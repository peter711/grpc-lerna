'use strict';

var require$$1$1 = require('process');
var require$$0$1 = require('tls');
var require$$0 = require('fs');
var require$$0$2 = require('os');
var require$$0$3 = require('net');
var require$$0$4 = require('events');
var require$$1$2 = require('stream');
var require$$1$3 = require('path');
var require$$0$5 = require('http2');
var require$$3$1 = require('http');
var require$$7 = require('url');
var require$$1$4 = require('dns');
var require$$2 = require('util');
var require$$0$6 = require('zlib');
var require$$3$2 = require('crypto');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var src$2 = {};

var callCredentials = {};

var metadata = {};

var logging$8 = {};

var constants = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(constants, "__esModule", { value: true });
constants.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = constants.DEFAULT_MAX_SEND_MESSAGE_LENGTH = constants.Propagate = constants.LogVerbosity = constants.Status = void 0;
var Status;
(function (Status) {
    Status[Status["OK"] = 0] = "OK";
    Status[Status["CANCELLED"] = 1] = "CANCELLED";
    Status[Status["UNKNOWN"] = 2] = "UNKNOWN";
    Status[Status["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status[Status["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status[Status["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status[Status["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status[Status["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status[Status["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status[Status["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status[Status["ABORTED"] = 10] = "ABORTED";
    Status[Status["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status[Status["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status[Status["INTERNAL"] = 13] = "INTERNAL";
    Status[Status["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status[Status["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status[Status["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(Status || (constants.Status = Status = {}));
var LogVerbosity;
(function (LogVerbosity) {
    LogVerbosity[LogVerbosity["DEBUG"] = 0] = "DEBUG";
    LogVerbosity[LogVerbosity["INFO"] = 1] = "INFO";
    LogVerbosity[LogVerbosity["ERROR"] = 2] = "ERROR";
    LogVerbosity[LogVerbosity["NONE"] = 3] = "NONE";
})(LogVerbosity || (constants.LogVerbosity = LogVerbosity = {}));
/**
 * NOTE: This enum is not currently used in any implemented API in this
 * library. It is included only for type parity with the other implementation.
 */
var Propagate;
(function (Propagate) {
    Propagate[Propagate["DEADLINE"] = 1] = "DEADLINE";
    Propagate[Propagate["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
    Propagate[Propagate["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
    Propagate[Propagate["CANCELLATION"] = 8] = "CANCELLATION";
    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43
    Propagate[Propagate["DEFAULTS"] = 65535] = "DEFAULTS";
})(Propagate || (constants.Propagate = Propagate = {}));
// -1 means unlimited
constants.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
// 4 MB default
constants.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;

var name$1 = "@grpc/grpc-js";
var version$2 = "1.10.6";
var description$1 = "gRPC Library for Node - pure JS implementation";
var homepage = "https://grpc.io/";
var repository$1 = "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js";
var main$2 = "build/src/index.js";
var engines$1 = {
	node: ">=12.10.0"
};
var keywords$1 = [
];
var author = {
	name: "Google Inc."
};
var types$2 = "build/src/index.d.ts";
var license$1 = "Apache-2.0";
var devDependencies$1 = {
	"@types/gulp": "^4.0.17",
	"@types/gulp-mocha": "0.0.37",
	"@types/lodash": "^4.14.202",
	"@types/mocha": "^10.0.6",
	"@types/ncp": "^2.0.8",
	"@types/node": ">=20.11.20",
	"@types/pify": "^5.0.4",
	"@types/semver": "^7.5.8",
	"@typescript-eslint/eslint-plugin": "^7.1.0",
	"@typescript-eslint/parser": "^7.1.0",
	"@typescript-eslint/typescript-estree": "^7.1.0",
	"clang-format": "^1.8.0",
	eslint: "^8.42.0",
	"eslint-config-prettier": "^8.8.0",
	"eslint-plugin-node": "^11.1.0",
	"eslint-plugin-prettier": "^4.2.1",
	execa: "^2.0.3",
	gulp: "^4.0.2",
	"gulp-mocha": "^6.0.0",
	lodash: "^4.17.21",
	madge: "^5.0.1",
	"mocha-jenkins-reporter": "^0.4.1",
	ncp: "^2.0.0",
	pify: "^4.0.1",
	prettier: "^2.8.8",
	rimraf: "^3.0.2",
	semver: "^7.6.0",
	"ts-node": "^10.9.2",
	typescript: "^5.3.3"
};
var contributors = [
	{
		name: "Google Inc."
	}
];
var scripts$1 = {
	build: "npm run compile",
	clean: "rimraf ./build",
	compile: "tsc -p .",
	format: "clang-format -i -style=\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\" src/*.ts test/*.ts",
	lint: "eslint src/*.ts test/*.ts",
	prepare: "npm run generate-types && npm run compile",
	test: "gulp test",
	check: "npm run lint",
	fix: "eslint --fix src/*.ts test/*.ts",
	pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
	posttest: "npm run check && madge -c ./build/src",
	"generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
	"generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
};
var dependencies = {
	"@grpc/proto-loader": "^0.7.10",
	"@js-sdsl/ordered-map": "^4.4.2"
};
var files = [
	"src/**/*.ts",
	"build/src/**/*.{js,d.ts,js.map}",
	"proto/*.proto",
	"LICENSE",
	"deps/envoy-api/envoy/api/v2/**/*.proto",
	"deps/envoy-api/envoy/config/**/*.proto",
	"deps/envoy-api/envoy/service/**/*.proto",
	"deps/envoy-api/envoy/type/**/*.proto",
	"deps/udpa/udpa/**/*.proto",
	"deps/googleapis/google/api/*.proto",
	"deps/googleapis/google/rpc/*.proto",
	"deps/protoc-gen-validate/validate/**/*.proto"
];
var require$$12 = {
	name: name$1,
	version: version$2,
	description: description$1,
	homepage: homepage,
	repository: repository$1,
	main: main$2,
	engines: engines$1,
	keywords: keywords$1,
	author: author,
	types: types$2,
	license: license$1,
	devDependencies: devDependencies$1,
	contributors: contributors,
	scripts: scripts$1,
	dependencies: dependencies,
	files: files
};

(function (exports) {
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var _a, _b, _c, _d;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;
	const constants_1 = constants;
	const process_1 = require$$1$1;
	const clientVersion = require$$12.version;
	const DEFAULT_LOGGER = {
	    error: (message, ...optionalParams) => {
	        console.error('E ' + message, ...optionalParams);
	    },
	    info: (message, ...optionalParams) => {
	        console.error('I ' + message, ...optionalParams);
	    },
	    debug: (message, ...optionalParams) => {
	        console.error('D ' + message, ...optionalParams);
	    },
	};
	let _logger = DEFAULT_LOGGER;
	let _logVerbosity = constants_1.LogVerbosity.ERROR;
	const verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';
	switch (verbosityString.toUpperCase()) {
	    case 'DEBUG':
	        _logVerbosity = constants_1.LogVerbosity.DEBUG;
	        break;
	    case 'INFO':
	        _logVerbosity = constants_1.LogVerbosity.INFO;
	        break;
	    case 'ERROR':
	        _logVerbosity = constants_1.LogVerbosity.ERROR;
	        break;
	    case 'NONE':
	        _logVerbosity = constants_1.LogVerbosity.NONE;
	        break;
	    // Ignore any other values
	}
	const getLogger = () => {
	    return _logger;
	};
	exports.getLogger = getLogger;
	const setLogger = (logger) => {
	    _logger = logger;
	};
	exports.setLogger = setLogger;
	const setLoggerVerbosity = (verbosity) => {
	    _logVerbosity = verbosity;
	};
	exports.setLoggerVerbosity = setLoggerVerbosity;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const log = (severity, ...args) => {
	    let logFunction;
	    if (severity >= _logVerbosity) {
	        switch (severity) {
	            case constants_1.LogVerbosity.DEBUG:
	                logFunction = _logger.debug;
	                break;
	            case constants_1.LogVerbosity.INFO:
	                logFunction = _logger.info;
	                break;
	            case constants_1.LogVerbosity.ERROR:
	                logFunction = _logger.error;
	                break;
	        }
	        /* Fall back to _logger.error when other methods are not available for
	         * compatiblity with older behavior that always logged to _logger.error */
	        if (!logFunction) {
	            logFunction = _logger.error;
	        }
	        if (logFunction) {
	            logFunction.bind(_logger)(...args);
	        }
	    }
	};
	exports.log = log;
	const tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';
	const enabledTracers = new Set();
	const disabledTracers = new Set();
	for (const tracerName of tracersString.split(',')) {
	    if (tracerName.startsWith('-')) {
	        disabledTracers.add(tracerName.substring(1));
	    }
	    else {
	        enabledTracers.add(tracerName);
	    }
	}
	const allEnabled = enabledTracers.has('all');
	function trace(severity, tracer, text) {
	    if (isTracerEnabled(tracer)) {
	        (0, exports.log)(severity, new Date().toISOString() +
	            ' | v' +
	            clientVersion +
	            ' ' +
	            process_1.pid +
	            ' | ' +
	            tracer +
	            ' | ' +
	            text);
	    }
	}
	exports.trace = trace;
	function isTracerEnabled(tracer) {
	    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));
	}
	exports.isTracerEnabled = isTracerEnabled;
	
} (logging$8));

var error = {};

/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(error, "__esModule", { value: true });
error.getErrorCode = error.getErrorMessage = void 0;
function getErrorMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    else {
        return String(error);
    }
}
error.getErrorMessage = getErrorMessage;
function getErrorCode(error) {
    if (typeof error === 'object' &&
        error !== null &&
        'code' in error &&
        typeof error.code === 'number') {
        return error.code;
    }
    else {
        return null;
    }
}
error.getErrorCode = getErrorCode;

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.Metadata = void 0;
const logging_1$1 = logging$8;
const constants_1$c = constants;
const error_1 = error;
const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
function isLegalKey(key) {
    return LEGAL_KEY_REGEX.test(key);
}
function isLegalNonBinaryValue(value) {
    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
}
function isBinaryKey(key) {
    return key.endsWith('-bin');
}
function isCustomMetadata(key) {
    return !key.startsWith('grpc-');
}
function normalizeKey(key) {
    return key.toLowerCase();
}
function validate(key, value) {
    if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
    }
    if (value !== null && value !== undefined) {
        if (isBinaryKey(key)) {
            if (!Buffer.isBuffer(value)) {
                throw new Error("keys that end with '-bin' must have Buffer values");
            }
        }
        else {
            if (Buffer.isBuffer(value)) {
                throw new Error("keys that don't end with '-bin' must have String values");
            }
            if (!isLegalNonBinaryValue(value)) {
                throw new Error('Metadata string value "' + value + '" contains illegal characters');
            }
        }
    }
}
/**
 * A class for storing metadata. Keys are normalized to lowercase ASCII.
 */
class Metadata {
    constructor(options = {}) {
        this.internalRepr = new Map();
        this.options = options;
    }
    /**
     * Sets the given value for the given key by replacing any other values
     * associated with that key. Normalizes the key.
     * @param key The key to whose value should be set.
     * @param value The value to set. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    set(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
    }
    /**
     * Adds the given value for the given key by appending to a list of previous
     * values associated with that key. Normalizes the key.
     * @param key The key for which a new value should be appended.
     * @param value The value to add. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    add(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === undefined) {
            this.internalRepr.set(key, [value]);
        }
        else {
            existingValue.push(value);
        }
    }
    /**
     * Removes the given key and any associated values. Normalizes the key.
     * @param key The key whose values should be removed.
     */
    remove(key) {
        key = normalizeKey(key);
        // validate(key);
        this.internalRepr.delete(key);
    }
    /**
     * Gets a list of all values associated with the key. Normalizes the key.
     * @param key The key whose value should be retrieved.
     * @return A list of values associated with the given key.
     */
    get(key) {
        key = normalizeKey(key);
        // validate(key);
        return this.internalRepr.get(key) || [];
    }
    /**
     * Gets a plain object mapping each key to the first value associated with it.
     * This reflects the most common way that people will want to see metadata.
     * @return A key/value mapping of the metadata.
     */
    getMap() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
            if (values.length > 0) {
                const v = values[0];
                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
            }
        }
        return result;
    }
    /**
     * Clones the metadata object.
     * @return The newly cloned object.
     */
    clone() {
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        for (const [key, value] of this.internalRepr) {
            const clonedValue = value.map(v => {
                if (Buffer.isBuffer(v)) {
                    return Buffer.from(v);
                }
                else {
                    return v;
                }
            });
            newInternalRepr.set(key, clonedValue);
        }
        return newMetadata;
    }
    /**
     * Merges all key-value pairs from a given Metadata object into this one.
     * If both this object and the given object have values in the same key,
     * values from the other Metadata object will be appended to this object's
     * values.
     * @param other A Metadata object.
     */
    merge(other) {
        for (const [key, values] of other.internalRepr) {
            const mergedValue = (this.internalRepr.get(key) || []).concat(values);
            this.internalRepr.set(key, mergedValue);
        }
    }
    setOptions(options) {
        this.options = options;
    }
    getOptions() {
        return this.options;
    }
    /**
     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
     */
    toHttp2Headers() {
        // NOTE: Node <8.9 formats http2 headers incorrectly.
        const result = {};
        for (const [key, values] of this.internalRepr) {
            // We assume that the user's interaction with this object is limited to
            // through its public API (i.e. keys and values are already validated).
            result[key] = values.map(bufToString);
        }
        return result;
    }
    /**
     * This modifies the behavior of JSON.stringify to show an object
     * representation of the metadata map.
     */
    toJSON() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
            result[key] = values;
        }
        return result;
    }
    /**
     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
     * object.
     * @param headers An IncomingHttpHeaders object.
     */
    static fromHttp2Headers(headers) {
        const result = new Metadata();
        for (const key of Object.keys(headers)) {
            // Reserved headers (beginning with `:`) are not valid keys.
            if (key.charAt(0) === ':') {
                continue;
            }
            const values = headers[key];
            try {
                if (isBinaryKey(key)) {
                    if (Array.isArray(values)) {
                        values.forEach(value => {
                            result.add(key, Buffer.from(value, 'base64'));
                        });
                    }
                    else if (values !== undefined) {
                        if (isCustomMetadata(key)) {
                            values.split(',').forEach(v => {
                                result.add(key, Buffer.from(v.trim(), 'base64'));
                            });
                        }
                        else {
                            result.add(key, Buffer.from(values, 'base64'));
                        }
                    }
                }
                else {
                    if (Array.isArray(values)) {
                        values.forEach(value => {
                            result.add(key, value);
                        });
                    }
                    else if (values !== undefined) {
                        result.add(key, values);
                    }
                }
            }
            catch (error) {
                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
                (0, logging_1$1.log)(constants_1$c.LogVerbosity.ERROR, message);
            }
        }
        return result;
    }
}
metadata.Metadata = Metadata;
const bufToString = (val) => {
    return Buffer.isBuffer(val) ? val.toString('base64') : val;
};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(callCredentials, "__esModule", { value: true });
callCredentials.CallCredentials = void 0;
const metadata_1$7 = metadata;
function isCurrentOauth2Client(client) {
    return ('getRequestHeaders' in client &&
        typeof client.getRequestHeaders === 'function');
}
/**
 * A class that represents a generic method of adding authentication-related
 * metadata on a per-request basis.
 */
class CallCredentials {
    /**
     * Creates a new CallCredentials object from a given function that generates
     * Metadata objects.
     * @param metadataGenerator A function that accepts a set of options, and
     * generates a Metadata object based on these options, which is passed back
     * to the caller via a supplied (err, metadata) callback.
     */
    static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
    }
    /**
     * Create a gRPC credential from a Google credential object.
     * @param googleCredentials The authentication client to use.
     * @return The resulting CallCredentials object.
     */
    static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options, callback) => {
            let getHeaders;
            if (isCurrentOauth2Client(googleCredentials)) {
                getHeaders = googleCredentials.getRequestHeaders(options.service_url);
            }
            else {
                getHeaders = new Promise((resolve, reject) => {
                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        if (!headers) {
                            reject(new Error('Headers not set by metadata plugin'));
                            return;
                        }
                        resolve(headers);
                    });
                });
            }
            getHeaders.then(headers => {
                const metadata = new metadata_1$7.Metadata();
                for (const key of Object.keys(headers)) {
                    metadata.add(key, headers[key]);
                }
                callback(null, metadata);
            }, err => {
                callback(err);
            });
        });
    }
    static createEmpty() {
        return new EmptyCallCredentials();
    }
}
callCredentials.CallCredentials = CallCredentials;
class ComposedCallCredentials extends CallCredentials {
    constructor(creds) {
        super();
        this.creds = creds;
    }
    async generateMetadata(options) {
        const base = new metadata_1$7.Metadata();
        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));
        for (const gen of generated) {
            base.merge(gen);
        }
        return base;
    }
    compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof ComposedCallCredentials) {
            return this.creds.every((value, index) => value._equals(other.creds[index]));
        }
        else {
            return false;
        }
    }
}
class SingleCallCredentials extends CallCredentials {
    constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
    }
    generateMetadata(options) {
        return new Promise((resolve, reject) => {
            this.metadataGenerator(options, (err, metadata) => {
                if (metadata !== undefined) {
                    resolve(metadata);
                }
                else {
                    reject(err);
                }
            });
        });
    }
    compose(other) {
        return new ComposedCallCredentials([this, other]);
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof SingleCallCredentials) {
            return this.metadataGenerator === other.metadataGenerator;
        }
        else {
            return false;
        }
    }
}
class EmptyCallCredentials extends CallCredentials {
    generateMetadata(options) {
        return Promise.resolve(new metadata_1$7.Metadata());
    }
    compose(other) {
        return other;
    }
    _equals(other) {
        return other instanceof EmptyCallCredentials;
    }
}

var channel = {};

var channelCredentials = {};

var tlsHelpers = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(tlsHelpers, "__esModule", { value: true });
tlsHelpers.getDefaultRootsData = tlsHelpers.CIPHER_SUITES = void 0;
const fs$1 = require$$0;
tlsHelpers.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
const DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
let defaultRootsData = null;
function getDefaultRootsData() {
    if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
            defaultRootsData = fs$1.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
    }
    return null;
}
tlsHelpers.getDefaultRootsData = getDefaultRootsData;

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(channelCredentials, "__esModule", { value: true });
channelCredentials.ChannelCredentials = void 0;
const tls_1 = require$$0$1;
const call_credentials_1 = callCredentials;
const tls_helpers_1$1 = tlsHelpers;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function verifyIsBufferOrNull(obj, friendlyName) {
    if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
    }
}
/**
 * A class that contains credentials for communicating over a channel, as well
 * as a set of per-call credentials, which are applied to every method call made
 * over a channel initialized with an instance of this class.
 */
class ChannelCredentials {
    constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
    }
    /**
     * Gets the set of per-call credentials associated with this instance.
     */
    _getCallCredentials() {
        return this.callCredentials;
    }
    /**
     * Return a new ChannelCredentials instance with a given set of credentials.
     * The resulting instance can be used to construct a Channel that communicates
     * over TLS.
     * @param rootCerts The root certificate data.
     * @param privateKey The client certificate private key, if available.
     * @param certChain The client certificate key chain, if available.
     * @param verifyOptions Additional options to modify certificate verification
     */
    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        var _a;
        verifyIsBufferOrNull(rootCerts, 'Root certificate');
        verifyIsBufferOrNull(privateKey, 'Private key');
        verifyIsBufferOrNull(certChain, 'Certificate chain');
        if (privateKey && !certChain) {
            throw new Error('Private key must be given with accompanying certificate chain');
        }
        if (!privateKey && certChain) {
            throw new Error('Certificate chain must be given with accompanying private key');
        }
        const secureContext = (0, tls_1.createSecureContext)({
            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1$1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,
            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,
            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,
            ciphers: tls_helpers_1$1.CIPHER_SUITES,
        });
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
    }
    /**
     * Return a new ChannelCredentials instance with credentials created using
     * the provided secureContext. The resulting instances can be used to
     * construct a Channel that communicates over TLS. gRPC will not override
     * anything in the provided secureContext, so the environment variables
     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
     * not be applied.
     * @param secureContext The return value of tls.createSecureContext()
     * @param verifyOptions Additional options to modify certificate verification
     */
    static createFromSecureContext(secureContext, verifyOptions) {
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
    }
    /**
     * Return a new ChannelCredentials instance with no credentials.
     */
    static createInsecure() {
        return new InsecureChannelCredentialsImpl();
    }
}
channelCredentials.ChannelCredentials = ChannelCredentials;
class InsecureChannelCredentialsImpl extends ChannelCredentials {
    constructor() {
        super();
    }
    compose(callCredentials) {
        throw new Error('Cannot compose insecure credentials');
    }
    _getConnectionOptions() {
        return null;
    }
    _isSecure() {
        return false;
    }
    _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
    }
}
class SecureChannelCredentialsImpl extends ChannelCredentials {
    constructor(secureContext, verifyOptions) {
        super();
        this.secureContext = secureContext;
        this.verifyOptions = verifyOptions;
        this.connectionOptions = {
            secureContext,
        };
        // Node asserts that this option is a function, so we cannot pass undefined
        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {
            this.connectionOptions.checkServerIdentity =
                verifyOptions.checkServerIdentity;
        }
    }
    compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
    }
    _getConnectionOptions() {
        // Copy to prevent callers from mutating this.connectionOptions
        return Object.assign({}, this.connectionOptions);
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
            return (this.secureContext === other.secureContext &&
                this.verifyOptions.checkServerIdentity ===
                    other.verifyOptions.checkServerIdentity);
        }
        else {
            return false;
        }
    }
}
class ComposedChannelCredentialsImpl extends ChannelCredentials {
    constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
    }
    compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
    }
    _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
            return (this.channelCredentials._equals(other.channelCredentials) &&
                this.callCredentials._equals(other.callCredentials));
        }
        else {
            return false;
        }
    }
}

var internalChannel = {};

var resolvingLoadBalancer = {};

var loadBalancer = {};

var hasRequiredLoadBalancer;

function requireLoadBalancer () {
	if (hasRequiredLoadBalancer) return loadBalancer;
	hasRequiredLoadBalancer = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancer, "__esModule", { value: true });
	loadBalancer.selectLbConfigFromList = loadBalancer.getDefaultConfig = loadBalancer.parseLoadBalancingConfig = loadBalancer.isLoadBalancerNameRegistered = loadBalancer.createLoadBalancer = loadBalancer.registerDefaultLoadBalancerType = loadBalancer.registerLoadBalancerType = loadBalancer.createChildChannelControlHelper = void 0;
	const logging_1 = logging$8;
	const constants_1 = constants;
	/**
	 * Create a child ChannelControlHelper that overrides some methods of the
	 * parent while letting others pass through to the parent unmodified. This
	 * allows other code to create these children without needing to know about
	 * all of the methods to be passed through.
	 * @param parent
	 * @param overrides
	 */
	function createChildChannelControlHelper(parent, overrides) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
	    return {
	        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),
	        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),
	        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),
	        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),
	        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),
	    };
	}
	loadBalancer.createChildChannelControlHelper = createChildChannelControlHelper;
	const registeredLoadBalancerTypes = {};
	let defaultLoadBalancerType = null;
	function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
	    registeredLoadBalancerTypes[typeName] = {
	        LoadBalancer: loadBalancerType,
	        LoadBalancingConfig: loadBalancingConfigType,
	    };
	}
	loadBalancer.registerLoadBalancerType = registerLoadBalancerType;
	function registerDefaultLoadBalancerType(typeName) {
	    defaultLoadBalancerType = typeName;
	}
	loadBalancer.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
	function createLoadBalancer(config, channelControlHelper, options) {
	    const typeName = config.getLoadBalancerName();
	    if (typeName in registeredLoadBalancerTypes) {
	        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper, options);
	    }
	    else {
	        return null;
	    }
	}
	loadBalancer.createLoadBalancer = createLoadBalancer;
	function isLoadBalancerNameRegistered(typeName) {
	    return typeName in registeredLoadBalancerTypes;
	}
	loadBalancer.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
	function parseLoadBalancingConfig(rawConfig) {
	    const keys = Object.keys(rawConfig);
	    if (keys.length !== 1) {
	        throw new Error('Provided load balancing config has multiple conflicting entries');
	    }
	    const typeName = keys[0];
	    if (typeName in registeredLoadBalancerTypes) {
	        try {
	            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
	        }
	        catch (e) {
	            throw new Error(`${typeName}: ${e.message}`);
	        }
	    }
	    else {
	        throw new Error(`Unrecognized load balancing config name ${typeName}`);
	    }
	}
	loadBalancer.parseLoadBalancingConfig = parseLoadBalancingConfig;
	function getDefaultConfig() {
	    if (!defaultLoadBalancerType) {
	        throw new Error('No default load balancer type registered');
	    }
	    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
	}
	loadBalancer.getDefaultConfig = getDefaultConfig;
	function selectLbConfigFromList(configs, fallbackTodefault = false) {
	    for (const config of configs) {
	        try {
	            return parseLoadBalancingConfig(config);
	        }
	        catch (e) {
	            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, 'Config parsing failed with error', e.message);
	            continue;
	        }
	    }
	    if (fallbackTodefault) {
	        if (defaultLoadBalancerType) {
	            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
	        }
	        else {
	            return null;
	        }
	    }
	    else {
	        return null;
	    }
	}
	loadBalancer.selectLbConfigFromList = selectLbConfigFromList;
	
	return loadBalancer;
}

var serviceConfig = {};

var hasRequiredServiceConfig;

function requireServiceConfig () {
	if (hasRequiredServiceConfig) return serviceConfig;
	hasRequiredServiceConfig = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serviceConfig, "__esModule", { value: true });
	serviceConfig.extractAndSelectServiceConfig = serviceConfig.validateServiceConfig = serviceConfig.validateRetryThrottling = void 0;
	/* This file implements gRFC A2 and the service config spec:
	 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
	 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
	 * function here takes an object with unknown structure and returns its
	 * specific object type if the input has the right structure, and throws an
	 * error otherwise. */
	/* The any type is purposely used here. All functions validate their input at
	 * runtime */
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const os = require$$0$2;
	const constants_1 = constants;
	/**
	 * Recognizes a number with up to 9 digits after the decimal point, followed by
	 * an "s", representing a number of seconds.
	 */
	const DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
	/**
	 * Client language name used for determining whether this client matches a
	 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
	 */
	const CLIENT_LANGUAGE_STRING = 'node';
	function validateName(obj) {
	    // In this context, and unset field and '' are considered the same
	    if ('service' in obj && obj.service !== '') {
	        if (typeof obj.service !== 'string') {
	            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
	        }
	        if ('method' in obj && obj.method !== '') {
	            if (typeof obj.method !== 'string') {
	                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
	            }
	            return {
	                service: obj.service,
	                method: obj.method,
	            };
	        }
	        else {
	            return {
	                service: obj.service,
	            };
	        }
	    }
	    else {
	        if ('method' in obj && obj.method !== undefined) {
	            throw new Error(`Invalid method config name: method set with empty or unset service`);
	        }
	        return {};
	    }
	}
	function validateRetryPolicy(obj) {
	    if (!('maxAttempts' in obj) ||
	        !Number.isInteger(obj.maxAttempts) ||
	        obj.maxAttempts < 2) {
	        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');
	    }
	    if (!('initialBackoff' in obj) ||
	        typeof obj.initialBackoff !== 'string' ||
	        !DURATION_REGEX.test(obj.initialBackoff)) {
	        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s');
	    }
	    if (!('maxBackoff' in obj) ||
	        typeof obj.maxBackoff !== 'string' ||
	        !DURATION_REGEX.test(obj.maxBackoff)) {
	        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s');
	    }
	    if (!('backoffMultiplier' in obj) ||
	        typeof obj.backoffMultiplier !== 'number' ||
	        obj.backoffMultiplier <= 0) {
	        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');
	    }
	    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {
	        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');
	    }
	    if (obj.retryableStatusCodes.length === 0) {
	        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');
	    }
	    for (const value of obj.retryableStatusCodes) {
	        if (typeof value === 'number') {
	            if (!Object.values(constants_1.Status).includes(value)) {
	                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');
	            }
	        }
	        else if (typeof value === 'string') {
	            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
	                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');
	            }
	        }
	        else {
	            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');
	        }
	    }
	    return {
	        maxAttempts: obj.maxAttempts,
	        initialBackoff: obj.initialBackoff,
	        maxBackoff: obj.maxBackoff,
	        backoffMultiplier: obj.backoffMultiplier,
	        retryableStatusCodes: obj.retryableStatusCodes,
	    };
	}
	function validateHedgingPolicy(obj) {
	    if (!('maxAttempts' in obj) ||
	        !Number.isInteger(obj.maxAttempts) ||
	        obj.maxAttempts < 2) {
	        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');
	    }
	    if ('hedgingDelay' in obj &&
	        (typeof obj.hedgingDelay !== 'string' ||
	            !DURATION_REGEX.test(obj.hedgingDelay))) {
	        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');
	    }
	    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {
	        for (const value of obj.nonFatalStatusCodes) {
	            if (typeof value === 'number') {
	                if (!Object.values(constants_1.Status).includes(value)) {
	                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not in status code range');
	                }
	            }
	            else if (typeof value === 'string') {
	                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
	                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not a status code name');
	                }
	            }
	            else {
	                throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number');
	            }
	        }
	    }
	    const result = {
	        maxAttempts: obj.maxAttempts,
	    };
	    if (obj.hedgingDelay) {
	        result.hedgingDelay = obj.hedgingDelay;
	    }
	    if (obj.nonFatalStatusCodes) {
	        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
	    }
	    return result;
	}
	function validateMethodConfig(obj) {
	    var _a;
	    const result = {
	        name: [],
	    };
	    if (!('name' in obj) || !Array.isArray(obj.name)) {
	        throw new Error('Invalid method config: invalid name array');
	    }
	    for (const name of obj.name) {
	        result.name.push(validateName(name));
	    }
	    if ('waitForReady' in obj) {
	        if (typeof obj.waitForReady !== 'boolean') {
	            throw new Error('Invalid method config: invalid waitForReady');
	        }
	        result.waitForReady = obj.waitForReady;
	    }
	    if ('timeout' in obj) {
	        if (typeof obj.timeout === 'object') {
	            if (!('seconds' in obj.timeout) ||
	                !(typeof obj.timeout.seconds === 'number')) {
	                throw new Error('Invalid method config: invalid timeout.seconds');
	            }
	            if (!('nanos' in obj.timeout) ||
	                !(typeof obj.timeout.nanos === 'number')) {
	                throw new Error('Invalid method config: invalid timeout.nanos');
	            }
	            result.timeout = obj.timeout;
	        }
	        else if (typeof obj.timeout === 'string' &&
	            DURATION_REGEX.test(obj.timeout)) {
	            const timeoutParts = obj.timeout
	                .substring(0, obj.timeout.length - 1)
	                .split('.');
	            result.timeout = {
	                seconds: timeoutParts[0] | 0,
	                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,
	            };
	        }
	        else {
	            throw new Error('Invalid method config: invalid timeout');
	        }
	    }
	    if ('maxRequestBytes' in obj) {
	        if (typeof obj.maxRequestBytes !== 'number') {
	            throw new Error('Invalid method config: invalid maxRequestBytes');
	        }
	        result.maxRequestBytes = obj.maxRequestBytes;
	    }
	    if ('maxResponseBytes' in obj) {
	        if (typeof obj.maxResponseBytes !== 'number') {
	            throw new Error('Invalid method config: invalid maxRequestBytes');
	        }
	        result.maxResponseBytes = obj.maxResponseBytes;
	    }
	    if ('retryPolicy' in obj) {
	        if ('hedgingPolicy' in obj) {
	            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');
	        }
	        else {
	            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
	        }
	    }
	    else if ('hedgingPolicy' in obj) {
	        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
	    }
	    return result;
	}
	function validateRetryThrottling(obj) {
	    if (!('maxTokens' in obj) ||
	        typeof obj.maxTokens !== 'number' ||
	        obj.maxTokens <= 0 ||
	        obj.maxTokens > 1000) {
	        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');
	    }
	    if (!('tokenRatio' in obj) ||
	        typeof obj.tokenRatio !== 'number' ||
	        obj.tokenRatio <= 0) {
	        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');
	    }
	    return {
	        maxTokens: +obj.maxTokens.toFixed(3),
	        tokenRatio: +obj.tokenRatio.toFixed(3),
	    };
	}
	serviceConfig.validateRetryThrottling = validateRetryThrottling;
	function validateLoadBalancingConfig(obj) {
	    if (!(typeof obj === 'object' && obj !== null)) {
	        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
	    }
	    const keys = Object.keys(obj);
	    if (keys.length > 1) {
	        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);
	    }
	    if (keys.length === 0) {
	        throw new Error('Invalid loadBalancingConfig: load balancing policy name required');
	    }
	    return {
	        [keys[0]]: obj[keys[0]],
	    };
	}
	function validateServiceConfig(obj) {
	    const result = {
	        loadBalancingConfig: [],
	        methodConfig: [],
	    };
	    if ('loadBalancingPolicy' in obj) {
	        if (typeof obj.loadBalancingPolicy === 'string') {
	            result.loadBalancingPolicy = obj.loadBalancingPolicy;
	        }
	        else {
	            throw new Error('Invalid service config: invalid loadBalancingPolicy');
	        }
	    }
	    if ('loadBalancingConfig' in obj) {
	        if (Array.isArray(obj.loadBalancingConfig)) {
	            for (const config of obj.loadBalancingConfig) {
	                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));
	            }
	        }
	        else {
	            throw new Error('Invalid service config: invalid loadBalancingConfig');
	        }
	    }
	    if ('methodConfig' in obj) {
	        if (Array.isArray(obj.methodConfig)) {
	            for (const methodConfig of obj.methodConfig) {
	                result.methodConfig.push(validateMethodConfig(methodConfig));
	            }
	        }
	    }
	    if ('retryThrottling' in obj) {
	        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
	    }
	    // Validate method name uniqueness
	    const seenMethodNames = [];
	    for (const methodConfig of result.methodConfig) {
	        for (const name of methodConfig.name) {
	            for (const seenName of seenMethodNames) {
	                if (name.service === seenName.service &&
	                    name.method === seenName.method) {
	                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
	                }
	            }
	            seenMethodNames.push(name);
	        }
	    }
	    return result;
	}
	serviceConfig.validateServiceConfig = validateServiceConfig;
	function validateCanaryConfig(obj) {
	    if (!('serviceConfig' in obj)) {
	        throw new Error('Invalid service config choice: missing service config');
	    }
	    const result = {
	        serviceConfig: validateServiceConfig(obj.serviceConfig),
	    };
	    if ('clientLanguage' in obj) {
	        if (Array.isArray(obj.clientLanguage)) {
	            result.clientLanguage = [];
	            for (const lang of obj.clientLanguage) {
	                if (typeof lang === 'string') {
	                    result.clientLanguage.push(lang);
	                }
	                else {
	                    throw new Error('Invalid service config choice: invalid clientLanguage');
	                }
	            }
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid clientLanguage');
	        }
	    }
	    if ('clientHostname' in obj) {
	        if (Array.isArray(obj.clientHostname)) {
	            result.clientHostname = [];
	            for (const lang of obj.clientHostname) {
	                if (typeof lang === 'string') {
	                    result.clientHostname.push(lang);
	                }
	                else {
	                    throw new Error('Invalid service config choice: invalid clientHostname');
	                }
	            }
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid clientHostname');
	        }
	    }
	    if ('percentage' in obj) {
	        if (typeof obj.percentage === 'number' &&
	            0 <= obj.percentage &&
	            obj.percentage <= 100) {
	            result.percentage = obj.percentage;
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid percentage');
	        }
	    }
	    // Validate that no unexpected fields are present
	    const allowedFields = [
	        'clientLanguage',
	        'percentage',
	        'clientHostname',
	        'serviceConfig',
	    ];
	    for (const field in obj) {
	        if (!allowedFields.includes(field)) {
	            throw new Error(`Invalid service config choice: unexpected field ${field}`);
	        }
	    }
	    return result;
	}
	function validateAndSelectCanaryConfig(obj, percentage) {
	    if (!Array.isArray(obj)) {
	        throw new Error('Invalid service config list');
	    }
	    for (const config of obj) {
	        const validatedConfig = validateCanaryConfig(config);
	        /* For each field, we check if it is present, then only discard the
	         * config if the field value does not match the current client */
	        if (typeof validatedConfig.percentage === 'number' &&
	            percentage > validatedConfig.percentage) {
	            continue;
	        }
	        if (Array.isArray(validatedConfig.clientHostname)) {
	            let hostnameMatched = false;
	            for (const hostname of validatedConfig.clientHostname) {
	                if (hostname === os.hostname()) {
	                    hostnameMatched = true;
	                }
	            }
	            if (!hostnameMatched) {
	                continue;
	            }
	        }
	        if (Array.isArray(validatedConfig.clientLanguage)) {
	            let languageMatched = false;
	            for (const language of validatedConfig.clientLanguage) {
	                if (language === CLIENT_LANGUAGE_STRING) {
	                    languageMatched = true;
	                }
	            }
	            if (!languageMatched) {
	                continue;
	            }
	        }
	        return validatedConfig.serviceConfig;
	    }
	    throw new Error('No matching service config found');
	}
	/**
	 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
	 * and select a service config with selection fields that all match this client. Most of these steps
	 * can fail with an error; the caller must handle any errors thrown this way.
	 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
	 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
	 * @return The service configuration to use, given the percentage value, or null if the service config
	 *     data has a valid format but none of the options match the current client.
	 */
	function extractAndSelectServiceConfig(txtRecord, percentage) {
	    for (const record of txtRecord) {
	        if (record.length > 0 && record[0].startsWith('grpc_config=')) {
	            /* Treat the list of strings in this record as a single string and remove
	             * "grpc_config=" from the beginning. The rest should be a JSON string */
	            const recordString = record.join('').substring('grpc_config='.length);
	            const recordJson = JSON.parse(recordString);
	            return validateAndSelectCanaryConfig(recordJson, percentage);
	        }
	    }
	    return null;
	}
	serviceConfig.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
	
	return serviceConfig;
}

var connectivityState = {};

/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(connectivityState, "__esModule", { value: true });
connectivityState.ConnectivityState = void 0;
var ConnectivityState;
(function (ConnectivityState) {
    ConnectivityState[ConnectivityState["IDLE"] = 0] = "IDLE";
    ConnectivityState[ConnectivityState["CONNECTING"] = 1] = "CONNECTING";
    ConnectivityState[ConnectivityState["READY"] = 2] = "READY";
    ConnectivityState[ConnectivityState["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
    ConnectivityState[ConnectivityState["SHUTDOWN"] = 4] = "SHUTDOWN";
})(ConnectivityState || (connectivityState.ConnectivityState = ConnectivityState = {}));

var resolver = {};

var uriParser = {};

/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(uriParser, "__esModule", { value: true });
uriParser.uriToString = uriParser.combineHostPort = uriParser.splitHostPort = uriParser.parseUri = void 0;
/*
 * The groups correspond to URI parts as follows:
 * 1. scheme
 * 2. authority
 * 3. path
 */
const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
function parseUri(uriString) {
    const parsedUri = URI_REGEX.exec(uriString);
    if (parsedUri === null) {
        return null;
    }
    return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3],
    };
}
uriParser.parseUri = parseUri;
const NUMBER_REGEX = /^\d+$/;
function splitHostPort(path) {
    if (path.startsWith('[')) {
        const hostEnd = path.indexOf(']');
        if (hostEnd === -1) {
            return null;
        }
        const host = path.substring(1, hostEnd);
        /* Only an IPv6 address should be in bracketed notation, and an IPv6
         * address should have at least one colon */
        if (host.indexOf(':') === -1) {
            return null;
        }
        if (path.length > hostEnd + 1) {
            if (path[hostEnd + 1] === ':') {
                const portString = path.substring(hostEnd + 2);
                if (NUMBER_REGEX.test(portString)) {
                    return {
                        host: host,
                        port: +portString,
                    };
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        else {
            return {
                host,
            };
        }
    }
    else {
        const splitPath = path.split(':');
        /* Exactly one colon means that this is host:port. Zero colons means that
         * there is no port. And multiple colons means that this is a bare IPv6
         * address with no port */
        if (splitPath.length === 2) {
            if (NUMBER_REGEX.test(splitPath[1])) {
                return {
                    host: splitPath[0],
                    port: +splitPath[1],
                };
            }
            else {
                return null;
            }
        }
        else {
            return {
                host: path,
            };
        }
    }
}
uriParser.splitHostPort = splitHostPort;
function combineHostPort(hostPort) {
    if (hostPort.port === undefined) {
        return hostPort.host;
    }
    else {
        // Only an IPv6 host should include a colon
        if (hostPort.host.includes(':')) {
            return `[${hostPort.host}]:${hostPort.port}`;
        }
        else {
            return `${hostPort.host}:${hostPort.port}`;
        }
    }
}
uriParser.combineHostPort = combineHostPort;
function uriToString(uri) {
    let result = '';
    if (uri.scheme !== undefined) {
        result += uri.scheme + ':';
    }
    if (uri.authority !== undefined) {
        result += '//' + uri.authority + '/';
    }
    result += uri.path;
    return result;
}
uriParser.uriToString = uriToString;

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(resolver, "__esModule", { value: true });
resolver.mapUriDefaultScheme = resolver.getDefaultAuthority = resolver.createResolver = resolver.registerDefaultScheme = resolver.registerResolver = void 0;
const uri_parser_1$4 = uriParser;
const registeredResolvers = {};
let defaultScheme = null;
/**
 * Register a resolver class to handle target names prefixed with the `prefix`
 * string. This prefix should correspond to a URI scheme name listed in the
 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 * @param prefix
 * @param resolverClass
 */
function registerResolver(scheme, resolverClass) {
    registeredResolvers[scheme] = resolverClass;
}
resolver.registerResolver = registerResolver;
/**
 * Register a default resolver to handle target names that do not start with
 * any registered prefix.
 * @param resolverClass
 */
function registerDefaultScheme(scheme) {
    defaultScheme = scheme;
}
resolver.registerDefaultScheme = registerDefaultScheme;
/**
 * Create a name resolver for the specified target, if possible. Throws an
 * error if no such name resolver can be created.
 * @param target
 * @param listener
 */
function createResolver(target, listener, options) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
    }
    else {
        throw new Error(`No resolver could be created for target ${(0, uri_parser_1$4.uriToString)(target)}`);
    }
}
resolver.createResolver = createResolver;
/**
 * Get the default authority for the specified target, if possible. Throws an
 * error if no registered name resolver can parse that target string.
 * @param target
 */
function getDefaultAuthority(target) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
    }
    else {
        throw new Error(`Invalid target ${(0, uri_parser_1$4.uriToString)(target)}`);
    }
}
resolver.getDefaultAuthority = getDefaultAuthority;
function mapUriDefaultScheme(target) {
    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
            return {
                scheme: defaultScheme,
                authority: undefined,
                path: (0, uri_parser_1$4.uriToString)(target),
            };
        }
        else {
            return null;
        }
    }
    return target;
}
resolver.mapUriDefaultScheme = mapUriDefaultScheme;

var picker = {};

var hasRequiredPicker;

function requirePicker () {
	if (hasRequiredPicker) return picker;
	hasRequiredPicker = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(picker, "__esModule", { value: true });
	picker.QueuePicker = picker.UnavailablePicker = picker.PickResultType = void 0;
	const metadata_1 = metadata;
	const constants_1 = constants;
	var PickResultType;
	(function (PickResultType) {
	    PickResultType[PickResultType["COMPLETE"] = 0] = "COMPLETE";
	    PickResultType[PickResultType["QUEUE"] = 1] = "QUEUE";
	    PickResultType[PickResultType["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
	    PickResultType[PickResultType["DROP"] = 3] = "DROP";
	})(PickResultType || (picker.PickResultType = PickResultType = {}));
	/**
	 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
	 * state. Always responds to every pick request with an UNAVAILABLE status.
	 */
	class UnavailablePicker {
	    constructor(status) {
	        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);
	    }
	    pick(pickArgs) {
	        return {
	            pickResultType: PickResultType.TRANSIENT_FAILURE,
	            subchannel: null,
	            status: this.status,
	            onCallStarted: null,
	            onCallEnded: null,
	        };
	    }
	}
	picker.UnavailablePicker = UnavailablePicker;
	/**
	 * A standard picker representing a load balancer in the IDLE or CONNECTING
	 * state. Always responds to every pick request with a QUEUE pick result
	 * indicating that the pick should be tried again with the next `Picker`. Also
	 * reports back to the load balancer that a connection should be established
	 * once any pick is attempted.
	 * If the childPicker is provided, delegate to it instead of returning the
	 * hardcoded QUEUE pick result, but still calls exitIdle.
	 */
	class QueuePicker {
	    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
	    constructor(loadBalancer, childPicker) {
	        this.loadBalancer = loadBalancer;
	        this.childPicker = childPicker;
	        this.calledExitIdle = false;
	    }
	    pick(pickArgs) {
	        if (!this.calledExitIdle) {
	            process.nextTick(() => {
	                this.loadBalancer.exitIdle();
	            });
	            this.calledExitIdle = true;
	        }
	        if (this.childPicker) {
	            return this.childPicker.pick(pickArgs);
	        }
	        else {
	            return {
	                pickResultType: PickResultType.QUEUE,
	                subchannel: null,
	                status: null,
	                onCallStarted: null,
	                onCallEnded: null,
	            };
	        }
	    }
	}
	picker.QueuePicker = QueuePicker;
	
	return picker;
}

var backoffTimeout = {};

var hasRequiredBackoffTimeout;

function requireBackoffTimeout () {
	if (hasRequiredBackoffTimeout) return backoffTimeout;
	hasRequiredBackoffTimeout = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(backoffTimeout, "__esModule", { value: true });
	backoffTimeout.BackoffTimeout = void 0;
	const INITIAL_BACKOFF_MS = 1000;
	const BACKOFF_MULTIPLIER = 1.6;
	const MAX_BACKOFF_MS = 120000;
	const BACKOFF_JITTER = 0.2;
	/**
	 * Get a number uniformly at random in the range [min, max)
	 * @param min
	 * @param max
	 */
	function uniformRandom(min, max) {
	    return Math.random() * (max - min) + min;
	}
	class BackoffTimeout {
	    constructor(callback, options) {
	        this.callback = callback;
	        /**
	         * The delay time at the start, and after each reset.
	         */
	        this.initialDelay = INITIAL_BACKOFF_MS;
	        /**
	         * The exponential backoff multiplier.
	         */
	        this.multiplier = BACKOFF_MULTIPLIER;
	        /**
	         * The maximum delay time
	         */
	        this.maxDelay = MAX_BACKOFF_MS;
	        /**
	         * The maximum fraction by which the delay time can randomly vary after
	         * applying the multiplier.
	         */
	        this.jitter = BACKOFF_JITTER;
	        /**
	         * Indicates whether the timer is currently running.
	         */
	        this.running = false;
	        /**
	         * Indicates whether the timer should keep the Node process running if no
	         * other async operation is doing so.
	         */
	        this.hasRef = true;
	        /**
	         * The time that the currently running timer was started. Only valid if
	         * running is true.
	         */
	        this.startTime = new Date();
	        /**
	         * The approximate time that the currently running timer will end. Only valid
	         * if running is true.
	         */
	        this.endTime = new Date();
	        if (options) {
	            if (options.initialDelay) {
	                this.initialDelay = options.initialDelay;
	            }
	            if (options.multiplier) {
	                this.multiplier = options.multiplier;
	            }
	            if (options.jitter) {
	                this.jitter = options.jitter;
	            }
	            if (options.maxDelay) {
	                this.maxDelay = options.maxDelay;
	            }
	        }
	        this.nextDelay = this.initialDelay;
	        this.timerId = setTimeout(() => { }, 0);
	        clearTimeout(this.timerId);
	    }
	    runTimer(delay) {
	        var _a, _b;
	        this.endTime = this.startTime;
	        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);
	        clearTimeout(this.timerId);
	        this.timerId = setTimeout(() => {
	            this.callback();
	            this.running = false;
	        }, delay);
	        if (!this.hasRef) {
	            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	        }
	    }
	    /**
	     * Call the callback after the current amount of delay time
	     */
	    runOnce() {
	        this.running = true;
	        this.startTime = new Date();
	        this.runTimer(this.nextDelay);
	        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
	        const jitterMagnitude = nextBackoff * this.jitter;
	        this.nextDelay =
	            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
	    }
	    /**
	     * Stop the timer. The callback will not be called until `runOnce` is called
	     * again.
	     */
	    stop() {
	        clearTimeout(this.timerId);
	        this.running = false;
	    }
	    /**
	     * Reset the delay time to its initial value. If the timer is still running,
	     * retroactively apply that reset to the current timer.
	     */
	    reset() {
	        this.nextDelay = this.initialDelay;
	        if (this.running) {
	            const now = new Date();
	            const newEndTime = this.startTime;
	            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
	            clearTimeout(this.timerId);
	            if (now < newEndTime) {
	                this.runTimer(newEndTime.getTime() - now.getTime());
	            }
	            else {
	                this.running = false;
	            }
	        }
	    }
	    /**
	     * Check whether the timer is currently running.
	     */
	    isRunning() {
	        return this.running;
	    }
	    /**
	     * Set that while the timer is running, it should keep the Node process
	     * running.
	     */
	    ref() {
	        var _a, _b;
	        this.hasRef = true;
	        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    /**
	     * Set that while the timer is running, it should not keep the Node process
	     * running.
	     */
	    unref() {
	        var _a, _b;
	        this.hasRef = false;
	        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    /**
	     * Get the approximate timestamp of when the timer will fire. Only valid if
	     * this.isRunning() is true.
	     */
	    getEndTime() {
	        return this.endTime;
	    }
	}
	backoffTimeout.BackoffTimeout = BackoffTimeout;
	
	return backoffTimeout;
}

var loadBalancerChildHandler = {};

var hasRequiredLoadBalancerChildHandler;

function requireLoadBalancerChildHandler () {
	if (hasRequiredLoadBalancerChildHandler) return loadBalancerChildHandler;
	hasRequiredLoadBalancerChildHandler = 1;
	/*
	 * Copyright 2020 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerChildHandler, "__esModule", { value: true });
	loadBalancerChildHandler.ChildLoadBalancerHandler = void 0;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = connectivityState;
	const TYPE_NAME = 'child_load_balancer_helper';
	class ChildLoadBalancerHandler {
	    constructor(channelControlHelper, options) {
	        this.channelControlHelper = channelControlHelper;
	        this.options = options;
	        this.currentChild = null;
	        this.pendingChild = null;
	        this.latestConfig = null;
	        this.ChildPolicyHelper = class {
	            constructor(parent) {
	                this.parent = parent;
	                this.child = null;
	            }
	            createSubchannel(subchannelAddress, subchannelArgs) {
	                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
	            }
	            updateState(connectivityState, picker) {
	                var _a;
	                if (this.calledByPendingChild()) {
	                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
	                        return;
	                    }
	                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
	                    this.parent.currentChild = this.parent.pendingChild;
	                    this.parent.pendingChild = null;
	                }
	                else if (!this.calledByCurrentChild()) {
	                    return;
	                }
	                this.parent.channelControlHelper.updateState(connectivityState, picker);
	            }
	            requestReresolution() {
	                var _a;
	                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
	                if (this.child === latestChild) {
	                    this.parent.channelControlHelper.requestReresolution();
	                }
	            }
	            setChild(newChild) {
	                this.child = newChild;
	            }
	            addChannelzChild(child) {
	                this.parent.channelControlHelper.addChannelzChild(child);
	            }
	            removeChannelzChild(child) {
	                this.parent.channelControlHelper.removeChannelzChild(child);
	            }
	            calledByPendingChild() {
	                return this.child === this.parent.pendingChild;
	            }
	            calledByCurrentChild() {
	                return this.child === this.parent.currentChild;
	            }
	        };
	    }
	    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
	        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
	    }
	    /**
	     * Prerequisites: lbConfig !== null and lbConfig.name is registered
	     * @param endpointList
	     * @param lbConfig
	     * @param attributes
	     */
	    updateAddressList(endpointList, lbConfig, attributes) {
	        let childToUpdate;
	        if (this.currentChild === null ||
	            this.latestConfig === null ||
	            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
	            const newHelper = new this.ChildPolicyHelper(this);
	            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper, this.options);
	            newHelper.setChild(newChild);
	            if (this.currentChild === null) {
	                this.currentChild = newChild;
	                childToUpdate = this.currentChild;
	            }
	            else {
	                if (this.pendingChild) {
	                    this.pendingChild.destroy();
	                }
	                this.pendingChild = newChild;
	                childToUpdate = this.pendingChild;
	            }
	        }
	        else {
	            if (this.pendingChild === null) {
	                childToUpdate = this.currentChild;
	            }
	            else {
	                childToUpdate = this.pendingChild;
	            }
	        }
	        this.latestConfig = lbConfig;
	        childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
	    }
	    exitIdle() {
	        if (this.currentChild) {
	            this.currentChild.exitIdle();
	            if (this.pendingChild) {
	                this.pendingChild.exitIdle();
	            }
	        }
	    }
	    resetBackoff() {
	        if (this.currentChild) {
	            this.currentChild.resetBackoff();
	            if (this.pendingChild) {
	                this.pendingChild.resetBackoff();
	            }
	        }
	    }
	    destroy() {
	        /* Note: state updates are only propagated from the child balancer if that
	         * object is equal to this.currentChild or this.pendingChild. Since this
	         * function sets both of those to null, no further state updates will
	         * occur after this function returns. */
	        if (this.currentChild) {
	            this.currentChild.destroy();
	            this.currentChild = null;
	        }
	        if (this.pendingChild) {
	            this.pendingChild.destroy();
	            this.pendingChild = null;
	        }
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerChildHandler.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
	
	return loadBalancerChildHandler;
}

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(resolvingLoadBalancer, "__esModule", { value: true });
resolvingLoadBalancer.ResolvingLoadBalancer = void 0;
const load_balancer_1 = requireLoadBalancer();
const service_config_1 = requireServiceConfig();
const connectivity_state_1$1 = connectivityState;
const resolver_1$2 = resolver;
const picker_1$1 = requirePicker();
const backoff_timeout_1 = requireBackoffTimeout();
const constants_1$b = constants;
const metadata_1$6 = metadata;
const logging$7 = logging$8;
const constants_2$1 = constants;
const uri_parser_1$3 = uriParser;
const load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
const TRACER_NAME$6 = 'resolving_load_balancer';
function trace$1(text) {
    logging$7.trace(constants_2$1.LogVerbosity.DEBUG, TRACER_NAME$6, text);
}
/**
 * Name match levels in order from most to least specific. This is the order in
 * which searches will be performed.
 */
const NAME_MATCH_LEVEL_ORDER = [
    'SERVICE_AND_METHOD',
    'SERVICE',
    'EMPTY',
];
function hasMatchingName(service, method, methodConfig, matchLevel) {
    for (const name of methodConfig.name) {
        switch (matchLevel) {
            case 'EMPTY':
                if (!name.service && !name.method) {
                    return true;
                }
                break;
            case 'SERVICE':
                if (name.service === service && !name.method) {
                    return true;
                }
                break;
            case 'SERVICE_AND_METHOD':
                if (name.service === service && name.method === method) {
                    return true;
                }
        }
    }
    return false;
}
function findMatchingConfig(service, method, methodConfigs, matchLevel) {
    for (const config of methodConfigs) {
        if (hasMatchingName(service, method, config, matchLevel)) {
            return config;
        }
    }
    return null;
}
function getDefaultConfigSelector(serviceConfig) {
    return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split('/').filter(x => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';
        if (serviceConfig && serviceConfig.methodConfig) {
            /* Check for the following in order, and return the first method
             * config that matches:
             * 1. A name that exactly matches the service and method
             * 2. A name with no method set that matches the service
             * 3. An empty name
             */
            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);
                if (matchingConfig) {
                    return {
                        methodConfig: matchingConfig,
                        pickInformation: {},
                        status: constants_1$b.Status.OK,
                        dynamicFilterFactories: [],
                    };
                }
            }
        }
        return {
            methodConfig: { name: [] },
            pickInformation: {},
            status: constants_1$b.Status.OK,
            dynamicFilterFactories: [],
        };
    };
}
class ResolvingLoadBalancer {
    /**
     * Wrapper class that behaves like a `LoadBalancer` and also handles name
     * resolution internally.
     * @param target The address of the backend to connect to.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     * @param defaultServiceConfig The default service configuration to be used
     *     if none is provided by the name resolver. A `null` value indicates
     *     that the default behavior should be the default unconfigured behavior.
     *     In practice, that means using the "pick first" load balancer
     *     implmentation
     */
    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = connectivity_state_1$1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1$1.QueuePicker(this);
        /**
         * This resolving load balancer's current connectivity state.
         */
        this.currentState = connectivity_state_1$1.ConnectivityState.IDLE;
        /**
         * The service config object from the last successful resolution, if
         * available. A value of null indicates that we have not yet received a valid
         * service config from the resolver.
         */
        this.previousServiceConfig = null;
        /**
         * Indicates whether we should attempt to resolve again after the backoff
         * timer runs out.
         */
        this.continueResolving = false;
        if (channelOptions['grpc.service_config']) {
            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));
        }
        else {
            this.defaultServiceConfig = {
                loadBalancingConfig: [],
                methodConfig: [],
            };
        }
        this.updateState(connectivity_state_1$1.ConnectivityState.IDLE, new picker_1$1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
            requestReresolution: () => {
                /* If the backoffTimeout is running, we're still backing off from
                 * making resolve requests, so we shouldn't make another one here.
                 * In that case, the backoff timer callback will call
                 * updateResolution */
                if (this.backoffTimeout.isRunning()) {
                    trace$1('requestReresolution delayed by backoff timer until ' +
                        this.backoffTimeout.getEndTime().toISOString());
                    this.continueResolving = true;
                }
                else {
                    this.updateResolution();
                }
            },
            updateState: (newState, picker) => {
                this.latestChildState = newState;
                this.latestChildPicker = picker;
                this.updateState(newState, picker);
            },
            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),
        }, channelOptions);
        this.innerResolver = (0, resolver_1$2.createResolver)(target, {
            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
                var _a;
                this.backoffTimeout.stop();
                this.backoffTimeout.reset();
                let workingServiceConfig = null;
                /* This first group of conditionals implements the algorithm described
                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
                 * in the section called "Behavior on receiving a new gRPC Config".
                 */
                if (serviceConfig === null) {
                    // Step 4 and 5
                    if (serviceConfigError === null) {
                        // Step 5
                        this.previousServiceConfig = null;
                        workingServiceConfig = this.defaultServiceConfig;
                    }
                    else {
                        // Step 4
                        if (this.previousServiceConfig === null) {
                            // Step 4.ii
                            this.handleResolutionFailure(serviceConfigError);
                        }
                        else {
                            // Step 4.i
                            workingServiceConfig = this.previousServiceConfig;
                        }
                    }
                }
                else {
                    // Step 3
                    workingServiceConfig = serviceConfig;
                    this.previousServiceConfig = serviceConfig;
                }
                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
                const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
                if (loadBalancingConfig === null) {
                    // There were load balancing configs but none are supported. This counts as a resolution failure
                    this.handleResolutionFailure({
                        code: constants_1$b.Status.UNAVAILABLE,
                        details: 'All load balancer options in service config are not compatible',
                        metadata: new metadata_1$6.Metadata(),
                    });
                    return;
                }
                this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, attributes);
                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
            },
            onError: (error) => {
                this.handleResolutionFailure(error);
            },
        }, channelOptions);
        const backoffOptions = {
            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
            if (this.continueResolving) {
                this.updateResolution();
                this.continueResolving = false;
            }
            else {
                this.updateState(this.latestChildState, this.latestChildPicker);
            }
        }, backoffOptions);
        this.backoffTimeout.unref();
    }
    updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === connectivity_state_1$1.ConnectivityState.IDLE) {
            /* this.latestChildPicker is initialized as new QueuePicker(this), which
             * is an appropriate value here if the child LB policy is unset.
             * Otherwise, we want to delegate to the child here, in case that
             * triggers something. */
            this.updateState(connectivity_state_1$1.ConnectivityState.CONNECTING, this.latestChildPicker);
        }
        this.backoffTimeout.runOnce();
    }
    updateState(connectivityState, picker) {
        trace$1((0, uri_parser_1$3.uriToString)(this.target) +
            ' ' +
            connectivity_state_1$1.ConnectivityState[this.currentState] +
            ' -> ' +
            connectivity_state_1$1.ConnectivityState[connectivityState]);
        // Ensure that this.exitIdle() is called by the picker
        if (connectivityState === connectivity_state_1$1.ConnectivityState.IDLE) {
            picker = new picker_1$1.QueuePicker(this, picker);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
    }
    handleResolutionFailure(error) {
        if (this.latestChildState === connectivity_state_1$1.ConnectivityState.IDLE) {
            this.updateState(connectivity_state_1$1.ConnectivityState.TRANSIENT_FAILURE, new picker_1$1.UnavailablePicker(error));
            this.onFailedResolution(error);
        }
    }
    exitIdle() {
        if (this.currentState === connectivity_state_1$1.ConnectivityState.IDLE ||
            this.currentState === connectivity_state_1$1.ConnectivityState.TRANSIENT_FAILURE) {
            if (this.backoffTimeout.isRunning()) {
                this.continueResolving = true;
            }
            else {
                this.updateResolution();
            }
        }
        this.childLoadBalancer.exitIdle();
    }
    updateAddressList(endpointList, lbConfig) {
        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
    }
    resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
    }
    destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.backoffTimeout.reset();
        this.backoffTimeout.stop();
        this.latestChildState = connectivity_state_1$1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1$1.QueuePicker(this);
        this.currentState = connectivity_state_1$1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
    }
    getTypeName() {
        return 'resolving_load_balancer';
    }
}
resolvingLoadBalancer.ResolvingLoadBalancer = ResolvingLoadBalancer;

var subchannelPool = {};

var channelOptions = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(channelOptions, "__esModule", { value: true });
channelOptions.channelOptionsEqual = channelOptions.recognizedOptions = void 0;
/**
 * This is for checking provided options at runtime. This is an object for
 * easier membership checking.
 */
channelOptions.recognizedOptions = {
    'grpc.ssl_target_name_override': true,
    'grpc.primary_user_agent': true,
    'grpc.secondary_user_agent': true,
    'grpc.default_authority': true,
    'grpc.keepalive_time_ms': true,
    'grpc.keepalive_timeout_ms': true,
    'grpc.keepalive_permit_without_calls': true,
    'grpc.service_config': true,
    'grpc.max_concurrent_streams': true,
    'grpc.initial_reconnect_backoff_ms': true,
    'grpc.max_reconnect_backoff_ms': true,
    'grpc.use_local_subchannel_pool': true,
    'grpc.max_send_message_length': true,
    'grpc.max_receive_message_length': true,
    'grpc.enable_http_proxy': true,
    'grpc.enable_channelz': true,
    'grpc.dns_min_time_between_resolutions_ms': true,
    'grpc.enable_retries': true,
    'grpc.per_rpc_retry_buffer_size': true,
    'grpc.retry_buffer_size': true,
    'grpc.max_connection_age_ms': true,
    'grpc.max_connection_age_grace_ms': true,
    'grpc-node.max_session_memory': true,
    'grpc.service_config_disable_resolution': true,
    'grpc.client_idle_timeout_ms': true,
    'grpc-node.tls_enable_trace': true,
    'grpc.lb.ring_hash.ring_size_cap': true,
};
function channelOptionsEqual(options1, options2) {
    const keys1 = Object.keys(options1).sort();
    const keys2 = Object.keys(options2).sort();
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
            return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
            return false;
        }
    }
    return true;
}
channelOptions.channelOptionsEqual = channelOptionsEqual;

var subchannel = {};

var subchannelAddress = {};

/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(subchannelAddress, "__esModule", { value: true });
subchannelAddress.EndpointMap = subchannelAddress.endpointHasAddress = subchannelAddress.endpointToString = subchannelAddress.endpointEqual = subchannelAddress.stringToSubchannelAddress = subchannelAddress.subchannelAddressToString = subchannelAddress.subchannelAddressEqual = subchannelAddress.isTcpSubchannelAddress = void 0;
const net_1 = require$$0$3;
function isTcpSubchannelAddress(address) {
    return 'port' in address;
}
subchannelAddress.isTcpSubchannelAddress = isTcpSubchannelAddress;
function subchannelAddressEqual(address1, address2) {
    if (!address1 && !address2) {
        return true;
    }
    if (!address1 || !address2) {
        return false;
    }
    if (isTcpSubchannelAddress(address1)) {
        return (isTcpSubchannelAddress(address2) &&
            address1.host === address2.host &&
            address1.port === address2.port);
    }
    else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
    }
}
subchannelAddress.subchannelAddressEqual = subchannelAddressEqual;
function subchannelAddressToString(address) {
    if (isTcpSubchannelAddress(address)) {
        if ((0, net_1.isIPv6)(address.host)) {
            return '[' + address.host + ']:' + address.port;
        }
        else {
            return address.host + ':' + address.port;
        }
    }
    else {
        return address.path;
    }
}
subchannelAddress.subchannelAddressToString = subchannelAddressToString;
const DEFAULT_PORT = 443;
function stringToSubchannelAddress(addressString, port) {
    if ((0, net_1.isIP)(addressString)) {
        return {
            host: addressString,
            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,
        };
    }
    else {
        return {
            path: addressString,
        };
    }
}
subchannelAddress.stringToSubchannelAddress = stringToSubchannelAddress;
function endpointEqual(endpoint1, endpoint2) {
    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
    }
    for (let i = 0; i < endpoint1.addresses.length; i++) {
        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {
            return false;
        }
    }
    return true;
}
subchannelAddress.endpointEqual = endpointEqual;
function endpointToString(endpoint) {
    return ('[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']');
}
subchannelAddress.endpointToString = endpointToString;
function endpointHasAddress(endpoint, expectedAddress) {
    for (const address of endpoint.addresses) {
        if (subchannelAddressEqual(address, expectedAddress)) {
            return true;
        }
    }
    return false;
}
subchannelAddress.endpointHasAddress = endpointHasAddress;
function endpointEqualUnordered(endpoint1, endpoint2) {
    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
    }
    for (const address1 of endpoint1.addresses) {
        let matchFound = false;
        for (const address2 of endpoint2.addresses) {
            if (subchannelAddressEqual(address1, address2)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
class EndpointMap {
    constructor() {
        this.map = new Set();
    }
    get size() {
        return this.map.size;
    }
    getForSubchannelAddress(address) {
        for (const entry of this.map) {
            if (endpointHasAddress(entry.key, address)) {
                return entry.value;
            }
        }
        return undefined;
    }
    /**
     * Delete any entries in this map with keys that are not in endpoints
     * @param endpoints
     */
    deleteMissing(endpoints) {
        const removedValues = [];
        for (const entry of this.map) {
            let foundEntry = false;
            for (const endpoint of endpoints) {
                if (endpointEqualUnordered(endpoint, entry.key)) {
                    foundEntry = true;
                }
            }
            if (!foundEntry) {
                removedValues.push(entry.value);
                this.map.delete(entry);
            }
        }
        return removedValues;
    }
    get(endpoint) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                return entry.value;
            }
        }
        return undefined;
    }
    set(endpoint, mapEntry) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                entry.value = mapEntry;
                return;
            }
        }
        this.map.add({ key: endpoint, value: mapEntry });
    }
    delete(endpoint) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                this.map.delete(entry);
                return;
            }
        }
    }
    has(endpoint) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                return true;
            }
        }
        return false;
    }
    clear() {
        this.map.clear();
    }
    *keys() {
        for (const entry of this.map) {
            yield entry.key;
        }
    }
    *values() {
        for (const entry of this.map) {
            yield entry.value;
        }
    }
    *entries() {
        for (const entry of this.map) {
            yield [entry.key, entry.value];
        }
    }
}
subchannelAddress.EndpointMap = EndpointMap;

var channelz = {};

var extendStatics = function(e, r) {
    extendStatics = Object.setPrototypeOf || {
        __proto__: []
    } instanceof Array && function(e, r) {
        e.__proto__ = r;
    } || function(e, r) {
        for (var t in r) if (Object.prototype.hasOwnProperty.call(r, t)) e[t] = r[t];
    };
    return extendStatics(e, r);
};

function __extends(e, r) {
    if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    extendStatics(e, r);
    function __() {
        this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __);
}

function __generator(e, r) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1) throw s[1];
            return s[1];
        },
        trys: [],
        ops: []
    }, i, n, s, h;
    return h = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
    }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
        return this;
    }), h;
    function verb(e) {
        return function(r) {
            return step([ e, r ]);
        };
    }
    function step(a) {
        if (i) throw new TypeError("Generator is already executing.");
        while (h && (h = 0, a[0] && (t = 0)), t) try {
            if (i = 1, n && (s = a[0] & 2 ? n["return"] : a[0] ? n["throw"] || ((s = n["return"]) && s.call(n), 
            0) : n.next) && !(s = s.call(n, a[1])).done) return s;
            if (n = 0, s) a = [ a[0] & 2, s.value ];
            switch (a[0]) {
              case 0:
              case 1:
                s = a;
                break;

              case 4:
                t.label++;
                return {
                    value: a[1],
                    done: false
                };

              case 5:
                t.label++;
                n = a[1];
                a = [ 0 ];
                continue;

              case 7:
                a = t.ops.pop();
                t.trys.pop();
                continue;

              default:
                if (!(s = t.trys, s = s.length > 0 && s[s.length - 1]) && (a[0] === 6 || a[0] === 2)) {
                    t = 0;
                    continue;
                }
                if (a[0] === 3 && (!s || a[1] > s[0] && a[1] < s[3])) {
                    t.label = a[1];
                    break;
                }
                if (a[0] === 6 && t.label < s[1]) {
                    t.label = s[1];
                    s = a;
                    break;
                }
                if (s && t.label < s[2]) {
                    t.label = s[2];
                    t.ops.push(a);
                    break;
                }
                if (s[2]) t.ops.pop();
                t.trys.pop();
                continue;
            }
            a = r.call(e, t);
        } catch (e) {
            a = [ 6, e ];
            n = 0;
        } finally {
            i = s = 0;
        }
        if (a[0] & 5) throw a[1];
        return {
            value: a[0] ? a[1] : void 0,
            done: true
        };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function(e, r, t) {
    var i = new Error(t);
    return i.name = "SuppressedError", i.error = e, i.suppressed = r, i;
};

var TreeNode = function() {
    function TreeNode(e, r, t) {
        if (t === void 0) {
            t = 1;
        }
        this.t = undefined;
        this.i = undefined;
        this.h = undefined;
        this.u = e;
        this.o = r;
        this.l = t;
    }
    TreeNode.prototype.v = function() {
        var e = this;
        var r = e.h.h === e;
        if (r && e.l === 1) {
            e = e.i;
        } else if (e.t) {
            e = e.t;
            while (e.i) {
                e = e.i;
            }
        } else {
            if (r) {
                return e.h;
            }
            var t = e.h;
            while (t.t === e) {
                e = t;
                t = e.h;
            }
            e = t;
        }
        return e;
    };
    TreeNode.prototype.p = function() {
        var e = this;
        if (e.i) {
            e = e.i;
            while (e.t) {
                e = e.t;
            }
            return e;
        } else {
            var r = e.h;
            while (r.i === e) {
                e = r;
                r = e.h;
            }
            if (e.i !== r) {
                return r;
            } else return e;
        }
    };
    TreeNode.prototype.T = function() {
        var e = this.h;
        var r = this.i;
        var t = r.t;
        if (e.h === this) e.h = r; else if (e.t === this) e.t = r; else e.i = r;
        r.h = e;
        r.t = this;
        this.h = r;
        this.i = t;
        if (t) t.h = this;
        return r;
    };
    TreeNode.prototype.I = function() {
        var e = this.h;
        var r = this.t;
        var t = r.i;
        if (e.h === this) e.h = r; else if (e.t === this) e.t = r; else e.i = r;
        r.h = e;
        r.i = this;
        this.h = r;
        this.t = t;
        if (t) t.h = this;
        return r;
    };
    return TreeNode;
}();

var TreeNodeEnableIndex = function(e) {
    __extends(TreeNodeEnableIndex, e);
    function TreeNodeEnableIndex() {
        var r = e !== null && e.apply(this, arguments) || this;
        r.O = 1;
        return r;
    }
    TreeNodeEnableIndex.prototype.T = function() {
        var r = e.prototype.T.call(this);
        this.M();
        r.M();
        return r;
    };
    TreeNodeEnableIndex.prototype.I = function() {
        var r = e.prototype.I.call(this);
        this.M();
        r.M();
        return r;
    };
    TreeNodeEnableIndex.prototype.M = function() {
        this.O = 1;
        if (this.t) {
            this.O += this.t.O;
        }
        if (this.i) {
            this.O += this.i.O;
        }
    };
    return TreeNodeEnableIndex;
}(TreeNode);

var ContainerIterator = function() {
    function ContainerIterator(e) {
        if (e === void 0) {
            e = 0;
        }
        this.iteratorType = e;
    }
    ContainerIterator.prototype.equals = function(e) {
        return this.C === e.C;
    };
    return ContainerIterator;
}();

var Base = function() {
    function Base() {
        this._ = 0;
    }
    Object.defineProperty(Base.prototype, "length", {
        get: function() {
            return this._;
        },
        enumerable: false,
        configurable: true
    });
    Base.prototype.size = function() {
        return this._;
    };
    Base.prototype.empty = function() {
        return this._ === 0;
    };
    return Base;
}();

var Container = function(e) {
    __extends(Container, e);
    function Container() {
        return e !== null && e.apply(this, arguments) || this;
    }
    return Container;
}(Base);

function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
}

var TreeContainer = function(e) {
    __extends(TreeContainer, e);
    function TreeContainer(r, t) {
        if (r === void 0) {
            r = function(e, r) {
                if (e < r) return -1;
                if (e > r) return 1;
                return 0;
            };
        }
        if (t === void 0) {
            t = false;
        }
        var i = e.call(this) || this;
        i.N = undefined;
        i.g = r;
        i.enableIndex = t;
        i.S = t ? TreeNodeEnableIndex : TreeNode;
        i.A = new i.S;
        return i;
    }
    TreeContainer.prototype.m = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                e = e.i;
            } else if (i > 0) {
                t = e;
                e = e.t;
            } else return e;
        }
        return t;
    };
    TreeContainer.prototype.B = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i <= 0) {
                e = e.i;
            } else {
                t = e;
                e = e.t;
            }
        }
        return t;
    };
    TreeContainer.prototype.j = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                t = e;
                e = e.i;
            } else if (i > 0) {
                e = e.t;
            } else return e;
        }
        return t;
    };
    TreeContainer.prototype.k = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                t = e;
                e = e.i;
            } else {
                e = e.t;
            }
        }
        return t;
    };
    TreeContainer.prototype.R = function(e) {
        while (true) {
            var r = e.h;
            if (r === this.A) return;
            if (e.l === 1) {
                e.l = 0;
                return;
            }
            if (e === r.t) {
                var t = r.i;
                if (t.l === 1) {
                    t.l = 0;
                    r.l = 1;
                    if (r === this.N) {
                        this.N = r.T();
                    } else r.T();
                } else {
                    if (t.i && t.i.l === 1) {
                        t.l = r.l;
                        r.l = 0;
                        t.i.l = 0;
                        if (r === this.N) {
                            this.N = r.T();
                        } else r.T();
                        return;
                    } else if (t.t && t.t.l === 1) {
                        t.l = 1;
                        t.t.l = 0;
                        t.I();
                    } else {
                        t.l = 1;
                        e = r;
                    }
                }
            } else {
                var t = r.t;
                if (t.l === 1) {
                    t.l = 0;
                    r.l = 1;
                    if (r === this.N) {
                        this.N = r.I();
                    } else r.I();
                } else {
                    if (t.t && t.t.l === 1) {
                        t.l = r.l;
                        r.l = 0;
                        t.t.l = 0;
                        if (r === this.N) {
                            this.N = r.I();
                        } else r.I();
                        return;
                    } else if (t.i && t.i.l === 1) {
                        t.l = 1;
                        t.i.l = 0;
                        t.T();
                    } else {
                        t.l = 1;
                        e = r;
                    }
                }
            }
        }
    };
    TreeContainer.prototype.G = function(e) {
        if (this._ === 1) {
            this.clear();
            return;
        }
        var r = e;
        while (r.t || r.i) {
            if (r.i) {
                r = r.i;
                while (r.t) r = r.t;
            } else {
                r = r.t;
            }
            var t = e.u;
            e.u = r.u;
            r.u = t;
            var i = e.o;
            e.o = r.o;
            r.o = i;
            e = r;
        }
        if (this.A.t === r) {
            this.A.t = r.h;
        } else if (this.A.i === r) {
            this.A.i = r.h;
        }
        this.R(r);
        var n = r.h;
        if (r === n.t) {
            n.t = undefined;
        } else n.i = undefined;
        this._ -= 1;
        this.N.l = 0;
        if (this.enableIndex) {
            while (n !== this.A) {
                n.O -= 1;
                n = n.h;
            }
        }
    };
    TreeContainer.prototype.P = function(e) {
        var r = typeof e === "number" ? e : undefined;
        var t = typeof e === "function" ? e : undefined;
        var i = typeof e === "undefined" ? [] : undefined;
        var n = 0;
        var s = this.N;
        var h = [];
        while (h.length || s) {
            if (s) {
                h.push(s);
                s = s.t;
            } else {
                s = h.pop();
                if (n === r) return s;
                i && i.push(s);
                t && t(s, n, this);
                n += 1;
                s = s.i;
            }
        }
        return i;
    };
    TreeContainer.prototype.q = function(e) {
        while (true) {
            var r = e.h;
            if (r.l === 0) return;
            var t = r.h;
            if (r === t.t) {
                var i = t.i;
                if (i && i.l === 1) {
                    i.l = r.l = 0;
                    if (t === this.N) return;
                    t.l = 1;
                    e = t;
                    continue;
                } else if (e === r.i) {
                    e.l = 0;
                    if (e.t) {
                        e.t.h = r;
                    }
                    if (e.i) {
                        e.i.h = t;
                    }
                    r.i = e.t;
                    t.t = e.i;
                    e.t = r;
                    e.i = t;
                    if (t === this.N) {
                        this.N = e;
                        this.A.h = e;
                    } else {
                        var n = t.h;
                        if (n.t === t) {
                            n.t = e;
                        } else n.i = e;
                    }
                    e.h = t.h;
                    r.h = e;
                    t.h = e;
                    t.l = 1;
                } else {
                    r.l = 0;
                    if (t === this.N) {
                        this.N = t.I();
                    } else t.I();
                    t.l = 1;
                    return;
                }
            } else {
                var i = t.t;
                if (i && i.l === 1) {
                    i.l = r.l = 0;
                    if (t === this.N) return;
                    t.l = 1;
                    e = t;
                    continue;
                } else if (e === r.t) {
                    e.l = 0;
                    if (e.t) {
                        e.t.h = t;
                    }
                    if (e.i) {
                        e.i.h = r;
                    }
                    t.i = e.t;
                    r.t = e.i;
                    e.t = t;
                    e.i = r;
                    if (t === this.N) {
                        this.N = e;
                        this.A.h = e;
                    } else {
                        var n = t.h;
                        if (n.t === t) {
                            n.t = e;
                        } else n.i = e;
                    }
                    e.h = t.h;
                    r.h = e;
                    t.h = e;
                    t.l = 1;
                } else {
                    r.l = 0;
                    if (t === this.N) {
                        this.N = t.T();
                    } else t.T();
                    t.l = 1;
                    return;
                }
            }
            if (this.enableIndex) {
                r.M();
                t.M();
                e.M();
            }
            return;
        }
    };
    TreeContainer.prototype.D = function(e, r, t) {
        if (this.N === undefined) {
            this._ += 1;
            this.N = new this.S(e, r, 0);
            this.N.h = this.A;
            this.A.h = this.A.t = this.A.i = this.N;
            return this._;
        }
        var i;
        var n = this.A.t;
        var s = this.g(n.u, e);
        if (s === 0) {
            n.o = r;
            return this._;
        } else if (s > 0) {
            n.t = new this.S(e, r);
            n.t.h = n;
            i = n.t;
            this.A.t = i;
        } else {
            var h = this.A.i;
            var a = this.g(h.u, e);
            if (a === 0) {
                h.o = r;
                return this._;
            } else if (a < 0) {
                h.i = new this.S(e, r);
                h.i.h = h;
                i = h.i;
                this.A.i = i;
            } else {
                if (t !== undefined) {
                    var u = t.C;
                    if (u !== this.A) {
                        var f = this.g(u.u, e);
                        if (f === 0) {
                            u.o = r;
                            return this._;
                        } else if (f > 0) {
                            var o = u.v();
                            var d = this.g(o.u, e);
                            if (d === 0) {
                                o.o = r;
                                return this._;
                            } else if (d < 0) {
                                i = new this.S(e, r);
                                if (o.i === undefined) {
                                    o.i = i;
                                    i.h = o;
                                } else {
                                    u.t = i;
                                    i.h = u;
                                }
                            }
                        }
                    }
                }
                if (i === undefined) {
                    i = this.N;
                    while (true) {
                        var c = this.g(i.u, e);
                        if (c > 0) {
                            if (i.t === undefined) {
                                i.t = new this.S(e, r);
                                i.t.h = i;
                                i = i.t;
                                break;
                            }
                            i = i.t;
                        } else if (c < 0) {
                            if (i.i === undefined) {
                                i.i = new this.S(e, r);
                                i.i.h = i;
                                i = i.i;
                                break;
                            }
                            i = i.i;
                        } else {
                            i.o = r;
                            return this._;
                        }
                    }
                }
            }
        }
        if (this.enableIndex) {
            var l = i.h;
            while (l !== this.A) {
                l.O += 1;
                l = l.h;
            }
        }
        this.q(i);
        this._ += 1;
        return this._;
    };
    TreeContainer.prototype.F = function(e, r) {
        while (e) {
            var t = this.g(e.u, r);
            if (t < 0) {
                e = e.i;
            } else if (t > 0) {
                e = e.t;
            } else return e;
        }
        return e || this.A;
    };
    TreeContainer.prototype.clear = function() {
        this._ = 0;
        this.N = undefined;
        this.A.h = undefined;
        this.A.t = this.A.i = undefined;
    };
    TreeContainer.prototype.updateKeyByIterator = function(e, r) {
        var t = e.C;
        if (t === this.A) {
            throwIteratorAccessError();
        }
        if (this._ === 1) {
            t.u = r;
            return true;
        }
        var i = t.p().u;
        if (t === this.A.t) {
            if (this.g(i, r) > 0) {
                t.u = r;
                return true;
            }
            return false;
        }
        var n = t.v().u;
        if (t === this.A.i) {
            if (this.g(n, r) < 0) {
                t.u = r;
                return true;
            }
            return false;
        }
        if (this.g(n, r) >= 0 || this.g(i, r) <= 0) return false;
        t.u = r;
        return true;
    };
    TreeContainer.prototype.eraseElementByPos = function(e) {
        if (e < 0 || e > this._ - 1) {
            throw new RangeError;
        }
        var r = this.P(e);
        this.G(r);
        return this._;
    };
    TreeContainer.prototype.eraseElementByKey = function(e) {
        if (this._ === 0) return false;
        var r = this.F(this.N, e);
        if (r === this.A) return false;
        this.G(r);
        return true;
    };
    TreeContainer.prototype.eraseElementByIterator = function(e) {
        var r = e.C;
        if (r === this.A) {
            throwIteratorAccessError();
        }
        var t = r.i === undefined;
        var i = e.iteratorType === 0;
        if (i) {
            if (t) e.next();
        } else {
            if (!t || r.t === undefined) e.next();
        }
        this.G(r);
        return e;
    };
    TreeContainer.prototype.getHeight = function() {
        if (this._ === 0) return 0;
        function traversal(e) {
            if (!e) return 0;
            return Math.max(traversal(e.t), traversal(e.i)) + 1;
        }
        return traversal(this.N);
    };
    return TreeContainer;
}(Container);

var TreeIterator = function(e) {
    __extends(TreeIterator, e);
    function TreeIterator(r, t, i) {
        var n = e.call(this, i) || this;
        n.C = r;
        n.A = t;
        if (n.iteratorType === 0) {
            n.pre = function() {
                if (this.C === this.A.t) {
                    throwIteratorAccessError();
                }
                this.C = this.C.v();
                return this;
            };
            n.next = function() {
                if (this.C === this.A) {
                    throwIteratorAccessError();
                }
                this.C = this.C.p();
                return this;
            };
        } else {
            n.pre = function() {
                if (this.C === this.A.i) {
                    throwIteratorAccessError();
                }
                this.C = this.C.p();
                return this;
            };
            n.next = function() {
                if (this.C === this.A) {
                    throwIteratorAccessError();
                }
                this.C = this.C.v();
                return this;
            };
        }
        return n;
    }
    Object.defineProperty(TreeIterator.prototype, "index", {
        get: function() {
            var e = this.C;
            var r = this.A.h;
            if (e === this.A) {
                if (r) {
                    return r.O - 1;
                }
                return 0;
            }
            var t = 0;
            if (e.t) {
                t += e.t.O;
            }
            while (e !== r) {
                var i = e.h;
                if (e === i.i) {
                    t += 1;
                    if (i.t) {
                        t += i.t.O;
                    }
                }
                e = i;
            }
            return t;
        },
        enumerable: false,
        configurable: true
    });
    TreeIterator.prototype.isAccessible = function() {
        return this.C !== this.A;
    };
    return TreeIterator;
}(ContainerIterator);

var OrderedMapIterator = function(e) {
    __extends(OrderedMapIterator, e);
    function OrderedMapIterator(r, t, i, n) {
        var s = e.call(this, r, t, n) || this;
        s.container = i;
        return s;
    }
    Object.defineProperty(OrderedMapIterator.prototype, "pointer", {
        get: function() {
            if (this.C === this.A) {
                throwIteratorAccessError();
            }
            var e = this;
            return new Proxy([], {
                get: function(r, t) {
                    if (t === "0") return e.C.u; else if (t === "1") return e.C.o;
                    r[0] = e.C.u;
                    r[1] = e.C.o;
                    return r[t];
                },
                set: function(r, t, i) {
                    if (t !== "1") {
                        throw new TypeError("prop must be 1");
                    }
                    e.C.o = i;
                    return true;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    OrderedMapIterator.prototype.copy = function() {
        return new OrderedMapIterator(this.C, this.A, this.container, this.iteratorType);
    };
    return OrderedMapIterator;
}(TreeIterator);

var OrderedMap = function(e) {
    __extends(OrderedMap, e);
    function OrderedMap(r, t, i) {
        if (r === void 0) {
            r = [];
        }
        var n = e.call(this, t, i) || this;
        var s = n;
        r.forEach((function(e) {
            s.setElement(e[0], e[1]);
        }));
        return n;
    }
    OrderedMap.prototype.begin = function() {
        return new OrderedMapIterator(this.A.t || this.A, this.A, this);
    };
    OrderedMap.prototype.end = function() {
        return new OrderedMapIterator(this.A, this.A, this);
    };
    OrderedMap.prototype.rBegin = function() {
        return new OrderedMapIterator(this.A.i || this.A, this.A, this, 1);
    };
    OrderedMap.prototype.rEnd = function() {
        return new OrderedMapIterator(this.A, this.A, this, 1);
    };
    OrderedMap.prototype.front = function() {
        if (this._ === 0) return;
        var e = this.A.t;
        return [ e.u, e.o ];
    };
    OrderedMap.prototype.back = function() {
        if (this._ === 0) return;
        var e = this.A.i;
        return [ e.u, e.o ];
    };
    OrderedMap.prototype.lowerBound = function(e) {
        var r = this.m(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.upperBound = function(e) {
        var r = this.B(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.reverseLowerBound = function(e) {
        var r = this.j(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.reverseUpperBound = function(e) {
        var r = this.k(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.forEach = function(e) {
        this.P((function(r, t, i) {
            e([ r.u, r.o ], t, i);
        }));
    };
    OrderedMap.prototype.setElement = function(e, r, t) {
        return this.D(e, r, t);
    };
    OrderedMap.prototype.getElementByPos = function(e) {
        if (e < 0 || e > this._ - 1) {
            throw new RangeError;
        }
        var r = this.P(e);
        return [ r.u, r.o ];
    };
    OrderedMap.prototype.find = function(e) {
        var r = this.F(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.getElementByKey = function(e) {
        var r = this.F(this.N, e);
        return r.o;
    };
    OrderedMap.prototype.union = function(e) {
        var r = this;
        e.forEach((function(e) {
            r.setElement(e[0], e[1]);
        }));
        return this._;
    };
    OrderedMap.prototype[Symbol.iterator] = function() {
        var e, r, t, i;
        return __generator(this, (function(n) {
            switch (n.label) {
              case 0:
                e = this._;
                r = this.P();
                t = 0;
                n.label = 1;

              case 1:
                if (!(t < e)) return [ 3, 4 ];
                i = r[t];
                return [ 4, [ i.u, i.o ] ];

              case 2:
                n.sent();
                n.label = 3;

              case 3:
                ++t;
                return [ 3, 1 ];

              case 4:
                return [ 2 ];
            }
        }));
    };
    return OrderedMap;
}(TreeContainer);

var esm = /*#__PURE__*/Object.freeze({
	__proto__: null,
	OrderedMap: OrderedMap
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(esm);

var admin = {};

var hasRequiredAdmin;

function requireAdmin () {
	if (hasRequiredAdmin) return admin;
	hasRequiredAdmin = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(admin, "__esModule", { value: true });
	admin.addAdminServicesToServer = admin.registerAdminService = void 0;
	const registeredAdminServices = [];
	function registerAdminService(getServiceDefinition, getHandlers) {
	    registeredAdminServices.push({ getServiceDefinition, getHandlers });
	}
	admin.registerAdminService = registerAdminService;
	function addAdminServicesToServer(server) {
	    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
	        server.addService(getServiceDefinition(), getHandlers());
	    }
	}
	admin.addAdminServicesToServer = addAdminServicesToServer;
	
	return admin;
}

var makeClient = {};

var client = {};

var call = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(call, "__esModule", { value: true });
call.ClientDuplexStreamImpl = call.ClientWritableStreamImpl = call.ClientReadableStreamImpl = call.ClientUnaryCallImpl = call.callErrorFromStatus = void 0;
const events_1$1 = require$$0$4;
const stream_1$1 = require$$1$2;
const constants_1$a = constants;
/**
 * Construct a ServiceError from a StatusObject. This function exists primarily
 * as an attempt to make the error stack trace clearly communicate that the
 * error is not necessarily a problem in gRPC itself.
 * @param status
 */
function callErrorFromStatus(status, callerStack) {
    const message = `${status.code} ${constants_1$a.Status[status.code]}: ${status.details}`;
    const error = new Error(message);
    const stack = `${error.stack}\nfor call at\n${callerStack}`;
    return Object.assign(new Error(message), status, { stack });
}
call.callErrorFromStatus = callErrorFromStatus;
class ClientUnaryCallImpl extends events_1$1.EventEmitter {
    constructor() {
        super();
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1$a.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
}
call.ClientUnaryCallImpl = ClientUnaryCallImpl;
class ClientReadableStreamImpl extends stream_1$1.Readable {
    constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1$a.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
}
call.ClientReadableStreamImpl = ClientReadableStreamImpl;
class ClientWritableStreamImpl extends stream_1$1.Writable {
    constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1$a.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _write(chunk, encoding, cb) {
        var _a;
        const context = {
            callback: cb,
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
            context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
    }
}
call.ClientWritableStreamImpl = ClientWritableStreamImpl;
class ClientDuplexStreamImpl extends stream_1$1.Duplex {
    constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1$a.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
    _write(chunk, encoding, cb) {
        var _a;
        const context = {
            callback: cb,
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
            context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
    }
}
call.ClientDuplexStreamImpl = ClientDuplexStreamImpl;

var clientInterceptors = {};

var callInterface = {};

var hasRequiredCallInterface;

function requireCallInterface () {
	if (hasRequiredCallInterface) return callInterface;
	hasRequiredCallInterface = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callInterface, "__esModule", { value: true });
	callInterface.InterceptingListenerImpl = callInterface.isInterceptingListener = void 0;
	function isInterceptingListener(listener) {
	    return (listener.onReceiveMetadata !== undefined &&
	        listener.onReceiveMetadata.length === 1);
	}
	callInterface.isInterceptingListener = isInterceptingListener;
	class InterceptingListenerImpl {
	    constructor(listener, nextListener) {
	        this.listener = listener;
	        this.nextListener = nextListener;
	        this.processingMetadata = false;
	        this.hasPendingMessage = false;
	        this.processingMessage = false;
	        this.pendingStatus = null;
	    }
	    processPendingMessage() {
	        if (this.hasPendingMessage) {
	            this.nextListener.onReceiveMessage(this.pendingMessage);
	            this.pendingMessage = null;
	            this.hasPendingMessage = false;
	        }
	    }
	    processPendingStatus() {
	        if (this.pendingStatus) {
	            this.nextListener.onReceiveStatus(this.pendingStatus);
	        }
	    }
	    onReceiveMetadata(metadata) {
	        this.processingMetadata = true;
	        this.listener.onReceiveMetadata(metadata, metadata => {
	            this.processingMetadata = false;
	            this.nextListener.onReceiveMetadata(metadata);
	            this.processPendingMessage();
	            this.processPendingStatus();
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    onReceiveMessage(message) {
	        /* If this listener processes messages asynchronously, the last message may
	         * be reordered with respect to the status */
	        this.processingMessage = true;
	        this.listener.onReceiveMessage(message, msg => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessage = msg;
	                this.hasPendingMessage = true;
	            }
	            else {
	                this.nextListener.onReceiveMessage(msg);
	                this.processPendingStatus();
	            }
	        });
	    }
	    onReceiveStatus(status) {
	        this.listener.onReceiveStatus(status, processedStatus => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingStatus = processedStatus;
	            }
	            else {
	                this.nextListener.onReceiveStatus(processedStatus);
	            }
	        });
	    }
	}
	callInterface.InterceptingListenerImpl = InterceptingListenerImpl;
	
	return callInterface;
}

var hasRequiredClientInterceptors;

function requireClientInterceptors () {
	if (hasRequiredClientInterceptors) return clientInterceptors;
	hasRequiredClientInterceptors = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(clientInterceptors, "__esModule", { value: true });
	clientInterceptors.getInterceptingCall = clientInterceptors.InterceptingCall = clientInterceptors.RequesterBuilder = clientInterceptors.ListenerBuilder = clientInterceptors.InterceptorConfigurationError = void 0;
	const metadata_1 = metadata;
	const call_interface_1 = requireCallInterface();
	const constants_1 = constants;
	const error_1 = error;
	/**
	 * Error class associated with passing both interceptors and interceptor
	 * providers to a client constructor or as call options.
	 */
	class InterceptorConfigurationError extends Error {
	    constructor(message) {
	        super(message);
	        this.name = 'InterceptorConfigurationError';
	        Error.captureStackTrace(this, InterceptorConfigurationError);
	    }
	}
	clientInterceptors.InterceptorConfigurationError = InterceptorConfigurationError;
	class ListenerBuilder {
	    constructor() {
	        this.metadata = undefined;
	        this.message = undefined;
	        this.status = undefined;
	    }
	    withOnReceiveMetadata(onReceiveMetadata) {
	        this.metadata = onReceiveMetadata;
	        return this;
	    }
	    withOnReceiveMessage(onReceiveMessage) {
	        this.message = onReceiveMessage;
	        return this;
	    }
	    withOnReceiveStatus(onReceiveStatus) {
	        this.status = onReceiveStatus;
	        return this;
	    }
	    build() {
	        return {
	            onReceiveMetadata: this.metadata,
	            onReceiveMessage: this.message,
	            onReceiveStatus: this.status,
	        };
	    }
	}
	clientInterceptors.ListenerBuilder = ListenerBuilder;
	class RequesterBuilder {
	    constructor() {
	        this.start = undefined;
	        this.message = undefined;
	        this.halfClose = undefined;
	        this.cancel = undefined;
	    }
	    withStart(start) {
	        this.start = start;
	        return this;
	    }
	    withSendMessage(sendMessage) {
	        this.message = sendMessage;
	        return this;
	    }
	    withHalfClose(halfClose) {
	        this.halfClose = halfClose;
	        return this;
	    }
	    withCancel(cancel) {
	        this.cancel = cancel;
	        return this;
	    }
	    build() {
	        return {
	            start: this.start,
	            sendMessage: this.message,
	            halfClose: this.halfClose,
	            cancel: this.cancel,
	        };
	    }
	}
	clientInterceptors.RequesterBuilder = RequesterBuilder;
	/**
	 * A Listener with a default pass-through implementation of each method. Used
	 * for filling out Listeners with some methods omitted.
	 */
	const defaultListener = {
	    onReceiveMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    onReceiveMessage: (message, next) => {
	        next(message);
	    },
	    onReceiveStatus: (status, next) => {
	        next(status);
	    },
	};
	/**
	 * A Requester with a default pass-through implementation of each method. Used
	 * for filling out Requesters with some methods omitted.
	 */
	const defaultRequester = {
	    start: (metadata, listener, next) => {
	        next(metadata, listener);
	    },
	    sendMessage: (message, next) => {
	        next(message);
	    },
	    halfClose: next => {
	        next();
	    },
	    cancel: next => {
	        next();
	    },
	};
	class InterceptingCall {
	    constructor(nextCall, requester) {
	        var _a, _b, _c, _d;
	        this.nextCall = nextCall;
	        /**
	         * Indicates that metadata has been passed to the requester's start
	         * method but it has not been passed to the corresponding next callback
	         */
	        this.processingMetadata = false;
	        /**
	         * Message context for a pending message that is waiting for
	         */
	        this.pendingMessageContext = null;
	        /**
	         * Indicates that a message has been passed to the requester's sendMessage
	         * method but it has not been passed to the corresponding next callback
	         */
	        this.processingMessage = false;
	        /**
	         * Indicates that a status was received but could not be propagated because
	         * a message was still being processed.
	         */
	        this.pendingHalfClose = false;
	        if (requester) {
	            this.requester = {
	                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
	                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
	                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
	                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,
	            };
	        }
	        else {
	            this.requester = defaultRequester;
	        }
	    }
	    cancelWithStatus(status, details) {
	        this.requester.cancel(() => {
	            this.nextCall.cancelWithStatus(status, details);
	        });
	    }
	    getPeer() {
	        return this.nextCall.getPeer();
	    }
	    processPendingMessage() {
	        if (this.pendingMessageContext) {
	            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
	            this.pendingMessageContext = null;
	            this.pendingMessage = null;
	        }
	    }
	    processPendingHalfClose() {
	        if (this.pendingHalfClose) {
	            this.nextCall.halfClose();
	        }
	    }
	    start(metadata, interceptingListener) {
	        var _a, _b, _c, _d, _e, _f;
	        const fullInterceptingListener = {
	            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),
	            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),
	            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),
	        };
	        this.processingMetadata = true;
	        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
	            var _a, _b, _c;
	            this.processingMetadata = false;
	            let finalInterceptingListener;
	            if ((0, call_interface_1.isInterceptingListener)(listener)) {
	                finalInterceptingListener = listener;
	            }
	            else {
	                const fullListener = {
	                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,
	                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,
	                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,
	                };
	                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
	            }
	            this.nextCall.start(md, finalInterceptingListener);
	            this.processPendingMessage();
	            this.processPendingHalfClose();
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessageWithContext(context, message) {
	        this.processingMessage = true;
	        this.requester.sendMessage(message, finalMessage => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessageContext = context;
	                this.pendingMessage = message;
	            }
	            else {
	                this.nextCall.sendMessageWithContext(context, finalMessage);
	                this.processPendingHalfClose();
	            }
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessage(message) {
	        this.sendMessageWithContext({}, message);
	    }
	    startRead() {
	        this.nextCall.startRead();
	    }
	    halfClose() {
	        this.requester.halfClose(() => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingHalfClose = true;
	            }
	            else {
	                this.nextCall.halfClose();
	            }
	        });
	    }
	}
	clientInterceptors.InterceptingCall = InterceptingCall;
	function getCall(channel, path, options) {
	    var _a, _b;
	    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
	    const host = options.host;
	    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
	    const propagateFlags = options.propagate_flags;
	    const credentials = options.credentials;
	    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
	    if (credentials) {
	        call.setCredentials(credentials);
	    }
	    return call;
	}
	/**
	 * InterceptingCall implementation that directly owns the underlying Call
	 * object and handles serialization and deseraizliation.
	 */
	class BaseInterceptingCall {
	    constructor(call, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    methodDefinition) {
	        this.call = call;
	        this.methodDefinition = methodDefinition;
	    }
	    cancelWithStatus(status, details) {
	        this.call.cancelWithStatus(status, details);
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessageWithContext(context, message) {
	        let serialized;
	        try {
	            serialized = this.methodDefinition.requestSerialize(message);
	        }
	        catch (e) {
	            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);
	            return;
	        }
	        this.call.sendMessageWithContext(context, serialized);
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessage(message) {
	        this.sendMessageWithContext({}, message);
	    }
	    start(metadata, interceptingListener) {
	        let readError = null;
	        this.call.start(metadata, {
	            onReceiveMetadata: metadata => {
	                var _a;
	                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);
	            },
	            onReceiveMessage: message => {
	                var _a;
	                // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                let deserialized;
	                try {
	                    deserialized = this.methodDefinition.responseDeserialize(message);
	                }
	                catch (e) {
	                    readError = {
	                        code: constants_1.Status.INTERNAL,
	                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,
	                        metadata: new metadata_1.Metadata(),
	                    };
	                    this.call.cancelWithStatus(readError.code, readError.details);
	                    return;
	                }
	                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
	            },
	            onReceiveStatus: status => {
	                var _a, _b;
	                if (readError) {
	                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
	                }
	                else {
	                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
	                }
	            },
	        });
	    }
	    startRead() {
	        this.call.startRead();
	    }
	    halfClose() {
	        this.call.halfClose();
	    }
	}
	/**
	 * BaseInterceptingCall with special-cased behavior for methods with unary
	 * responses.
	 */
	class BaseUnaryInterceptingCall extends BaseInterceptingCall {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    constructor(call, methodDefinition) {
	        super(call, methodDefinition);
	    }
	    start(metadata, listener) {
	        var _a, _b;
	        let receivedMessage = false;
	        const wrapperListener = {
	            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage: (message) => {
	                var _a;
	                receivedMessage = true;
	                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);
	            },
	            onReceiveStatus: (status) => {
	                var _a, _b;
	                if (!receivedMessage) {
	                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);
	                }
	                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);
	            },
	        };
	        super.start(metadata, wrapperListener);
	        this.call.startRead();
	    }
	}
	/**
	 * BaseInterceptingCall with special-cased behavior for methods with streaming
	 * responses.
	 */
	class BaseStreamingInterceptingCall extends BaseInterceptingCall {
	}
	function getBottomInterceptingCall(channel, options, 
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	methodDefinition) {
	    const call = getCall(channel, methodDefinition.path, options);
	    if (methodDefinition.responseStream) {
	        return new BaseStreamingInterceptingCall(call, methodDefinition);
	    }
	    else {
	        return new BaseUnaryInterceptingCall(call, methodDefinition);
	    }
	}
	function getInterceptingCall(interceptorArgs, 
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	methodDefinition, options, channel) {
	    if (interceptorArgs.clientInterceptors.length > 0 &&
	        interceptorArgs.clientInterceptorProviders.length > 0) {
	        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
	            'to the client constructor. Only one of these is allowed.');
	    }
	    if (interceptorArgs.callInterceptors.length > 0 &&
	        interceptorArgs.callInterceptorProviders.length > 0) {
	        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
	            'options. Only one of these is allowed.');
	    }
	    let interceptors = [];
	    // Interceptors passed to the call override interceptors passed to the client constructor
	    if (interceptorArgs.callInterceptors.length > 0 ||
	        interceptorArgs.callInterceptorProviders.length > 0) {
	        interceptors = []
	            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))
	            .filter(interceptor => interceptor);
	        // Filter out falsy values when providers return nothing
	    }
	    else {
	        interceptors = []
	            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))
	            .filter(interceptor => interceptor);
	        // Filter out falsy values when providers return nothing
	    }
	    const interceptorOptions = Object.assign({}, options, {
	        method_definition: methodDefinition,
	    });
	    /* For each interceptor in the list, the nextCall function passed to it is
	     * based on the next interceptor in the list, using a nextCall function
	     * constructed with the following interceptor in the list, and so on. The
	     * initialValue, which is effectively at the end of the list, is a nextCall
	     * function that invokes getBottomInterceptingCall, the result of which
	     * handles (de)serialization and also gets the underlying call from the
	     * channel. */
	    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {
	        return currentOptions => nextInterceptor(currentOptions, nextCall);
	    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
	    return getCall(interceptorOptions);
	}
	clientInterceptors.getInterceptingCall = getInterceptingCall;
	
	return clientInterceptors;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client;
	hasRequiredClient = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(client, "__esModule", { value: true });
	client.Client = void 0;
	const call_1 = call;
	const channel_1 = requireChannel();
	const connectivity_state_1 = connectivityState;
	const constants_1 = constants;
	const metadata_1 = metadata;
	const client_interceptors_1 = requireClientInterceptors();
	const CHANNEL_SYMBOL = Symbol();
	const INTERCEPTOR_SYMBOL = Symbol();
	const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
	const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
	function isFunction(arg) {
	    return typeof arg === 'function';
	}
	function getErrorStackString(error) {
	    var _a;
	    return ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\n').slice(1).join('\n')) || 'no stack trace available';
	}
	/**
	 * A generic gRPC client. Primarily useful as a base class for all generated
	 * clients.
	 */
	class Client {
	    constructor(address, credentials, options = {}) {
	        var _a, _b;
	        options = Object.assign({}, options);
	        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
	        delete options.interceptors;
	        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
	        delete options.interceptor_providers;
	        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
	            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
	            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
	                'to the client constructor. Only one of these is allowed.');
	        }
	        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
	            options.callInvocationTransformer;
	        delete options.callInvocationTransformer;
	        if (options.channelOverride) {
	            this[CHANNEL_SYMBOL] = options.channelOverride;
	        }
	        else if (options.channelFactoryOverride) {
	            const channelFactoryOverride = options.channelFactoryOverride;
	            delete options.channelFactoryOverride;
	            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
	        }
	        else {
	            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
	        }
	    }
	    close() {
	        this[CHANNEL_SYMBOL].close();
	    }
	    getChannel() {
	        return this[CHANNEL_SYMBOL];
	    }
	    waitForReady(deadline, callback) {
	        const checkState = (err) => {
	            if (err) {
	                callback(new Error('Failed to connect before the deadline'));
	                return;
	            }
	            let newState;
	            try {
	                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
	            }
	            catch (e) {
	                callback(new Error('The channel has been closed'));
	                return;
	            }
	            if (newState === connectivity_state_1.ConnectivityState.READY) {
	                callback();
	            }
	            else {
	                try {
	                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
	                }
	                catch (e) {
	                    callback(new Error('The channel has been closed'));
	                }
	            }
	        };
	        setImmediate(checkState);
	    }
	    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
	        if (isFunction(arg1)) {
	            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
	        }
	        else if (isFunction(arg2)) {
	            if (arg1 instanceof metadata_1.Metadata) {
	                return { metadata: arg1, options: {}, callback: arg2 };
	            }
	            else {
	                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
	            }
	        }
	        else {
	            if (!(arg1 instanceof metadata_1.Metadata &&
	                arg2 instanceof Object &&
	                isFunction(arg3))) {
	                throw new Error('Incorrect arguments passed');
	            }
	            return { metadata: arg1, options: arg2, callback: arg3 };
	        }
	    }
	    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
	        var _a, _b;
	        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
	        const methodDefinition = {
	            path: method,
	            requestStream: false,
	            responseStream: false,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            argument: argument,
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientUnaryCallImpl(),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	            callback: checkedArguments.callback,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const emitter = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        emitter.call = call;
	        let responseMessage = null;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata: metadata => {
	                emitter.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                if (responseMessage !== null) {
	                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
	                }
	                responseMessage = message;
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                if (status.code === constants_1.Status.OK) {
	                    if (responseMessage === null) {
	                        const callerStack = getErrorStackString(callerStackError);
	                        callProperties.callback((0, call_1.callErrorFromStatus)({
	                            code: constants_1.Status.INTERNAL,
	                            details: 'No message received',
	                            metadata: status.metadata,
	                        }, callerStack));
	                    }
	                    else {
	                        callProperties.callback(null, responseMessage);
	                    }
	                }
	                else {
	                    const callerStack = getErrorStackString(callerStackError);
	                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                emitter.emit('status', status);
	            },
	        });
	        call.sendMessage(argument);
	        call.halfClose();
	        return emitter;
	    }
	    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
	        var _a, _b;
	        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
	        const methodDefinition = {
	            path: method,
	            requestStream: true,
	            responseStream: false,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientWritableStreamImpl(serialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	            callback: checkedArguments.callback,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const emitter = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        emitter.call = call;
	        let responseMessage = null;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata: metadata => {
	                emitter.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                if (responseMessage !== null) {
	                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
	                }
	                responseMessage = message;
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                if (status.code === constants_1.Status.OK) {
	                    if (responseMessage === null) {
	                        const callerStack = getErrorStackString(callerStackError);
	                        callProperties.callback((0, call_1.callErrorFromStatus)({
	                            code: constants_1.Status.INTERNAL,
	                            details: 'No message received',
	                            metadata: status.metadata,
	                        }, callerStack));
	                    }
	                    else {
	                        callProperties.callback(null, responseMessage);
	                    }
	                }
	                else {
	                    const callerStack = getErrorStackString(callerStackError);
	                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                emitter.emit('status', status);
	            },
	        });
	        return emitter;
	    }
	    checkMetadataAndOptions(arg1, arg2) {
	        let metadata;
	        let options;
	        if (arg1 instanceof metadata_1.Metadata) {
	            metadata = arg1;
	            if (arg2) {
	                options = arg2;
	            }
	            else {
	                options = {};
	            }
	        }
	        else {
	            if (arg1) {
	                options = arg1;
	            }
	            else {
	                options = {};
	            }
	            metadata = new metadata_1.Metadata();
	        }
	        return { metadata, options };
	    }
	    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
	        var _a, _b;
	        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
	        const methodDefinition = {
	            path: method,
	            requestStream: false,
	            responseStream: true,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            argument: argument,
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientReadableStreamImpl(deserialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const stream = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        stream.call = call;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata(metadata) {
	                stream.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                stream.push(message);
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                stream.push(null);
	                if (status.code !== constants_1.Status.OK) {
	                    const callerStack = getErrorStackString(callerStackError);
	                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                stream.emit('status', status);
	            },
	        });
	        call.sendMessage(argument);
	        call.halfClose();
	        return stream;
	    }
	    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
	        var _a, _b;
	        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
	        const methodDefinition = {
	            path: method,
	            requestStream: true,
	            responseStream: true,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const stream = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        stream.call = call;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata(metadata) {
	                stream.emit('metadata', metadata);
	            },
	            onReceiveMessage(message) {
	                stream.push(message);
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                stream.push(null);
	                if (status.code !== constants_1.Status.OK) {
	                    const callerStack = getErrorStackString(callerStackError);
	                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                stream.emit('status', status);
	            },
	        });
	        return stream;
	    }
	}
	client.Client = Client;
	
	return client;
}

var hasRequiredMakeClient;

function requireMakeClient () {
	if (hasRequiredMakeClient) return makeClient;
	hasRequiredMakeClient = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(makeClient, "__esModule", { value: true });
	makeClient.loadPackageDefinition = makeClient.makeClientConstructor = void 0;
	const client_1 = requireClient();
	/**
	 * Map with short names for each of the requester maker functions. Used in
	 * makeClientConstructor
	 * @private
	 */
	const requesterFuncs = {
	    unary: client_1.Client.prototype.makeUnaryRequest,
	    server_stream: client_1.Client.prototype.makeServerStreamRequest,
	    client_stream: client_1.Client.prototype.makeClientStreamRequest,
	    bidi: client_1.Client.prototype.makeBidiStreamRequest,
	};
	/**
	 * Returns true, if given key is included in the blacklisted
	 * keys.
	 * @param key key for check, string.
	 */
	function isPrototypePolluted(key) {
	    return ['__proto__', 'prototype', 'constructor'].includes(key);
	}
	/**
	 * Creates a constructor for a client with the given methods, as specified in
	 * the methods argument. The resulting class will have an instance method for
	 * each method in the service, which is a partial application of one of the
	 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
	 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
	 * arguments predefined.
	 * @param methods An object mapping method names to
	 *     method attributes
	 * @param serviceName The fully qualified name of the service
	 * @param classOptions An options object.
	 * @return New client constructor, which is a subclass of
	 *     {@link grpc.Client}, and has the same arguments as that constructor.
	 */
	function makeClientConstructor(methods, serviceName, classOptions) {
	    class ServiceClientImpl extends client_1.Client {
	    }
	    Object.keys(methods).forEach(name => {
	        if (isPrototypePolluted(name)) {
	            return;
	        }
	        const attrs = methods[name];
	        let methodType;
	        // TODO(murgatroid99): Verify that we don't need this anymore
	        if (typeof name === 'string' && name.charAt(0) === '$') {
	            throw new Error('Method names cannot start with $');
	        }
	        if (attrs.requestStream) {
	            if (attrs.responseStream) {
	                methodType = 'bidi';
	            }
	            else {
	                methodType = 'client_stream';
	            }
	        }
	        else {
	            if (attrs.responseStream) {
	                methodType = 'server_stream';
	            }
	            else {
	                methodType = 'unary';
	            }
	        }
	        const serialize = attrs.requestSerialize;
	        const deserialize = attrs.responseDeserialize;
	        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
	        ServiceClientImpl.prototype[name] = methodFunc;
	        // Associate all provided attributes with the method
	        Object.assign(ServiceClientImpl.prototype[name], attrs);
	        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
	            ServiceClientImpl.prototype[attrs.originalName] =
	                ServiceClientImpl.prototype[name];
	        }
	    });
	    ServiceClientImpl.service = methods;
	    ServiceClientImpl.serviceName = serviceName;
	    return ServiceClientImpl;
	}
	makeClient.makeClientConstructor = makeClientConstructor;
	function partial(fn, path, serialize, deserialize) {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    return function (...args) {
	        return fn.call(this, path, serialize, deserialize, ...args);
	    };
	}
	function isProtobufTypeDefinition(obj) {
	    return 'format' in obj;
	}
	/**
	 * Load a gRPC package definition as a gRPC object hierarchy.
	 * @param packageDef The package definition object.
	 * @return The resulting gRPC object.
	 */
	function loadPackageDefinition(packageDef) {
	    const result = {};
	    for (const serviceFqn in packageDef) {
	        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
	            const service = packageDef[serviceFqn];
	            const nameComponents = serviceFqn.split('.');
	            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
	                continue;
	            }
	            const serviceName = nameComponents[nameComponents.length - 1];
	            let current = result;
	            for (const packageName of nameComponents.slice(0, -1)) {
	                if (!current[packageName]) {
	                    current[packageName] = {};
	                }
	                current = current[packageName];
	            }
	            if (isProtobufTypeDefinition(service)) {
	                current[serviceName] = service;
	            }
	            else {
	                current[serviceName] = makeClientConstructor(service, serviceName);
	            }
	        }
	    }
	    return result;
	}
	makeClient.loadPackageDefinition = loadPackageDefinition;
	
	return makeClient;
}

var src$1 = {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_camelcase;
var hasRequiredLodash_camelcase;

function requireLodash_camelcase () {
	if (hasRequiredLodash_camelcase) return lodash_camelcase;
	hasRequiredLodash_camelcase = 1;
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match words composed of alphanumeric characters. */
	var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	/** Used to match Latin Unicode letters (excluding mathematical operators). */
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	    rsComboSymbolsRange = '\\u20d0-\\u20f0',
	    rsDingbatRange = '\\u2700-\\u27bf',
	    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	    rsPunctuationRange = '\\u2000-\\u206f',
	    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	    rsVarRange = '\\ufe0e\\ufe0f',
	    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	/** Used to compose unicode capture groups. */
	var rsApos = "['\u2019]",
	    rsAstral = '[' + rsAstralRange + ']',
	    rsBreak = '[' + rsBreakRange + ']',
	    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	    rsDigits = '\\d+',
	    rsDingbat = '[' + rsDingbatRange + ']',
	    rsLower = '[' + rsLowerRange + ']',
	    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsUpper = '[' + rsUpperRange + ']',
	    rsZWJ = '\\u200d';

	/** Used to compose unicode regexes. */
	var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
	    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
	    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	    reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	/** Used to match apostrophes. */
	var reApos = RegExp(rsApos, 'g');

	/**
	 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	 */
	var reComboMark = RegExp(rsCombo, 'g');

	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	/** Used to match complex or compound words. */
	var reUnicodeWord = RegExp([
	  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
	  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
	  rsUpper + '+' + rsOptUpperContr,
	  rsDigits,
	  rsEmoji
	].join('|'), 'g');

	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

	/** Used to detect strings that need a more robust regexp to match words. */
	var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	/** Used to map Latin Unicode letters to basic Latin letters. */
	var deburredLetters = {
	  // Latin-1 Supplement block.
	  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	  '\xc7': 'C',  '\xe7': 'c',
	  '\xd0': 'D',  '\xf0': 'd',
	  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	  '\xd1': 'N',  '\xf1': 'n',
	  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	  '\xc6': 'Ae', '\xe6': 'ae',
	  '\xde': 'Th', '\xfe': 'th',
	  '\xdf': 'ss',
	  // Latin Extended-A block.
	  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	  '\u0134': 'J',  '\u0135': 'j',
	  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	  '\u0174': 'W',  '\u0175': 'w',
	  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	  '\u0132': 'IJ', '\u0133': 'ij',
	  '\u0152': 'Oe', '\u0153': 'oe',
	  '\u0149': "'n", '\u017f': 'ss'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array ? array.length : 0;
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function asciiToArray(string) {
	  return string.split('');
	}

	/**
	 * Splits an ASCII `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function asciiWords(string) {
	  return string.match(reAsciiWord) || [];
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	 * letters to basic Latin letters.
	 *
	 * @private
	 * @param {string} letter The matched letter to deburr.
	 * @returns {string} Returns the deburred letter.
	 */
	var deburrLetter = basePropertyOf(deburredLetters);

	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}

	/**
	 * Checks if `string` contains a word composed of Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a word is found, else `false`.
	 */
	function hasUnicodeWord(string) {
	  return reHasUnicodeWord.test(string);
	}

	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return hasUnicode(string)
	    ? unicodeToArray(string)
	    : asciiToArray(string);
	}

	/**
	 * Converts a Unicode `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function unicodeToArray(string) {
	  return string.match(reUnicode) || [];
	}

	/**
	 * Splits a Unicode `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function unicodeWords(string) {
	  return string.match(reUnicodeWord) || [];
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol = root.Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return baseSlice(array, start, end);
	}

	/**
	 * Creates a function like `_.lowerFirst`.
	 *
	 * @private
	 * @param {string} methodName The name of the `String` case method to use.
	 * @returns {Function} Returns the new case function.
	 */
	function createCaseFirst(methodName) {
	  return function(string) {
	    string = toString(string);

	    var strSymbols = hasUnicode(string)
	      ? stringToArray(string)
	      : undefined;

	    var chr = strSymbols
	      ? strSymbols[0]
	      : string.charAt(0);

	    var trailing = strSymbols
	      ? castSlice(strSymbols, 1).join('')
	      : string.slice(1);

	    return chr[methodName]() + trailing;
	  };
	}

	/**
	 * Creates a function like `_.camelCase`.
	 *
	 * @private
	 * @param {Function} callback The function to combine each word.
	 * @returns {Function} Returns the new compounder function.
	 */
	function createCompounder(callback) {
	  return function(string) {
	    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	  };
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the camel cased string.
	 * @example
	 *
	 * _.camelCase('Foo Bar');
	 * // => 'fooBar'
	 *
	 * _.camelCase('--foo-bar--');
	 * // => 'fooBar'
	 *
	 * _.camelCase('__FOO_BAR__');
	 * // => 'fooBar'
	 */
	var camelCase = createCompounder(function(result, word, index) {
	  word = word.toLowerCase();
	  return result + (index ? capitalize(word) : word);
	});

	/**
	 * Converts the first character of `string` to upper case and the remaining
	 * to lower case.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to capitalize.
	 * @returns {string} Returns the capitalized string.
	 * @example
	 *
	 * _.capitalize('FRED');
	 * // => 'Fred'
	 */
	function capitalize(string) {
	  return upperFirst(toString(string).toLowerCase());
	}

	/**
	 * Deburrs `string` by converting
	 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	 * letters to basic Latin letters and removing
	 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to deburr.
	 * @returns {string} Returns the deburred string.
	 * @example
	 *
	 * _.deburr('dj vu');
	 * // => 'deja vu'
	 */
	function deburr(string) {
	  string = toString(string);
	  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}

	/**
	 * Converts the first character of `string` to upper case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.upperFirst('fred');
	 * // => 'Fred'
	 *
	 * _.upperFirst('FRED');
	 * // => 'FRED'
	 */
	var upperFirst = createCaseFirst('toUpperCase');

	/**
	 * Splits `string` into an array of its words.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {RegExp|string} [pattern] The pattern to match words.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the words of `string`.
	 * @example
	 *
	 * _.words('fred, barney, & pebbles');
	 * // => ['fred', 'barney', 'pebbles']
	 *
	 * _.words('fred, barney, & pebbles', /[^, ]+/g);
	 * // => ['fred', 'barney', '&', 'pebbles']
	 */
	function words(string, pattern, guard) {
	  string = toString(string);
	  pattern = pattern;

	  if (pattern === undefined) {
	    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	  }
	  return string.match(pattern) || [];
	}

	lodash_camelcase = camelCase;
	return lodash_camelcase;
}

var src = {exports: {}};

var indexLight = {exports: {}};

var indexMinimal = {};

var minimal = {};

var aspromise;
var hasRequiredAspromise;

function requireAspromise () {
	if (hasRequiredAspromise) return aspromise;
	hasRequiredAspromise = 1;
	aspromise = asPromise;

	/**
	 * Callback as used by {@link util.asPromise}.
	 * @typedef asPromiseCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {...*} params Additional arguments
	 * @returns {undefined}
	 */

	/**
	 * Returns a promise from a node-style callback function.
	 * @memberof util
	 * @param {asPromiseCallback} fn Function to call
	 * @param {*} ctx Function context
	 * @param {...*} params Function arguments
	 * @returns {Promise<*>} Promisified function
	 */
	function asPromise(fn, ctx/*, varargs */) {
	    var params  = new Array(arguments.length - 1),
	        offset  = 0,
	        index   = 2,
	        pending = true;
	    while (index < arguments.length)
	        params[offset++] = arguments[index++];
	    return new Promise(function executor(resolve, reject) {
	        params[offset] = function callback(err/*, varargs */) {
	            if (pending) {
	                pending = false;
	                if (err)
	                    reject(err);
	                else {
	                    var params = new Array(arguments.length - 1),
	                        offset = 0;
	                    while (offset < params.length)
	                        params[offset++] = arguments[offset];
	                    resolve.apply(null, params);
	                }
	            }
	        };
	        try {
	            fn.apply(ctx || null, params);
	        } catch (err) {
	            if (pending) {
	                pending = false;
	                reject(err);
	            }
	        }
	    });
	}
	return aspromise;
}

var base64 = {};

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	(function (exports) {

		/**
		 * A minimal base64 implementation for number arrays.
		 * @memberof util
		 * @namespace
		 */
		var base64 = exports;

		/**
		 * Calculates the byte length of a base64 encoded string.
		 * @param {string} string Base64 encoded string
		 * @returns {number} Byte length
		 */
		base64.length = function length(string) {
		    var p = string.length;
		    if (!p)
		        return 0;
		    var n = 0;
		    while (--p % 4 > 1 && string.charAt(p) === "=")
		        ++n;
		    return Math.ceil(string.length * 3) / 4 - n;
		};

		// Base64 encoding table
		var b64 = new Array(64);

		// Base64 decoding table
		var s64 = new Array(123);

		// 65..90, 97..122, 48..57, 43, 47
		for (var i = 0; i < 64;)
		    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

		/**
		 * Encodes a buffer to a base64 encoded string.
		 * @param {Uint8Array} buffer Source buffer
		 * @param {number} start Source start
		 * @param {number} end Source end
		 * @returns {string} Base64 encoded string
		 */
		base64.encode = function encode(buffer, start, end) {
		    var parts = null,
		        chunk = [];
		    var i = 0, // output index
		        j = 0, // goto index
		        t;     // temporary
		    while (start < end) {
		        var b = buffer[start++];
		        switch (j) {
		            case 0:
		                chunk[i++] = b64[b >> 2];
		                t = (b & 3) << 4;
		                j = 1;
		                break;
		            case 1:
		                chunk[i++] = b64[t | b >> 4];
		                t = (b & 15) << 2;
		                j = 2;
		                break;
		            case 2:
		                chunk[i++] = b64[t | b >> 6];
		                chunk[i++] = b64[b & 63];
		                j = 0;
		                break;
		        }
		        if (i > 8191) {
		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
		            i = 0;
		        }
		    }
		    if (j) {
		        chunk[i++] = b64[t];
		        chunk[i++] = 61;
		        if (j === 1)
		            chunk[i++] = 61;
		    }
		    if (parts) {
		        if (i)
		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
		        return parts.join("");
		    }
		    return String.fromCharCode.apply(String, chunk.slice(0, i));
		};

		var invalidEncoding = "invalid encoding";

		/**
		 * Decodes a base64 encoded string to a buffer.
		 * @param {string} string Source string
		 * @param {Uint8Array} buffer Destination buffer
		 * @param {number} offset Destination offset
		 * @returns {number} Number of bytes written
		 * @throws {Error} If encoding is invalid
		 */
		base64.decode = function decode(string, buffer, offset) {
		    var start = offset;
		    var j = 0, // goto index
		        t;     // temporary
		    for (var i = 0; i < string.length;) {
		        var c = string.charCodeAt(i++);
		        if (c === 61 && j > 1)
		            break;
		        if ((c = s64[c]) === undefined)
		            throw Error(invalidEncoding);
		        switch (j) {
		            case 0:
		                t = c;
		                j = 1;
		                break;
		            case 1:
		                buffer[offset++] = t << 2 | (c & 48) >> 4;
		                t = c;
		                j = 2;
		                break;
		            case 2:
		                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
		                t = c;
		                j = 3;
		                break;
		            case 3:
		                buffer[offset++] = (t & 3) << 6 | c;
		                j = 0;
		                break;
		        }
		    }
		    if (j === 1)
		        throw Error(invalidEncoding);
		    return offset - start;
		};

		/**
		 * Tests if the specified string appears to be base64 encoded.
		 * @param {string} string String to test
		 * @returns {boolean} `true` if probably base64 encoded, otherwise false
		 */
		base64.test = function test(string) {
		    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
		}; 
	} (base64));
	return base64;
}

var eventemitter;
var hasRequiredEventemitter;

function requireEventemitter () {
	if (hasRequiredEventemitter) return eventemitter;
	hasRequiredEventemitter = 1;
	eventemitter = EventEmitter;

	/**
	 * Constructs a new event emitter instance.
	 * @classdesc A minimal event emitter.
	 * @memberof util
	 * @constructor
	 */
	function EventEmitter() {

	    /**
	     * Registered listeners.
	     * @type {Object.<string,*>}
	     * @private
	     */
	    this._listeners = {};
	}

	/**
	 * Registers an event listener.
	 * @param {string} evt Event name
	 * @param {function} fn Listener
	 * @param {*} [ctx] Listener context
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.on = function on(evt, fn, ctx) {
	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
	        fn  : fn,
	        ctx : ctx || this
	    });
	    return this;
	};

	/**
	 * Removes an event listener or any matching listeners if arguments are omitted.
	 * @param {string} [evt] Event name. Removes all listeners if omitted.
	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.off = function off(evt, fn) {
	    if (evt === undefined)
	        this._listeners = {};
	    else {
	        if (fn === undefined)
	            this._listeners[evt] = [];
	        else {
	            var listeners = this._listeners[evt];
	            for (var i = 0; i < listeners.length;)
	                if (listeners[i].fn === fn)
	                    listeners.splice(i, 1);
	                else
	                    ++i;
	        }
	    }
	    return this;
	};

	/**
	 * Emits an event by calling its listeners with the specified arguments.
	 * @param {string} evt Event name
	 * @param {...*} args Arguments
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.emit = function emit(evt) {
	    var listeners = this._listeners[evt];
	    if (listeners) {
	        var args = [],
	            i = 1;
	        for (; i < arguments.length;)
	            args.push(arguments[i++]);
	        for (i = 0; i < listeners.length;)
	            listeners[i].fn.apply(listeners[i++].ctx, args);
	    }
	    return this;
	};
	return eventemitter;
}

var float;
var hasRequiredFloat;

function requireFloat () {
	if (hasRequiredFloat) return float;
	hasRequiredFloat = 1;

	float = factory(factory);

	/**
	 * Reads / writes floats / doubles from / to buffers.
	 * @name util.float
	 * @namespace
	 */

	/**
	 * Writes a 32 bit float to a buffer using little endian byte order.
	 * @name util.float.writeFloatLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 32 bit float to a buffer using big endian byte order.
	 * @name util.float.writeFloatBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 32 bit float from a buffer using little endian byte order.
	 * @name util.float.readFloatLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 32 bit float from a buffer using big endian byte order.
	 * @name util.float.readFloatBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Writes a 64 bit double to a buffer using little endian byte order.
	 * @name util.float.writeDoubleLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 64 bit double to a buffer using big endian byte order.
	 * @name util.float.writeDoubleBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 64 bit double from a buffer using little endian byte order.
	 * @name util.float.readDoubleLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 64 bit double from a buffer using big endian byte order.
	 * @name util.float.readDoubleBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	// Factory function for the purpose of node-based testing in modified global environments
	function factory(exports) {

	    // float: typed array
	    if (typeof Float32Array !== "undefined") (function() {

	        var f32 = new Float32Array([ -0 ]),
	            f8b = new Uint8Array(f32.buffer),
	            le  = f8b[3] === 128;

	        function writeFloat_f32_cpy(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	        }

	        function writeFloat_f32_rev(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[3];
	            buf[pos + 1] = f8b[2];
	            buf[pos + 2] = f8b[1];
	            buf[pos + 3] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

	        function readFloat_f32_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            return f32[0];
	        }

	        function readFloat_f32_rev(buf, pos) {
	            f8b[3] = buf[pos    ];
	            f8b[2] = buf[pos + 1];
	            f8b[1] = buf[pos + 2];
	            f8b[0] = buf[pos + 3];
	            return f32[0];
	        }

	        /* istanbul ignore next */
	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

	    // float: ieee754
	    })(); else (function() {

	        function writeFloat_ieee754(writeUint, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0)
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
	            else if (isNaN(val))
	                writeUint(2143289344, buf, pos);
	            else if (val > 3.4028234663852886e+38) // +-Infinity
	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
	            else if (val < 1.1754943508222875e-38) // denormal
	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
	            else {
	                var exponent = Math.floor(Math.log(val) / Math.LN2),
	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
	            }
	        }

	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

	        function readFloat_ieee754(readUint, buf, pos) {
	            var uint = readUint(buf, pos),
	                sign = (uint >> 31) * 2 + 1,
	                exponent = uint >>> 23 & 255,
	                mantissa = uint & 8388607;
	            return exponent === 255
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 1.401298464324817e-45 * mantissa
	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
	        }

	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

	    })();

	    // double: typed array
	    if (typeof Float64Array !== "undefined") (function() {

	        var f64 = new Float64Array([-0]),
	            f8b = new Uint8Array(f64.buffer),
	            le  = f8b[7] === 128;

	        function writeDouble_f64_cpy(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	            buf[pos + 4] = f8b[4];
	            buf[pos + 5] = f8b[5];
	            buf[pos + 6] = f8b[6];
	            buf[pos + 7] = f8b[7];
	        }

	        function writeDouble_f64_rev(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[7];
	            buf[pos + 1] = f8b[6];
	            buf[pos + 2] = f8b[5];
	            buf[pos + 3] = f8b[4];
	            buf[pos + 4] = f8b[3];
	            buf[pos + 5] = f8b[2];
	            buf[pos + 6] = f8b[1];
	            buf[pos + 7] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

	        function readDouble_f64_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            f8b[4] = buf[pos + 4];
	            f8b[5] = buf[pos + 5];
	            f8b[6] = buf[pos + 6];
	            f8b[7] = buf[pos + 7];
	            return f64[0];
	        }

	        function readDouble_f64_rev(buf, pos) {
	            f8b[7] = buf[pos    ];
	            f8b[6] = buf[pos + 1];
	            f8b[5] = buf[pos + 2];
	            f8b[4] = buf[pos + 3];
	            f8b[3] = buf[pos + 4];
	            f8b[2] = buf[pos + 5];
	            f8b[1] = buf[pos + 6];
	            f8b[0] = buf[pos + 7];
	            return f64[0];
	        }

	        /* istanbul ignore next */
	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

	    // double: ieee754
	    })(); else (function() {

	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0) {
	                writeUint(0, buf, pos + off0);
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
	            } else if (isNaN(val)) {
	                writeUint(0, buf, pos + off0);
	                writeUint(2146959360, buf, pos + off1);
	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
	                writeUint(0, buf, pos + off0);
	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
	            } else {
	                var mantissa;
	                if (val < 2.2250738585072014e-308) { // denormal
	                    mantissa = val / 5e-324;
	                    writeUint(mantissa >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
	                } else {
	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
	                    if (exponent === 1024)
	                        exponent = 1023;
	                    mantissa = val * Math.pow(2, -exponent);
	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
	                }
	            }
	        }

	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
	            var lo = readUint(buf, pos + off0),
	                hi = readUint(buf, pos + off1);
	            var sign = (hi >> 31) * 2 + 1,
	                exponent = hi >>> 20 & 2047,
	                mantissa = 4294967296 * (hi & 1048575) + lo;
	            return exponent === 2047
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 5e-324 * mantissa
	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
	        }

	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

	    })();

	    return exports;
	}

	// uint helpers

	function writeUintLE(val, buf, pos) {
	    buf[pos    ] =  val        & 255;
	    buf[pos + 1] =  val >>> 8  & 255;
	    buf[pos + 2] =  val >>> 16 & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	function writeUintBE(val, buf, pos) {
	    buf[pos    ] =  val >>> 24;
	    buf[pos + 1] =  val >>> 16 & 255;
	    buf[pos + 2] =  val >>> 8  & 255;
	    buf[pos + 3] =  val        & 255;
	}

	function readUintLE(buf, pos) {
	    return (buf[pos    ]
	          | buf[pos + 1] << 8
	          | buf[pos + 2] << 16
	          | buf[pos + 3] << 24) >>> 0;
	}

	function readUintBE(buf, pos) {
	    return (buf[pos    ] << 24
	          | buf[pos + 1] << 16
	          | buf[pos + 2] << 8
	          | buf[pos + 3]) >>> 0;
	}
	return float;
}

var inquire_1;
var hasRequiredInquire;

function requireInquire () {
	if (hasRequiredInquire) return inquire_1;
	hasRequiredInquire = 1;
	inquire_1 = inquire;

	/**
	 * Requires a module only if available.
	 * @memberof util
	 * @param {string} moduleName Module to require
	 * @returns {?Object} Required module if available and not empty, otherwise `null`
	 */
	function inquire(moduleName) {
	    try {
	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
	        if (mod && (mod.length || Object.keys(mod).length))
	            return mod;
	    } catch (e) {} // eslint-disable-line no-empty
	    return null;
	}
	return inquire_1;
}

var utf8 = {};

var hasRequiredUtf8;

function requireUtf8 () {
	if (hasRequiredUtf8) return utf8;
	hasRequiredUtf8 = 1;
	(function (exports) {

		/**
		 * A minimal UTF8 implementation for number arrays.
		 * @memberof util
		 * @namespace
		 */
		var utf8 = exports;

		/**
		 * Calculates the UTF8 byte length of a string.
		 * @param {string} string String
		 * @returns {number} Byte length
		 */
		utf8.length = function utf8_length(string) {
		    var len = 0,
		        c = 0;
		    for (var i = 0; i < string.length; ++i) {
		        c = string.charCodeAt(i);
		        if (c < 128)
		            len += 1;
		        else if (c < 2048)
		            len += 2;
		        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
		            ++i;
		            len += 4;
		        } else
		            len += 3;
		    }
		    return len;
		};

		/**
		 * Reads UTF8 bytes as a string.
		 * @param {Uint8Array} buffer Source buffer
		 * @param {number} start Source start
		 * @param {number} end Source end
		 * @returns {string} String read
		 */
		utf8.read = function utf8_read(buffer, start, end) {
		    var len = end - start;
		    if (len < 1)
		        return "";
		    var parts = null,
		        chunk = [],
		        i = 0, // char offset
		        t;     // temporary
		    while (start < end) {
		        t = buffer[start++];
		        if (t < 128)
		            chunk[i++] = t;
		        else if (t > 191 && t < 224)
		            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
		        else if (t > 239 && t < 365) {
		            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
		            chunk[i++] = 0xD800 + (t >> 10);
		            chunk[i++] = 0xDC00 + (t & 1023);
		        } else
		            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
		        if (i > 8191) {
		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
		            i = 0;
		        }
		    }
		    if (parts) {
		        if (i)
		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
		        return parts.join("");
		    }
		    return String.fromCharCode.apply(String, chunk.slice(0, i));
		};

		/**
		 * Writes a string as UTF8 bytes.
		 * @param {string} string Source string
		 * @param {Uint8Array} buffer Destination buffer
		 * @param {number} offset Destination offset
		 * @returns {number} Bytes written
		 */
		utf8.write = function utf8_write(string, buffer, offset) {
		    var start = offset,
		        c1, // character 1
		        c2; // character 2
		    for (var i = 0; i < string.length; ++i) {
		        c1 = string.charCodeAt(i);
		        if (c1 < 128) {
		            buffer[offset++] = c1;
		        } else if (c1 < 2048) {
		            buffer[offset++] = c1 >> 6       | 192;
		            buffer[offset++] = c1       & 63 | 128;
		        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
		            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
		            ++i;
		            buffer[offset++] = c1 >> 18      | 240;
		            buffer[offset++] = c1 >> 12 & 63 | 128;
		            buffer[offset++] = c1 >> 6  & 63 | 128;
		            buffer[offset++] = c1       & 63 | 128;
		        } else {
		            buffer[offset++] = c1 >> 12      | 224;
		            buffer[offset++] = c1 >> 6  & 63 | 128;
		            buffer[offset++] = c1       & 63 | 128;
		        }
		    }
		    return offset - start;
		}; 
	} (utf8));
	return utf8;
}

var pool_1;
var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return pool_1;
	hasRequiredPool = 1;
	pool_1 = pool;

	/**
	 * An allocator as used by {@link util.pool}.
	 * @typedef PoolAllocator
	 * @type {function}
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */

	/**
	 * A slicer as used by {@link util.pool}.
	 * @typedef PoolSlicer
	 * @type {function}
	 * @param {number} start Start offset
	 * @param {number} end End offset
	 * @returns {Uint8Array} Buffer slice
	 * @this {Uint8Array}
	 */

	/**
	 * A general purpose buffer pool.
	 * @memberof util
	 * @function
	 * @param {PoolAllocator} alloc Allocator
	 * @param {PoolSlicer} slice Slicer
	 * @param {number} [size=8192] Slab size
	 * @returns {PoolAllocator} Pooled allocator
	 */
	function pool(alloc, slice, size) {
	    var SIZE   = size || 8192;
	    var MAX    = SIZE >>> 1;
	    var slab   = null;
	    var offset = SIZE;
	    return function pool_alloc(size) {
	        if (size < 1 || size > MAX)
	            return alloc(size);
	        if (offset + size > SIZE) {
	            slab = alloc(SIZE);
	            offset = 0;
	        }
	        var buf = slice.call(slab, offset, offset += size);
	        if (offset & 7) // align to 32 bit
	            offset = (offset | 7) + 1;
	        return buf;
	    };
	}
	return pool_1;
}

var longbits;
var hasRequiredLongbits;

function requireLongbits () {
	if (hasRequiredLongbits) return longbits;
	hasRequiredLongbits = 1;
	longbits = LongBits;

	var util = requireMinimal();

	/**
	 * Constructs new long bits.
	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
	 * @memberof util
	 * @constructor
	 * @param {number} lo Low 32 bits, unsigned
	 * @param {number} hi High 32 bits, unsigned
	 */
	function LongBits(lo, hi) {

	    // note that the casts below are theoretically unnecessary as of today, but older statically
	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

	    /**
	     * Low bits.
	     * @type {number}
	     */
	    this.lo = lo >>> 0;

	    /**
	     * High bits.
	     * @type {number}
	     */
	    this.hi = hi >>> 0;
	}

	/**
	 * Zero bits.
	 * @memberof util.LongBits
	 * @type {util.LongBits}
	 */
	var zero = LongBits.zero = new LongBits(0, 0);

	zero.toNumber = function() { return 0; };
	zero.zzEncode = zero.zzDecode = function() { return this; };
	zero.length = function() { return 1; };

	/**
	 * Zero hash.
	 * @memberof util.LongBits
	 * @type {string}
	 */
	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

	/**
	 * Constructs new long bits from the specified number.
	 * @param {number} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.fromNumber = function fromNumber(value) {
	    if (value === 0)
	        return zero;
	    var sign = value < 0;
	    if (sign)
	        value = -value;
	    var lo = value >>> 0,
	        hi = (value - lo) / 4294967296 >>> 0;
	    if (sign) {
	        hi = ~hi >>> 0;
	        lo = ~lo >>> 0;
	        if (++lo > 4294967295) {
	            lo = 0;
	            if (++hi > 4294967295)
	                hi = 0;
	        }
	    }
	    return new LongBits(lo, hi);
	};

	/**
	 * Constructs new long bits from a number, long or string.
	 * @param {Long|number|string} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.from = function from(value) {
	    if (typeof value === "number")
	        return LongBits.fromNumber(value);
	    if (util.isString(value)) {
	        /* istanbul ignore else */
	        if (util.Long)
	            value = util.Long.fromString(value);
	        else
	            return LongBits.fromNumber(parseInt(value, 10));
	    }
	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
	};

	/**
	 * Converts this long bits to a possibly unsafe JavaScript number.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {number} Possibly unsafe number
	 */
	LongBits.prototype.toNumber = function toNumber(unsigned) {
	    if (!unsigned && this.hi >>> 31) {
	        var lo = ~this.lo + 1 >>> 0,
	            hi = ~this.hi     >>> 0;
	        if (!lo)
	            hi = hi + 1 >>> 0;
	        return -(lo + hi * 4294967296);
	    }
	    return this.lo + this.hi * 4294967296;
	};

	/**
	 * Converts this long bits to a long.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long} Long
	 */
	LongBits.prototype.toLong = function toLong(unsigned) {
	    return util.Long
	        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
	        /* istanbul ignore next */
	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
	};

	var charCodeAt = String.prototype.charCodeAt;

	/**
	 * Constructs new long bits from the specified 8 characters long hash.
	 * @param {string} hash Hash
	 * @returns {util.LongBits} Bits
	 */
	LongBits.fromHash = function fromHash(hash) {
	    if (hash === zeroHash)
	        return zero;
	    return new LongBits(
	        ( charCodeAt.call(hash, 0)
	        | charCodeAt.call(hash, 1) << 8
	        | charCodeAt.call(hash, 2) << 16
	        | charCodeAt.call(hash, 3) << 24) >>> 0
	    ,
	        ( charCodeAt.call(hash, 4)
	        | charCodeAt.call(hash, 5) << 8
	        | charCodeAt.call(hash, 6) << 16
	        | charCodeAt.call(hash, 7) << 24) >>> 0
	    );
	};

	/**
	 * Converts this long bits to a 8 characters long hash.
	 * @returns {string} Hash
	 */
	LongBits.prototype.toHash = function toHash() {
	    return String.fromCharCode(
	        this.lo        & 255,
	        this.lo >>> 8  & 255,
	        this.lo >>> 16 & 255,
	        this.lo >>> 24      ,
	        this.hi        & 255,
	        this.hi >>> 8  & 255,
	        this.hi >>> 16 & 255,
	        this.hi >>> 24
	    );
	};

	/**
	 * Zig-zag encodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzEncode = function zzEncode() {
	    var mask =   this.hi >> 31;
	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Zig-zag decodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzDecode = function zzDecode() {
	    var mask = -(this.lo & 1);
	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Calculates the length of this longbits when encoded as a varint.
	 * @returns {number} Length
	 */
	LongBits.prototype.length = function length() {
	    var part0 =  this.lo,
	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
	        part2 =  this.hi >>> 24;
	    return part2 === 0
	         ? part1 === 0
	           ? part0 < 16384
	             ? part0 < 128 ? 1 : 2
	             : part0 < 2097152 ? 3 : 4
	           : part1 < 16384
	             ? part1 < 128 ? 5 : 6
	             : part1 < 2097152 ? 7 : 8
	         : part2 < 128 ? 9 : 10;
	};
	return longbits;
}

var hasRequiredMinimal;

function requireMinimal () {
	if (hasRequiredMinimal) return minimal;
	hasRequiredMinimal = 1;
	(function (exports) {
		var util = exports;

		// used to return a Promise where callback is omitted
		util.asPromise = requireAspromise();

		// converts to / from base64 encoded strings
		util.base64 = requireBase64();

		// base class of rpc.Service
		util.EventEmitter = requireEventemitter();

		// float handling accross browsers
		util.float = requireFloat();

		// requires modules optionally and hides the call from bundlers
		util.inquire = requireInquire();

		// converts to / from utf8 encoded strings
		util.utf8 = requireUtf8();

		// provides a node-like buffer pool in the browser
		util.pool = requirePool();

		// utility to work with the low and high bits of a 64 bit value
		util.LongBits = requireLongbits();

		/**
		 * Whether running within node or not.
		 * @memberof util
		 * @type {boolean}
		 */
		util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
		                   && commonjsGlobal
		                   && commonjsGlobal.process
		                   && commonjsGlobal.process.versions
		                   && commonjsGlobal.process.versions.node);

		/**
		 * Global object reference.
		 * @memberof util
		 * @type {Object}
		 */
		util.global = util.isNode && commonjsGlobal
		           || typeof window !== "undefined" && window
		           || typeof self   !== "undefined" && self
		           || commonjsGlobal; // eslint-disable-line no-invalid-this

		/**
		 * An immuable empty array.
		 * @memberof util
		 * @type {Array.<*>}
		 * @const
		 */
		util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

		/**
		 * An immutable empty object.
		 * @type {Object}
		 * @const
		 */
		util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

		/**
		 * Tests if the specified value is an integer.
		 * @function
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is an integer
		 */
		util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
		    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
		};

		/**
		 * Tests if the specified value is a string.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a string
		 */
		util.isString = function isString(value) {
		    return typeof value === "string" || value instanceof String;
		};

		/**
		 * Tests if the specified value is a non-null object.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a non-null object
		 */
		util.isObject = function isObject(value) {
		    return value && typeof value === "object";
		};

		/**
		 * Checks if a property on a message is considered to be present.
		 * This is an alias of {@link util.isSet}.
		 * @function
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isset =

		/**
		 * Checks if a property on a message is considered to be present.
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isSet = function isSet(obj, prop) {
		    var value = obj[prop];
		    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
		        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
		    return false;
		};

		/**
		 * Any compatible Buffer instance.
		 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
		 * @interface Buffer
		 * @extends Uint8Array
		 */

		/**
		 * Node's Buffer class if available.
		 * @type {Constructor<Buffer>}
		 */
		util.Buffer = (function() {
		    try {
		        var Buffer = util.inquire("buffer").Buffer;
		        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
		        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
		    } catch (e) {
		        /* istanbul ignore next */
		        return null;
		    }
		})();

		// Internal alias of or polyfull for Buffer.from.
		util._Buffer_from = null;

		// Internal alias of or polyfill for Buffer.allocUnsafe.
		util._Buffer_allocUnsafe = null;

		/**
		 * Creates a new buffer of whatever type supported by the environment.
		 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
		 * @returns {Uint8Array|Buffer} Buffer
		 */
		util.newBuffer = function newBuffer(sizeOrArray) {
		    /* istanbul ignore next */
		    return typeof sizeOrArray === "number"
		        ? util.Buffer
		            ? util._Buffer_allocUnsafe(sizeOrArray)
		            : new util.Array(sizeOrArray)
		        : util.Buffer
		            ? util._Buffer_from(sizeOrArray)
		            : typeof Uint8Array === "undefined"
		                ? sizeOrArray
		                : new Uint8Array(sizeOrArray);
		};

		/**
		 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
		 * @type {Constructor<Uint8Array>}
		 */
		util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

		/**
		 * Any compatible Long instance.
		 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
		 * @interface Long
		 * @property {number} low Low bits
		 * @property {number} high High bits
		 * @property {boolean} unsigned Whether unsigned or not
		 */

		/**
		 * Long.js's Long class if available.
		 * @type {Constructor<Long>}
		 */
		util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
		         || /* istanbul ignore next */ util.global.Long
		         || util.inquire("long");

		/**
		 * Regular expression used to verify 2 bit (`bool`) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key2Re = /^true|false|0|1$/;

		/**
		 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

		/**
		 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

		/**
		 * Converts a number or long to an 8 characters long hash string.
		 * @param {Long|number} value Value to convert
		 * @returns {string} Hash
		 */
		util.longToHash = function longToHash(value) {
		    return value
		        ? util.LongBits.from(value).toHash()
		        : util.LongBits.zeroHash;
		};

		/**
		 * Converts an 8 characters long hash string to a long or number.
		 * @param {string} hash Hash
		 * @param {boolean} [unsigned=false] Whether unsigned or not
		 * @returns {Long|number} Original value
		 */
		util.longFromHash = function longFromHash(hash, unsigned) {
		    var bits = util.LongBits.fromHash(hash);
		    if (util.Long)
		        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
		    return bits.toNumber(Boolean(unsigned));
		};

		/**
		 * Merges the properties of the source object into the destination object.
		 * @memberof util
		 * @param {Object.<string,*>} dst Destination object
		 * @param {Object.<string,*>} src Source object
		 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
		 * @returns {Object.<string,*>} Destination object
		 */
		function merge(dst, src, ifNotSet) { // used by converters
		    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
		        if (dst[keys[i]] === undefined || !ifNotSet)
		            dst[keys[i]] = src[keys[i]];
		    return dst;
		}

		util.merge = merge;

		/**
		 * Converts the first character of a string to lower case.
		 * @param {string} str String to convert
		 * @returns {string} Converted string
		 */
		util.lcFirst = function lcFirst(str) {
		    return str.charAt(0).toLowerCase() + str.substring(1);
		};

		/**
		 * Creates a custom error constructor.
		 * @memberof util
		 * @param {string} name Error name
		 * @returns {Constructor<Error>} Custom error constructor
		 */
		function newError(name) {

		    function CustomError(message, properties) {

		        if (!(this instanceof CustomError))
		            return new CustomError(message, properties);

		        // Error.call(this, message);
		        // ^ just returns a new error instance because the ctor can be called as a function

		        Object.defineProperty(this, "message", { get: function() { return message; } });

		        /* istanbul ignore next */
		        if (Error.captureStackTrace) // node
		            Error.captureStackTrace(this, CustomError);
		        else
		            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

		        if (properties)
		            merge(this, properties);
		    }

		    CustomError.prototype = Object.create(Error.prototype, {
		        constructor: {
		            value: CustomError,
		            writable: true,
		            enumerable: false,
		            configurable: true,
		        },
		        name: {
		            get: function get() { return name; },
		            set: undefined,
		            enumerable: false,
		            // configurable: false would accurately preserve the behavior of
		            // the original, but I'm guessing that was not intentional.
		            // For an actual error subclass, this property would
		            // be configurable.
		            configurable: true,
		        },
		        toString: {
		            value: function value() { return this.name + ": " + this.message; },
		            writable: true,
		            enumerable: false,
		            configurable: true,
		        },
		    });

		    return CustomError;
		}

		util.newError = newError;

		/**
		 * Constructs a new protocol error.
		 * @classdesc Error subclass indicating a protocol specifc error.
		 * @memberof util
		 * @extends Error
		 * @template T extends Message<T>
		 * @constructor
		 * @param {string} message Error message
		 * @param {Object.<string,*>} [properties] Additional properties
		 * @example
		 * try {
		 *     MyMessage.decode(someBuffer); // throws if required fields are missing
		 * } catch (e) {
		 *     if (e instanceof ProtocolError && e.instance)
		 *         console.log("decoded so far: " + JSON.stringify(e.instance));
		 * }
		 */
		util.ProtocolError = newError("ProtocolError");

		/**
		 * So far decoded message instance.
		 * @name util.ProtocolError#instance
		 * @type {Message<T>}
		 */

		/**
		 * A OneOf getter as returned by {@link util.oneOfGetter}.
		 * @typedef OneOfGetter
		 * @type {function}
		 * @returns {string|undefined} Set field name, if any
		 */

		/**
		 * Builds a getter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfGetter} Unbound getter
		 */
		util.oneOfGetter = function getOneOf(fieldNames) {
		    var fieldMap = {};
		    for (var i = 0; i < fieldNames.length; ++i)
		        fieldMap[fieldNames[i]] = 1;

		    /**
		     * @returns {string|undefined} Set field name, if any
		     * @this Object
		     * @ignore
		     */
		    return function() { // eslint-disable-line consistent-return
		        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
		            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
		                return keys[i];
		    };
		};

		/**
		 * A OneOf setter as returned by {@link util.oneOfSetter}.
		 * @typedef OneOfSetter
		 * @type {function}
		 * @param {string|undefined} value Field name
		 * @returns {undefined}
		 */

		/**
		 * Builds a setter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfSetter} Unbound setter
		 */
		util.oneOfSetter = function setOneOf(fieldNames) {

		    /**
		     * @param {string} name Field name
		     * @returns {undefined}
		     * @this Object
		     * @ignore
		     */
		    return function(name) {
		        for (var i = 0; i < fieldNames.length; ++i)
		            if (fieldNames[i] !== name)
		                delete this[fieldNames[i]];
		    };
		};

		/**
		 * Default conversion options used for {@link Message#toJSON} implementations.
		 *
		 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
		 *
		 * - Longs become strings
		 * - Enums become string keys
		 * - Bytes become base64 encoded strings
		 * - (Sub-)Messages become plain objects
		 * - Maps become plain objects with all string keys
		 * - Repeated fields become arrays
		 * - NaN and Infinity for float and double fields become strings
		 *
		 * @type {IConversionOptions}
		 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
		 */
		util.toJSONOptions = {
		    longs: String,
		    enums: String,
		    bytes: String,
		    json: true
		};

		// Sets up buffer utility according to the environment (called in index-minimal)
		util._configure = function() {
		    var Buffer = util.Buffer;
		    /* istanbul ignore if */
		    if (!Buffer) {
		        util._Buffer_from = util._Buffer_allocUnsafe = null;
		        return;
		    }
		    // because node 4.x buffers are incompatible & immutable
		    // see: https://github.com/dcodeIO/protobuf.js/pull/665
		    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
		        /* istanbul ignore next */
		        function Buffer_from(value, encoding) {
		            return new Buffer(value, encoding);
		        };
		    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
		        /* istanbul ignore next */
		        function Buffer_allocUnsafe(size) {
		            return new Buffer(size);
		        };
		}; 
	} (minimal));
	return minimal;
}

var writer;
var hasRequiredWriter;

function requireWriter () {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1;
	writer = Writer;

	var util      = requireMinimal();

	var BufferWriter; // cyclic

	var LongBits  = util.LongBits,
	    base64    = util.base64,
	    utf8      = util.utf8;

	/**
	 * Constructs a new writer operation instance.
	 * @classdesc Scheduled writer operation.
	 * @constructor
	 * @param {function(*, Uint8Array, number)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {*} val Value to write
	 * @ignore
	 */
	function Op(fn, len, val) {

	    /**
	     * Function to call.
	     * @type {function(Uint8Array, number, *)}
	     */
	    this.fn = fn;

	    /**
	     * Value byte length.
	     * @type {number}
	     */
	    this.len = len;

	    /**
	     * Next operation.
	     * @type {Writer.Op|undefined}
	     */
	    this.next = undefined;

	    /**
	     * Value to write.
	     * @type {*}
	     */
	    this.val = val; // type varies
	}

	/* istanbul ignore next */
	function noop() {} // eslint-disable-line no-empty-function

	/**
	 * Constructs a new writer state instance.
	 * @classdesc Copied writer state.
	 * @memberof Writer
	 * @constructor
	 * @param {Writer} writer Writer to copy state from
	 * @ignore
	 */
	function State(writer) {

	    /**
	     * Current head.
	     * @type {Writer.Op}
	     */
	    this.head = writer.head;

	    /**
	     * Current tail.
	     * @type {Writer.Op}
	     */
	    this.tail = writer.tail;

	    /**
	     * Current buffer length.
	     * @type {number}
	     */
	    this.len = writer.len;

	    /**
	     * Next state.
	     * @type {State|null}
	     */
	    this.next = writer.states;
	}

	/**
	 * Constructs a new writer instance.
	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 */
	function Writer() {

	    /**
	     * Current length.
	     * @type {number}
	     */
	    this.len = 0;

	    /**
	     * Operations head.
	     * @type {Object}
	     */
	    this.head = new Op(noop, 0, 0);

	    /**
	     * Operations tail
	     * @type {Object}
	     */
	    this.tail = this.head;

	    /**
	     * Linked forked states.
	     * @type {Object|null}
	     */
	    this.states = null;

	    // When a value is written, the writer calculates its byte length and puts it into a linked
	    // list of operations to perform when finish() is called. This both allows us to allocate
	    // buffers of the exact required size and reduces the amount of work we have to do compared
	    // to first calculating over objects and then encoding over objects. In our case, the encoding
	    // part is just a linked list walk calling operations with already prepared values.
	}

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup() {
	            return (Writer.create = function create_buffer() {
	                return new BufferWriter();
	            })();
	        }
	        /* istanbul ignore next */
	        : function create_array() {
	            return new Writer();
	        };
	};

	/**
	 * Creates a new writer.
	 * @function
	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
	 */
	Writer.create = create();

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */
	Writer.alloc = function alloc(size) {
	    return new util.Array(size);
	};

	// Use Uint8Array buffer pool in the browser, just like node does with buffers
	/* istanbul ignore else */
	if (util.Array !== Array)
	    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

	/**
	 * Pushes a new operation to the queue.
	 * @param {function(Uint8Array, number, *)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @returns {Writer} `this`
	 * @private
	 */
	Writer.prototype._push = function push(fn, len, val) {
	    this.tail = this.tail.next = new Op(fn, len, val);
	    this.len += len;
	    return this;
	};

	function writeByte(val, buf, pos) {
	    buf[pos] = val & 255;
	}

	function writeVarint32(val, buf, pos) {
	    while (val > 127) {
	        buf[pos++] = val & 127 | 128;
	        val >>>= 7;
	    }
	    buf[pos] = val;
	}

	/**
	 * Constructs a new varint writer operation instance.
	 * @classdesc Scheduled varint writer operation.
	 * @extends Op
	 * @constructor
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @ignore
	 */
	function VarintOp(len, val) {
	    this.len = len;
	    this.next = undefined;
	    this.val = val;
	}

	VarintOp.prototype = Object.create(Op.prototype);
	VarintOp.prototype.fn = writeVarint32;

	/**
	 * Writes an unsigned 32 bit value as a varint.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.uint32 = function write_uint32(value) {
	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
	    // uint32 is by far the most frequently used operation and benefits significantly from this.
	    this.len += (this.tail = this.tail.next = new VarintOp(
	        (value = value >>> 0)
	                < 128       ? 1
	        : value < 16384     ? 2
	        : value < 2097152   ? 3
	        : value < 268435456 ? 4
	        :                     5,
	    value)).len;
	    return this;
	};

	/**
	 * Writes a signed 32 bit value as a varint.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.int32 = function write_int32(value) {
	    return value < 0
	        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
	        : this.uint32(value);
	};

	/**
	 * Writes a 32 bit value as a varint, zig-zag encoded.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sint32 = function write_sint32(value) {
	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
	};

	function writeVarint64(val, buf, pos) {
	    while (val.hi) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
	        val.hi >>>= 7;
	    }
	    while (val.lo > 127) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = val.lo >>> 7;
	    }
	    buf[pos++] = val.lo;
	}

	/**
	 * Writes an unsigned 64 bit value as a varint.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.uint64 = function write_uint64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a signed 64 bit value as a varint.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.int64 = Writer.prototype.uint64;

	/**
	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sint64 = function write_sint64(value) {
	    var bits = LongBits.from(value).zzEncode();
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a boolish value as a varint.
	 * @param {boolean} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bool = function write_bool(value) {
	    return this._push(writeByte, 1, value ? 1 : 0);
	};

	function writeFixed32(val, buf, pos) {
	    buf[pos    ] =  val         & 255;
	    buf[pos + 1] =  val >>> 8   & 255;
	    buf[pos + 2] =  val >>> 16  & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	/**
	 * Writes an unsigned 32 bit value as fixed 32 bits.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fixed32 = function write_fixed32(value) {
	    return this._push(writeFixed32, 4, value >>> 0);
	};

	/**
	 * Writes a signed 32 bit value as fixed 32 bits.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

	/**
	 * Writes an unsigned 64 bit value as fixed 64 bits.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.fixed64 = function write_fixed64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
	};

	/**
	 * Writes a signed 64 bit value as fixed 64 bits.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

	/**
	 * Writes a float (32 bit).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.float = function write_float(value) {
	    return this._push(util.float.writeFloatLE, 4, value);
	};

	/**
	 * Writes a double (64 bit float).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.double = function write_double(value) {
	    return this._push(util.float.writeDoubleLE, 8, value);
	};

	var writeBytes = util.Array.prototype.set
	    ? function writeBytes_set(val, buf, pos) {
	        buf.set(val, pos); // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytes_for(val, buf, pos) {
	        for (var i = 0; i < val.length; ++i)
	            buf[pos + i] = val[i];
	    };

	/**
	 * Writes a sequence of bytes.
	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bytes = function write_bytes(value) {
	    var len = value.length >>> 0;
	    if (!len)
	        return this._push(writeByte, 1, 0);
	    if (util.isString(value)) {
	        var buf = Writer.alloc(len = base64.length(value));
	        base64.decode(value, buf, 0);
	        value = buf;
	    }
	    return this.uint32(len)._push(writeBytes, len, value);
	};

	/**
	 * Writes a string.
	 * @param {string} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.string = function write_string(value) {
	    var len = utf8.length(value);
	    return len
	        ? this.uint32(len)._push(utf8.write, len, value)
	        : this._push(writeByte, 1, 0);
	};

	/**
	 * Forks this writer's state by pushing it to a stack.
	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fork = function fork() {
	    this.states = new State(this);
	    this.head = this.tail = new Op(noop, 0, 0);
	    this.len = 0;
	    return this;
	};

	/**
	 * Resets this instance to the last state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.reset = function reset() {
	    if (this.states) {
	        this.head   = this.states.head;
	        this.tail   = this.states.tail;
	        this.len    = this.states.len;
	        this.states = this.states.next;
	    } else {
	        this.head = this.tail = new Op(noop, 0, 0);
	        this.len  = 0;
	    }
	    return this;
	};

	/**
	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.ldelim = function ldelim() {
	    var head = this.head,
	        tail = this.tail,
	        len  = this.len;
	    this.reset().uint32(len);
	    if (len) {
	        this.tail.next = head.next; // skip noop
	        this.tail = tail;
	        this.len += len;
	    }
	    return this;
	};

	/**
	 * Finishes the write operation.
	 * @returns {Uint8Array} Finished buffer
	 */
	Writer.prototype.finish = function finish() {
	    var head = this.head.next, // skip noop
	        buf  = this.constructor.alloc(this.len),
	        pos  = 0;
	    while (head) {
	        head.fn(head.val, buf, pos);
	        pos += head.len;
	        head = head.next;
	    }
	    // this.head = this.tail = null;
	    return buf;
	};

	Writer._configure = function(BufferWriter_) {
	    BufferWriter = BufferWriter_;
	    Writer.create = create();
	    BufferWriter._configure();
	};
	return writer;
}

var writer_buffer;
var hasRequiredWriter_buffer;

function requireWriter_buffer () {
	if (hasRequiredWriter_buffer) return writer_buffer;
	hasRequiredWriter_buffer = 1;
	writer_buffer = BufferWriter;

	// extends Writer
	var Writer = requireWriter();
	(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

	var util = requireMinimal();

	/**
	 * Constructs a new buffer writer instance.
	 * @classdesc Wire format writer using node buffers.
	 * @extends Writer
	 * @constructor
	 */
	function BufferWriter() {
	    Writer.call(this);
	}

	BufferWriter._configure = function () {
	    /**
	     * Allocates a buffer of the specified size.
	     * @function
	     * @param {number} size Buffer size
	     * @returns {Buffer} Buffer
	     */
	    BufferWriter.alloc = util._Buffer_allocUnsafe;

	    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
	        ? function writeBytesBuffer_set(val, buf, pos) {
	          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
	          // also works for plain array values
	        }
	        /* istanbul ignore next */
	        : function writeBytesBuffer_copy(val, buf, pos) {
	          if (val.copy) // Buffer values
	            val.copy(buf, pos, 0, val.length);
	          else for (var i = 0; i < val.length;) // plain array values
	            buf[pos++] = val[i++];
	        };
	};


	/**
	 * @override
	 */
	BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
	    if (util.isString(value))
	        value = util._Buffer_from(value, "base64");
	    var len = value.length >>> 0;
	    this.uint32(len);
	    if (len)
	        this._push(BufferWriter.writeBytesBuffer, len, value);
	    return this;
	};

	function writeStringBuffer(val, buf, pos) {
	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
	        util.utf8.write(val, buf, pos);
	    else if (buf.utf8Write)
	        buf.utf8Write(val, pos);
	    else
	        buf.write(val, pos);
	}

	/**
	 * @override
	 */
	BufferWriter.prototype.string = function write_string_buffer(value) {
	    var len = util.Buffer.byteLength(value);
	    this.uint32(len);
	    if (len)
	        this._push(writeStringBuffer, len, value);
	    return this;
	};


	/**
	 * Finishes the write operation.
	 * @name BufferWriter#finish
	 * @function
	 * @returns {Buffer} Finished buffer
	 */

	BufferWriter._configure();
	return writer_buffer;
}

var reader;
var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	reader = Reader;

	var util      = requireMinimal();

	var BufferReader; // cyclic

	var LongBits  = util.LongBits,
	    utf8      = util.utf8;

	/* istanbul ignore next */
	function indexOutOfRange(reader, writeLength) {
	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
	}

	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {

	    /**
	     * Read buffer.
	     * @type {Uint8Array}
	     */
	    this.buf = buffer;

	    /**
	     * Read buffer position.
	     * @type {number}
	     */
	    this.pos = 0;

	    /**
	     * Read buffer length.
	     * @type {number}
	     */
	    this.len = buffer.length;
	}

	var create_array = typeof Uint8Array !== "undefined"
	    ? function create_typed_array(buffer) {
	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    }
	    /* istanbul ignore next */
	    : function create_array(buffer) {
	        if (Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    };

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup(buffer) {
	            return (Reader.create = function create_buffer(buffer) {
	                return util.Buffer.isBuffer(buffer)
	                    ? new BufferReader(buffer)
	                    /* istanbul ignore next */
	                    : create_array(buffer);
	            })(buffer);
	        }
	        /* istanbul ignore next */
	        : create_array;
	};

	/**
	 * Creates a new reader using the specified buffer.
	 * @function
	 * @param {Uint8Array|Buffer} buffer Buffer to read from
	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
	 * @throws {Error} If `buffer` is not a valid buffer
	 */
	Reader.create = create();

	Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

	/**
	 * Reads a varint as an unsigned 32 bit value.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.uint32 = (function read_uint32_setup() {
	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
	    return function read_uint32() {
	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

	        /* istanbul ignore if */
	        if ((this.pos += 5) > this.len) {
	            this.pos = this.len;
	            throw indexOutOfRange(this, 10);
	        }
	        return value;
	    };
	})();

	/**
	 * Reads a varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.int32 = function read_int32() {
	    return this.uint32() | 0;
	};

	/**
	 * Reads a zig-zag encoded varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.sint32 = function read_sint32() {
	    var value = this.uint32();
	    return value >>> 1 ^ -(value & 1) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readLongVarint() {
	    // tends to deopt with local vars for octet etc.
	    var bits = new LongBits(0, 0);
	    var i = 0;
	    if (this.len - this.pos > 4) { // fast route (lo)
	        for (; i < 4; ++i) {
	            // 1st..4th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 5th
	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
	        if (this.buf[this.pos++] < 128)
	            return bits;
	        i = 0;
	    } else {
	        for (; i < 3; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 1st..3th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 4th
	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
	        return bits;
	    }
	    if (this.len - this.pos > 4) { // fast route (hi)
	        for (; i < 5; ++i) {
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    } else {
	        for (; i < 5; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    }
	    /* istanbul ignore next */
	    throw Error("invalid varint encoding");
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads a varint as a signed 64 bit value.
	 * @name Reader#int64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as an unsigned 64 bit value.
	 * @name Reader#uint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a zig-zag encoded varint as a signed 64 bit value.
	 * @name Reader#sint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as a boolean.
	 * @returns {boolean} Value read
	 */
	Reader.prototype.bool = function read_bool() {
	    return this.uint32() !== 0;
	};

	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
	    return (buf[end - 4]
	          | buf[end - 3] << 8
	          | buf[end - 2] << 16
	          | buf[end - 1] << 24) >>> 0;
	}

	/**
	 * Reads fixed 32 bits as an unsigned 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.fixed32 = function read_fixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4);
	};

	/**
	 * Reads fixed 32 bits as a signed 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.sfixed32 = function read_sfixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readFixed64(/* this: Reader */) {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 8);

	    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads fixed 64 bits.
	 * @name Reader#fixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads zig-zag encoded fixed 64 bits.
	 * @name Reader#sfixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a float (32 bit) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.float = function read_float() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readFloatLE(this.buf, this.pos);
	    this.pos += 4;
	    return value;
	};

	/**
	 * Reads a double (64 bit float) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.double = function read_double() {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readDoubleLE(this.buf, this.pos);
	    this.pos += 8;
	    return value;
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @returns {Uint8Array} Value read
	 */
	Reader.prototype.bytes = function read_bytes() {
	    var length = this.uint32(),
	        start  = this.pos,
	        end    = this.pos + length;

	    /* istanbul ignore if */
	    if (end > this.len)
	        throw indexOutOfRange(this, length);

	    this.pos += length;
	    if (Array.isArray(this.buf)) // plain array
	        return this.buf.slice(start, end);

	    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
	        var nativeBuffer = util.Buffer;
	        return nativeBuffer
	            ? nativeBuffer.alloc(0)
	            : new this.buf.constructor(0);
	    }
	    return this._slice.call(this.buf, start, end);
	};

	/**
	 * Reads a string preceeded by its byte length as a varint.
	 * @returns {string} Value read
	 */
	Reader.prototype.string = function read_string() {
	    var bytes = this.bytes();
	    return utf8.read(bytes, 0, bytes.length);
	};

	/**
	 * Skips the specified number of bytes if specified, otherwise skips a varint.
	 * @param {number} [length] Length if known, otherwise a varint is assumed
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skip = function skip(length) {
	    if (typeof length === "number") {
	        /* istanbul ignore if */
	        if (this.pos + length > this.len)
	            throw indexOutOfRange(this, length);
	        this.pos += length;
	    } else {
	        do {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	        } while (this.buf[this.pos++] & 128);
	    }
	    return this;
	};

	/**
	 * Skips the next element of the specified wire type.
	 * @param {number} wireType Wire type received
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skipType = function(wireType) {
	    switch (wireType) {
	        case 0:
	            this.skip();
	            break;
	        case 1:
	            this.skip(8);
	            break;
	        case 2:
	            this.skip(this.uint32());
	            break;
	        case 3:
	            while ((wireType = this.uint32() & 7) !== 4) {
	                this.skipType(wireType);
	            }
	            break;
	        case 5:
	            this.skip(4);
	            break;

	        /* istanbul ignore next */
	        default:
	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
	    }
	    return this;
	};

	Reader._configure = function(BufferReader_) {
	    BufferReader = BufferReader_;
	    Reader.create = create();
	    BufferReader._configure();

	    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
	    util.merge(Reader.prototype, {

	        int64: function read_int64() {
	            return readLongVarint.call(this)[fn](false);
	        },

	        uint64: function read_uint64() {
	            return readLongVarint.call(this)[fn](true);
	        },

	        sint64: function read_sint64() {
	            return readLongVarint.call(this).zzDecode()[fn](false);
	        },

	        fixed64: function read_fixed64() {
	            return readFixed64.call(this)[fn](true);
	        },

	        sfixed64: function read_sfixed64() {
	            return readFixed64.call(this)[fn](false);
	        }

	    });
	};
	return reader;
}

var reader_buffer;
var hasRequiredReader_buffer;

function requireReader_buffer () {
	if (hasRequiredReader_buffer) return reader_buffer;
	hasRequiredReader_buffer = 1;
	reader_buffer = BufferReader;

	// extends Reader
	var Reader = requireReader();
	(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

	var util = requireMinimal();

	/**
	 * Constructs a new buffer reader instance.
	 * @classdesc Wire format reader using node buffers.
	 * @extends Reader
	 * @constructor
	 * @param {Buffer} buffer Buffer to read from
	 */
	function BufferReader(buffer) {
	    Reader.call(this, buffer);

	    /**
	     * Read buffer.
	     * @name BufferReader#buf
	     * @type {Buffer}
	     */
	}

	BufferReader._configure = function () {
	    /* istanbul ignore else */
	    if (util.Buffer)
	        BufferReader.prototype._slice = util.Buffer.prototype.slice;
	};


	/**
	 * @override
	 */
	BufferReader.prototype.string = function read_string_buffer() {
	    var len = this.uint32(); // modifies pos
	    return this.buf.utf8Slice
	        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
	        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @name BufferReader#bytes
	 * @function
	 * @returns {Buffer} Value read
	 */

	BufferReader._configure();
	return reader_buffer;
}

var rpc = {};

var service$1;
var hasRequiredService$1;

function requireService$1 () {
	if (hasRequiredService$1) return service$1;
	hasRequiredService$1 = 1;
	service$1 = Service;

	var util = requireMinimal();

	// Extends EventEmitter
	(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

	/**
	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
	 *
	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
	 * @typedef rpc.ServiceMethodCallback
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {TRes} [response] Response message
	 * @returns {undefined}
	 */

	/**
	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
	 * @typedef rpc.ServiceMethod
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
	 */

	/**
	 * Constructs a new RPC service instance.
	 * @classdesc An RPC service as returned by {@link Service#create}.
	 * @exports rpc.Service
	 * @extends util.EventEmitter
	 * @constructor
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 */
	function Service(rpcImpl, requestDelimited, responseDelimited) {

	    if (typeof rpcImpl !== "function")
	        throw TypeError("rpcImpl must be a function");

	    util.EventEmitter.call(this);

	    /**
	     * RPC implementation. Becomes `null` once the service is ended.
	     * @type {RPCImpl|null}
	     */
	    this.rpcImpl = rpcImpl;

	    /**
	     * Whether requests are length-delimited.
	     * @type {boolean}
	     */
	    this.requestDelimited = Boolean(requestDelimited);

	    /**
	     * Whether responses are length-delimited.
	     * @type {boolean}
	     */
	    this.responseDelimited = Boolean(responseDelimited);
	}

	/**
	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
	 * @param {Constructor<TReq>} requestCtor Request constructor
	 * @param {Constructor<TRes>} responseCtor Response constructor
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
	 * @returns {undefined}
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 */
	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

	    if (!request)
	        throw TypeError("request must be specified");

	    var self = this;
	    if (!callback)
	        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

	    if (!self.rpcImpl) {
	        setTimeout(function() { callback(Error("already ended")); }, 0);
	        return undefined;
	    }

	    try {
	        return self.rpcImpl(
	            method,
	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
	            function rpcCallback(err, response) {

	                if (err) {
	                    self.emit("error", err, method);
	                    return callback(err);
	                }

	                if (response === null) {
	                    self.end(/* endedByRPC */ true);
	                    return undefined;
	                }

	                if (!(response instanceof responseCtor)) {
	                    try {
	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
	                    } catch (err) {
	                        self.emit("error", err, method);
	                        return callback(err);
	                    }
	                }

	                self.emit("data", response, method);
	                return callback(null, response);
	            }
	        );
	    } catch (err) {
	        self.emit("error", err, method);
	        setTimeout(function() { callback(err); }, 0);
	        return undefined;
	    }
	};

	/**
	 * Ends this service and emits the `end` event.
	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
	 * @returns {rpc.Service} `this`
	 */
	Service.prototype.end = function end(endedByRPC) {
	    if (this.rpcImpl) {
	        if (!endedByRPC) // signal end to rpcImpl
	            this.rpcImpl(null, null, null);
	        this.rpcImpl = null;
	        this.emit("end").off();
	    }
	    return this;
	};
	return service$1;
}

var hasRequiredRpc;

function requireRpc () {
	if (hasRequiredRpc) return rpc;
	hasRequiredRpc = 1;
	(function (exports) {

		/**
		 * Streaming RPC helpers.
		 * @namespace
		 */
		var rpc = exports;

		/**
		 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
		 * @typedef RPCImpl
		 * @type {function}
		 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
		 * @param {Uint8Array} requestData Request data
		 * @param {RPCImplCallback} callback Callback function
		 * @returns {undefined}
		 * @example
		 * function rpcImpl(method, requestData, callback) {
		 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
		 *         throw Error("no such method");
		 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
		 *         callback(err, responseData);
		 *     });
		 * }
		 */

		/**
		 * Node-style callback as used by {@link RPCImpl}.
		 * @typedef RPCImplCallback
		 * @type {function}
		 * @param {Error|null} error Error, if any, otherwise `null`
		 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
		 * @returns {undefined}
		 */

		rpc.Service = requireService$1(); 
	} (rpc));
	return rpc;
}

var roots;
var hasRequiredRoots;

function requireRoots () {
	if (hasRequiredRoots) return roots;
	hasRequiredRoots = 1;
	roots = {};

	/**
	 * Named roots.
	 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
	 * Can also be used manually to make roots available across modules.
	 * @name roots
	 * @type {Object.<string,Root>}
	 * @example
	 * // pbjs -r myroot -o compiled.js ...
	 *
	 * // in another module:
	 * require("./compiled.js");
	 *
	 * // in any subsequent module:
	 * var root = protobuf.roots["myroot"];
	 */
	return roots;
}

var hasRequiredIndexMinimal;

function requireIndexMinimal () {
	if (hasRequiredIndexMinimal) return indexMinimal;
	hasRequiredIndexMinimal = 1;
	(function (exports) {
		var protobuf = exports;

		/**
		 * Build type, one of `"full"`, `"light"` or `"minimal"`.
		 * @name build
		 * @type {string}
		 * @const
		 */
		protobuf.build = "minimal";

		// Serialization
		protobuf.Writer       = requireWriter();
		protobuf.BufferWriter = requireWriter_buffer();
		protobuf.Reader       = requireReader();
		protobuf.BufferReader = requireReader_buffer();

		// Utility
		protobuf.util         = requireMinimal();
		protobuf.rpc          = requireRpc();
		protobuf.roots        = requireRoots();
		protobuf.configure    = configure;

		/* istanbul ignore next */
		/**
		 * Reconfigures the library according to the environment.
		 * @returns {undefined}
		 */
		function configure() {
		    protobuf.util._configure();
		    protobuf.Writer._configure(protobuf.BufferWriter);
		    protobuf.Reader._configure(protobuf.BufferReader);
		}

		// Set up buffer utility according to the environment
		configure(); 
	} (indexMinimal));
	return indexMinimal;
}

var util$2 = {exports: {}};

var codegen_1;
var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen_1;
	hasRequiredCodegen = 1;
	codegen_1 = codegen;

	/**
	 * Begins generating a function.
	 * @memberof util
	 * @param {string[]} functionParams Function parameter names
	 * @param {string} [functionName] Function name if not anonymous
	 * @returns {Codegen} Appender that appends code to the function's body
	 */
	function codegen(functionParams, functionName) {

	    /* istanbul ignore if */
	    if (typeof functionParams === "string") {
	        functionName = functionParams;
	        functionParams = undefined;
	    }

	    var body = [];

	    /**
	     * Appends code to the function's body or finishes generation.
	     * @typedef Codegen
	     * @type {function}
	     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
	     * @param {...*} [formatParams] Format parameters
	     * @returns {Codegen|Function} Itself or the generated function if finished
	     * @throws {Error} If format parameter counts do not match
	     */

	    function Codegen(formatStringOrScope) {
	        // note that explicit array handling below makes this ~50% faster

	        // finish the function
	        if (typeof formatStringOrScope !== "string") {
	            var source = toString();
	            if (codegen.verbose)
	                console.log("codegen: " + source); // eslint-disable-line no-console
	            source = "return " + source;
	            if (formatStringOrScope) {
	                var scopeKeys   = Object.keys(formatStringOrScope),
	                    scopeParams = new Array(scopeKeys.length + 1),
	                    scopeValues = new Array(scopeKeys.length),
	                    scopeOffset = 0;
	                while (scopeOffset < scopeKeys.length) {
	                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
	                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
	                }
	                scopeParams[scopeOffset] = source;
	                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
	            }
	            return Function(source)(); // eslint-disable-line no-new-func
	        }

	        // otherwise append to body
	        var formatParams = new Array(arguments.length - 1),
	            formatOffset = 0;
	        while (formatOffset < formatParams.length)
	            formatParams[formatOffset] = arguments[++formatOffset];
	        formatOffset = 0;
	        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
	            var value = formatParams[formatOffset++];
	            switch ($1) {
	                case "d": case "f": return String(Number(value));
	                case "i": return String(Math.floor(value));
	                case "j": return JSON.stringify(value);
	                case "s": return String(value);
	            }
	            return "%";
	        });
	        if (formatOffset !== formatParams.length)
	            throw Error("parameter count mismatch");
	        body.push(formatStringOrScope);
	        return Codegen;
	    }

	    function toString(functionNameOverride) {
	        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
	    }

	    Codegen.toString = toString;
	    return Codegen;
	}

	/**
	 * Begins generating a function.
	 * @memberof util
	 * @function codegen
	 * @param {string} [functionName] Function name if not anonymous
	 * @returns {Codegen} Appender that appends code to the function's body
	 * @variation 2
	 */

	/**
	 * When set to `true`, codegen will log generated code to console. Useful for debugging.
	 * @name util.codegen.verbose
	 * @type {boolean}
	 */
	codegen.verbose = false;
	return codegen_1;
}

var fetch_1;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1;
	fetch_1 = fetch;

	var asPromise = requireAspromise(),
	    inquire   = requireInquire();

	var fs = inquire("fs");

	/**
	 * Node-style callback as used by {@link util.fetch}.
	 * @typedef FetchCallback
	 * @type {function}
	 * @param {?Error} error Error, if any, otherwise `null`
	 * @param {string} [contents] File contents, if there hasn't been an error
	 * @returns {undefined}
	 */

	/**
	 * Options as used by {@link util.fetch}.
	 * @typedef FetchOptions
	 * @type {Object}
	 * @property {boolean} [binary=false] Whether expecting a binary response
	 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
	 */

	/**
	 * Fetches the contents of a file.
	 * @memberof util
	 * @param {string} filename File path or url
	 * @param {FetchOptions} options Fetch options
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 */
	function fetch(filename, options, callback) {
	    if (typeof options === "function") {
	        callback = options;
	        options = {};
	    } else if (!options)
	        options = {};

	    if (!callback)
	        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

	    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
	    if (!options.xhr && fs && fs.readFile)
	        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
	            return err && typeof XMLHttpRequest !== "undefined"
	                ? fetch.xhr(filename, options, callback)
	                : err
	                ? callback(err)
	                : callback(null, options.binary ? contents : contents.toString("utf8"));
	        });

	    // use the XHR version otherwise.
	    return fetch.xhr(filename, options, callback);
	}

	/**
	 * Fetches the contents of a file.
	 * @name util.fetch
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 * @variation 2
	 */

	/**
	 * Fetches the contents of a file.
	 * @name util.fetch
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchOptions} [options] Fetch options
	 * @returns {Promise<string|Uint8Array>} Promise
	 * @variation 3
	 */

	/**/
	fetch.xhr = function fetch_xhr(filename, options, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

	        if (xhr.readyState !== 4)
	            return undefined;

	        // local cors security errors return status 0 / empty string, too. afaik this cannot be
	        // reliably distinguished from an actually empty file for security reasons. feel free
	        // to send a pull request if you are aware of a solution.
	        if (xhr.status !== 0 && xhr.status !== 200)
	            return callback(Error("status " + xhr.status));

	        // if binary data is expected, make sure that some sort of array is returned, even if
	        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
	        if (options.binary) {
	            var buffer = xhr.response;
	            if (!buffer) {
	                buffer = [];
	                for (var i = 0; i < xhr.responseText.length; ++i)
	                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
	            }
	            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
	        }
	        return callback(null, xhr.responseText);
	    };

	    if (options.binary) {
	        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
	        if ("overrideMimeType" in xhr)
	            xhr.overrideMimeType("text/plain; charset=x-user-defined");
	        xhr.responseType = "arraybuffer";
	    }

	    xhr.open("GET", filename);
	    xhr.send();
	};
	return fetch_1;
}

var path$1 = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path$1;
	hasRequiredPath = 1;
	(function (exports) {

		/**
		 * A minimal path module to resolve Unix, Windows and URL paths alike.
		 * @memberof util
		 * @namespace
		 */
		var path = exports;

		var isAbsolute =
		/**
		 * Tests if the specified path is absolute.
		 * @param {string} path Path to test
		 * @returns {boolean} `true` if path is absolute
		 */
		path.isAbsolute = function isAbsolute(path) {
		    return /^(?:\/|\w+:)/.test(path);
		};

		var normalize =
		/**
		 * Normalizes the specified path.
		 * @param {string} path Path to normalize
		 * @returns {string} Normalized path
		 */
		path.normalize = function normalize(path) {
		    path = path.replace(/\\/g, "/")
		               .replace(/\/{2,}/g, "/");
		    var parts    = path.split("/"),
		        absolute = isAbsolute(path),
		        prefix   = "";
		    if (absolute)
		        prefix = parts.shift() + "/";
		    for (var i = 0; i < parts.length;) {
		        if (parts[i] === "..") {
		            if (i > 0 && parts[i - 1] !== "..")
		                parts.splice(--i, 2);
		            else if (absolute)
		                parts.splice(i, 1);
		            else
		                ++i;
		        } else if (parts[i] === ".")
		            parts.splice(i, 1);
		        else
		            ++i;
		    }
		    return prefix + parts.join("/");
		};

		/**
		 * Resolves the specified include path against the specified origin path.
		 * @param {string} originPath Path to the origin file
		 * @param {string} includePath Include path relative to origin path
		 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
		 * @returns {string} Path to the include file
		 */
		path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
		    if (!alreadyNormalized)
		        includePath = normalize(includePath);
		    if (isAbsolute(includePath))
		        return includePath;
		    if (!alreadyNormalized)
		        originPath = normalize(originPath);
		    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
		}; 
	} (path$1));
	return path$1;
}

var types$1 = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types$1;
	hasRequiredTypes = 1;
	(function (exports) {

		/**
		 * Common type constants.
		 * @namespace
		 */
		var types = exports;

		var util = requireUtil$1();

		var s = [
		    "double",   // 0
		    "float",    // 1
		    "int32",    // 2
		    "uint32",   // 3
		    "sint32",   // 4
		    "fixed32",  // 5
		    "sfixed32", // 6
		    "int64",    // 7
		    "uint64",   // 8
		    "sint64",   // 9
		    "fixed64",  // 10
		    "sfixed64", // 11
		    "bool",     // 12
		    "string",   // 13
		    "bytes"     // 14
		];

		function bake(values, offset) {
		    var i = 0, o = {};
		    offset |= 0;
		    while (i < values.length) o[s[i + offset]] = values[i++];
		    return o;
		}

		/**
		 * Basic type wire types.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} double=1 Fixed64 wire type
		 * @property {number} float=5 Fixed32 wire type
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 * @property {number} string=2 Ldelim wire type
		 * @property {number} bytes=2 Ldelim wire type
		 */
		types.basic = bake([
		    /* double   */ 1,
		    /* float    */ 5,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0,
		    /* string   */ 2,
		    /* bytes    */ 2
		]);

		/**
		 * Basic type defaults.
		 * @type {Object.<string,*>}
		 * @const
		 * @property {number} double=0 Double default
		 * @property {number} float=0 Float default
		 * @property {number} int32=0 Int32 default
		 * @property {number} uint32=0 Uint32 default
		 * @property {number} sint32=0 Sint32 default
		 * @property {number} fixed32=0 Fixed32 default
		 * @property {number} sfixed32=0 Sfixed32 default
		 * @property {number} int64=0 Int64 default
		 * @property {number} uint64=0 Uint64 default
		 * @property {number} sint64=0 Sint32 default
		 * @property {number} fixed64=0 Fixed64 default
		 * @property {number} sfixed64=0 Sfixed64 default
		 * @property {boolean} bool=false Bool default
		 * @property {string} string="" String default
		 * @property {Array.<number>} bytes=Array(0) Bytes default
		 * @property {null} message=null Message default
		 */
		types.defaults = bake([
		    /* double   */ 0,
		    /* float    */ 0,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 0,
		    /* sfixed32 */ 0,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 0,
		    /* sfixed64 */ 0,
		    /* bool     */ false,
		    /* string   */ "",
		    /* bytes    */ util.emptyArray,
		    /* message  */ null
		]);

		/**
		 * Basic long type wire types.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 */
		types.long = bake([
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1
		], 7);

		/**
		 * Allowed types for map keys with their associated wire type.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 * @property {number} string=2 Ldelim wire type
		 */
		types.mapKey = bake([
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0,
		    /* string   */ 2
		], 2);

		/**
		 * Allowed types for packed repeated fields with their associated wire type.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} double=1 Fixed64 wire type
		 * @property {number} float=5 Fixed32 wire type
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 */
		types.packed = bake([
		    /* double   */ 1,
		    /* float    */ 5,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0
		]); 
	} (types$1));
	return types$1;
}

var field;
var hasRequiredField;

function requireField () {
	if (hasRequiredField) return field;
	hasRequiredField = 1;
	field = Field;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

	var Enum  = require_enum(),
	    types = requireTypes(),
	    util  = requireUtil$1();

	var Type; // cyclic

	var ruleRe = /^required|optional|repeated$/;

	/**
	 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
	 * @name Field
	 * @classdesc Reflected message field.
	 * @extends FieldBase
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} type Value type
	 * @param {string|Object.<string,*>} [rule="optional"] Field rule
	 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
	 * @param {Object.<string,*>} [options] Declared options
	 */

	/**
	 * Constructs a field from a field descriptor.
	 * @param {string} name Field name
	 * @param {IField} json Field descriptor
	 * @returns {Field} Created field
	 * @throws {TypeError} If arguments are invalid
	 */
	Field.fromJSON = function fromJSON(name, json) {
	    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
	};

	/**
	 * Not an actual constructor. Use {@link Field} instead.
	 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
	 * @exports FieldBase
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} type Value type
	 * @param {string|Object.<string,*>} [rule="optional"] Field rule
	 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function Field(name, id, type, rule, extend, options, comment) {

	    if (util.isObject(rule)) {
	        comment = extend;
	        options = rule;
	        rule = extend = undefined;
	    } else if (util.isObject(extend)) {
	        comment = options;
	        options = extend;
	        extend = undefined;
	    }

	    ReflectionObject.call(this, name, options);

	    if (!util.isInteger(id) || id < 0)
	        throw TypeError("id must be a non-negative integer");

	    if (!util.isString(type))
	        throw TypeError("type must be a string");

	    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
	        throw TypeError("rule must be a string rule");

	    if (extend !== undefined && !util.isString(extend))
	        throw TypeError("extend must be a string");

	    /**
	     * Field rule, if any.
	     * @type {string|undefined}
	     */
	    if (rule === "proto3_optional") {
	        rule = "optional";
	    }
	    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

	    /**
	     * Field type.
	     * @type {string}
	     */
	    this.type = type; // toJSON

	    /**
	     * Unique field id.
	     * @type {number}
	     */
	    this.id = id; // toJSON, marker

	    /**
	     * Extended type if different from parent.
	     * @type {string|undefined}
	     */
	    this.extend = extend || undefined; // toJSON

	    /**
	     * Whether this field is required.
	     * @type {boolean}
	     */
	    this.required = rule === "required";

	    /**
	     * Whether this field is optional.
	     * @type {boolean}
	     */
	    this.optional = !this.required;

	    /**
	     * Whether this field is repeated.
	     * @type {boolean}
	     */
	    this.repeated = rule === "repeated";

	    /**
	     * Whether this field is a map or not.
	     * @type {boolean}
	     */
	    this.map = false;

	    /**
	     * Message this field belongs to.
	     * @type {Type|null}
	     */
	    this.message = null;

	    /**
	     * OneOf this field belongs to, if any,
	     * @type {OneOf|null}
	     */
	    this.partOf = null;

	    /**
	     * The field type's default value.
	     * @type {*}
	     */
	    this.typeDefault = null;

	    /**
	     * The field's default value on prototypes.
	     * @type {*}
	     */
	    this.defaultValue = null;

	    /**
	     * Whether this field's value should be treated as a long.
	     * @type {boolean}
	     */
	    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

	    /**
	     * Whether this field's value is a buffer.
	     * @type {boolean}
	     */
	    this.bytes = type === "bytes";

	    /**
	     * Resolved type if not a basic type.
	     * @type {Type|Enum|null}
	     */
	    this.resolvedType = null;

	    /**
	     * Sister-field within the extended type if a declaring extension field.
	     * @type {Field|null}
	     */
	    this.extensionField = null;

	    /**
	     * Sister-field within the declaring namespace if an extended field.
	     * @type {Field|null}
	     */
	    this.declaringField = null;

	    /**
	     * Internally remembers whether this field is packed.
	     * @type {boolean|null}
	     * @private
	     */
	    this._packed = null;

	    /**
	     * Comment for this field.
	     * @type {string|null}
	     */
	    this.comment = comment;
	}

	/**
	 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
	 * @name Field#packed
	 * @type {boolean}
	 * @readonly
	 */
	Object.defineProperty(Field.prototype, "packed", {
	    get: function() {
	        // defaults to packed=true if not explicity set to false
	        if (this._packed === null)
	            this._packed = this.getOption("packed") !== false;
	        return this._packed;
	    }
	});

	/**
	 * @override
	 */
	Field.prototype.setOption = function setOption(name, value, ifNotSet) {
	    if (name === "packed") // clear cached before setting
	        this._packed = null;
	    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
	};

	/**
	 * Field descriptor.
	 * @interface IField
	 * @property {string} [rule="optional"] Field rule
	 * @property {string} type Field type
	 * @property {number} id Field id
	 * @property {Object.<string,*>} [options] Field options
	 */

	/**
	 * Extension field descriptor.
	 * @interface IExtensionField
	 * @extends IField
	 * @property {string} extend Extended type
	 */

	/**
	 * Converts this field to a field descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IField} Field descriptor
	 */
	Field.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "rule"    , this.rule !== "optional" && this.rule || undefined,
	        "type"    , this.type,
	        "id"      , this.id,
	        "extend"  , this.extend,
	        "options" , this.options,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Resolves this field's type references.
	 * @returns {Field} `this`
	 * @throws {Error} If any reference cannot be resolved
	 */
	Field.prototype.resolve = function resolve() {

	    if (this.resolved)
	        return this;

	    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
	        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
	        if (this.resolvedType instanceof Type)
	            this.typeDefault = null;
	        else // instanceof Enum
	            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
	    } else if (this.options && this.options.proto3_optional) {
	        // proto3 scalar value marked optional; should default to null
	        this.typeDefault = null;
	    }

	    // use explicitly set default value if present
	    if (this.options && this.options["default"] != null) {
	        this.typeDefault = this.options["default"];
	        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
	            this.typeDefault = this.resolvedType.values[this.typeDefault];
	    }

	    // remove unnecessary options
	    if (this.options) {
	        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
	            delete this.options.packed;
	        if (!Object.keys(this.options).length)
	            this.options = undefined;
	    }

	    // convert to internal data type if necesssary
	    if (this.long) {
	        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

	        /* istanbul ignore else */
	        if (Object.freeze)
	            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

	    } else if (this.bytes && typeof this.typeDefault === "string") {
	        var buf;
	        if (util.base64.test(this.typeDefault))
	            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
	        else
	            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
	        this.typeDefault = buf;
	    }

	    // take special care of maps and repeated fields
	    if (this.map)
	        this.defaultValue = util.emptyObject;
	    else if (this.repeated)
	        this.defaultValue = util.emptyArray;
	    else
	        this.defaultValue = this.typeDefault;

	    // ensure proper value on prototype
	    if (this.parent instanceof Type)
	        this.parent.ctor.prototype[this.name] = this.defaultValue;

	    return ReflectionObject.prototype.resolve.call(this);
	};

	/**
	 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
	 * @typedef FieldDecorator
	 * @type {function}
	 * @param {Object} prototype Target prototype
	 * @param {string} fieldName Field name
	 * @returns {undefined}
	 */

	/**
	 * Field decorator (TypeScript).
	 * @name Field.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
	 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
	 * @param {T} [defaultValue] Default value
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
	 */
	Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

	    // submessage: decorate the submessage and use its name as the type
	    if (typeof fieldType === "function")
	        fieldType = util.decorateType(fieldType).name;

	    // enum reference: create a reflected copy of the enum and keep reuseing it
	    else if (fieldType && typeof fieldType === "object")
	        fieldType = util.decorateEnum(fieldType).name;

	    return function fieldDecorator(prototype, fieldName) {
	        util.decorateType(prototype.constructor)
	            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
	    };
	};

	/**
	 * Field decorator (TypeScript).
	 * @name Field.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {Constructor<T>|string} fieldType Field type
	 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends Message<T>
	 * @variation 2
	 */
	// like Field.d but without a default value

	// Sets up cyclic dependencies (called in index-light)
	Field._configure = function configure(Type_) {
	    Type = Type_;
	};
	return field;
}

var oneof;
var hasRequiredOneof;

function requireOneof () {
	if (hasRequiredOneof) return oneof;
	hasRequiredOneof = 1;
	oneof = OneOf;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

	var Field = requireField(),
	    util  = requireUtil$1();

	/**
	 * Constructs a new oneof instance.
	 * @classdesc Reflected oneof.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Oneof name
	 * @param {string[]|Object.<string,*>} [fieldNames] Field names
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function OneOf(name, fieldNames, options, comment) {
	    if (!Array.isArray(fieldNames)) {
	        options = fieldNames;
	        fieldNames = undefined;
	    }
	    ReflectionObject.call(this, name, options);

	    /* istanbul ignore if */
	    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
	        throw TypeError("fieldNames must be an Array");

	    /**
	     * Field names that belong to this oneof.
	     * @type {string[]}
	     */
	    this.oneof = fieldNames || []; // toJSON, marker

	    /**
	     * Fields that belong to this oneof as an array for iteration.
	     * @type {Field[]}
	     * @readonly
	     */
	    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

	    /**
	     * Comment for this field.
	     * @type {string|null}
	     */
	    this.comment = comment;
	}

	/**
	 * Oneof descriptor.
	 * @interface IOneOf
	 * @property {Array.<string>} oneof Oneof field names
	 * @property {Object.<string,*>} [options] Oneof options
	 */

	/**
	 * Constructs a oneof from a oneof descriptor.
	 * @param {string} name Oneof name
	 * @param {IOneOf} json Oneof descriptor
	 * @returns {OneOf} Created oneof
	 * @throws {TypeError} If arguments are invalid
	 */
	OneOf.fromJSON = function fromJSON(name, json) {
	    return new OneOf(name, json.oneof, json.options, json.comment);
	};

	/**
	 * Converts this oneof to a oneof descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IOneOf} Oneof descriptor
	 */
	OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options" , this.options,
	        "oneof"   , this.oneof,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Adds the fields of the specified oneof to the parent if not already done so.
	 * @param {OneOf} oneof The oneof
	 * @returns {undefined}
	 * @inner
	 * @ignore
	 */
	function addFieldsToParent(oneof) {
	    if (oneof.parent)
	        for (var i = 0; i < oneof.fieldsArray.length; ++i)
	            if (!oneof.fieldsArray[i].parent)
	                oneof.parent.add(oneof.fieldsArray[i]);
	}

	/**
	 * Adds a field to this oneof and removes it from its current parent, if any.
	 * @param {Field} field Field to add
	 * @returns {OneOf} `this`
	 */
	OneOf.prototype.add = function add(field) {

	    /* istanbul ignore if */
	    if (!(field instanceof Field))
	        throw TypeError("field must be a Field");

	    if (field.parent && field.parent !== this.parent)
	        field.parent.remove(field);
	    this.oneof.push(field.name);
	    this.fieldsArray.push(field);
	    field.partOf = this; // field.parent remains null
	    addFieldsToParent(this);
	    return this;
	};

	/**
	 * Removes a field from this oneof and puts it back to the oneof's parent.
	 * @param {Field} field Field to remove
	 * @returns {OneOf} `this`
	 */
	OneOf.prototype.remove = function remove(field) {

	    /* istanbul ignore if */
	    if (!(field instanceof Field))
	        throw TypeError("field must be a Field");

	    var index = this.fieldsArray.indexOf(field);

	    /* istanbul ignore if */
	    if (index < 0)
	        throw Error(field + " is not a member of " + this);

	    this.fieldsArray.splice(index, 1);
	    index = this.oneof.indexOf(field.name);

	    /* istanbul ignore else */
	    if (index > -1) // theoretical
	        this.oneof.splice(index, 1);

	    field.partOf = null;
	    return this;
	};

	/**
	 * @override
	 */
	OneOf.prototype.onAdd = function onAdd(parent) {
	    ReflectionObject.prototype.onAdd.call(this, parent);
	    var self = this;
	    // Collect present fields
	    for (var i = 0; i < this.oneof.length; ++i) {
	        var field = parent.get(this.oneof[i]);
	        if (field && !field.partOf) {
	            field.partOf = self;
	            self.fieldsArray.push(field);
	        }
	    }
	    // Add not yet present fields
	    addFieldsToParent(this);
	};

	/**
	 * @override
	 */
	OneOf.prototype.onRemove = function onRemove(parent) {
	    for (var i = 0, field; i < this.fieldsArray.length; ++i)
	        if ((field = this.fieldsArray[i]).parent)
	            field.parent.remove(field);
	    ReflectionObject.prototype.onRemove.call(this, parent);
	};

	/**
	 * Decorator function as returned by {@link OneOf.d} (TypeScript).
	 * @typedef OneOfDecorator
	 * @type {function}
	 * @param {Object} prototype Target prototype
	 * @param {string} oneofName OneOf name
	 * @returns {undefined}
	 */

	/**
	 * OneOf decorator (TypeScript).
	 * @function
	 * @param {...string} fieldNames Field names
	 * @returns {OneOfDecorator} Decorator function
	 * @template T extends string
	 */
	OneOf.d = function decorateOneOf() {
	    var fieldNames = new Array(arguments.length),
	        index = 0;
	    while (index < arguments.length)
	        fieldNames[index] = arguments[index++];
	    return function oneOfDecorator(prototype, oneofName) {
	        util.decorateType(prototype.constructor)
	            .add(new OneOf(oneofName, fieldNames));
	        Object.defineProperty(prototype, oneofName, {
	            get: util.oneOfGetter(fieldNames),
	            set: util.oneOfSetter(fieldNames)
	        });
	    };
	};
	return oneof;
}

var namespace;
var hasRequiredNamespace;

function requireNamespace () {
	if (hasRequiredNamespace) return namespace;
	hasRequiredNamespace = 1;
	namespace = Namespace;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

	var Field    = requireField(),
	    util     = requireUtil$1(),
	    OneOf    = requireOneof();

	var Type,    // cyclic
	    Service,
	    Enum;

	/**
	 * Constructs a new namespace instance.
	 * @name Namespace
	 * @classdesc Reflected namespace.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} [options] Declared options
	 */

	/**
	 * Constructs a namespace from JSON.
	 * @memberof Namespace
	 * @function
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} json JSON object
	 * @returns {Namespace} Created namespace
	 * @throws {TypeError} If arguments are invalid
	 */
	Namespace.fromJSON = function fromJSON(name, json) {
	    return new Namespace(name, json.options).addJSON(json.nested);
	};

	/**
	 * Converts an array of reflection objects to JSON.
	 * @memberof Namespace
	 * @param {ReflectionObject[]} array Object array
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
	 */
	function arrayToJSON(array, toJSONOptions) {
	    if (!(array && array.length))
	        return undefined;
	    var obj = {};
	    for (var i = 0; i < array.length; ++i)
	        obj[array[i].name] = array[i].toJSON(toJSONOptions);
	    return obj;
	}

	Namespace.arrayToJSON = arrayToJSON;

	/**
	 * Tests if the specified id is reserved.
	 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Namespace.isReservedId = function isReservedId(reserved, id) {
	    if (reserved)
	        for (var i = 0; i < reserved.length; ++i)
	            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
	                return true;
	    return false;
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Namespace.isReservedName = function isReservedName(reserved, name) {
	    if (reserved)
	        for (var i = 0; i < reserved.length; ++i)
	            if (reserved[i] === name)
	                return true;
	    return false;
	};

	/**
	 * Not an actual constructor. Use {@link Namespace} instead.
	 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
	 * @exports NamespaceBase
	 * @extends ReflectionObject
	 * @abstract
	 * @constructor
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} [options] Declared options
	 * @see {@link Namespace}
	 */
	function Namespace(name, options) {
	    ReflectionObject.call(this, name, options);

	    /**
	     * Nested objects by name.
	     * @type {Object.<string,ReflectionObject>|undefined}
	     */
	    this.nested = undefined; // toJSON

	    /**
	     * Cached nested objects as an array.
	     * @type {ReflectionObject[]|null}
	     * @private
	     */
	    this._nestedArray = null;
	}

	function clearCache(namespace) {
	    namespace._nestedArray = null;
	    return namespace;
	}

	/**
	 * Nested objects of this namespace as an array for iteration.
	 * @name NamespaceBase#nestedArray
	 * @type {ReflectionObject[]}
	 * @readonly
	 */
	Object.defineProperty(Namespace.prototype, "nestedArray", {
	    get: function() {
	        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
	    }
	});

	/**
	 * Namespace descriptor.
	 * @interface INamespace
	 * @property {Object.<string,*>} [options] Namespace options
	 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
	 */

	/**
	 * Any extension field descriptor.
	 * @typedef AnyExtensionField
	 * @type {IExtensionField|IExtensionMapField}
	 */

	/**
	 * Any nested object descriptor.
	 * @typedef AnyNestedObject
	 * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}
	 */

	/**
	 * Converts this namespace to a namespace descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {INamespace} Namespace descriptor
	 */
	Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
	    return util.toObject([
	        "options" , this.options,
	        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
	    ]);
	};

	/**
	 * Adds nested objects to this namespace from nested object descriptors.
	 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
	 * @returns {Namespace} `this`
	 */
	Namespace.prototype.addJSON = function addJSON(nestedJson) {
	    var ns = this;
	    /* istanbul ignore else */
	    if (nestedJson) {
	        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
	            nested = nestedJson[names[i]];
	            ns.add( // most to least likely
	                ( nested.fields !== undefined
	                ? Type.fromJSON
	                : nested.values !== undefined
	                ? Enum.fromJSON
	                : nested.methods !== undefined
	                ? Service.fromJSON
	                : nested.id !== undefined
	                ? Field.fromJSON
	                : Namespace.fromJSON )(names[i], nested)
	            );
	        }
	    }
	    return this;
	};

	/**
	 * Gets the nested object of the specified name.
	 * @param {string} name Nested object name
	 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
	 */
	Namespace.prototype.get = function get(name) {
	    return this.nested && this.nested[name]
	        || null;
	};

	/**
	 * Gets the values of the nested {@link Enum|enum} of the specified name.
	 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
	 * @param {string} name Nested enum name
	 * @returns {Object.<string,number>} Enum values
	 * @throws {Error} If there is no such enum
	 */
	Namespace.prototype.getEnum = function getEnum(name) {
	    if (this.nested && this.nested[name] instanceof Enum)
	        return this.nested[name].values;
	    throw Error("no such enum: " + name);
	};

	/**
	 * Adds a nested object to this namespace.
	 * @param {ReflectionObject} object Nested object to add
	 * @returns {Namespace} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a nested object with this name
	 */
	Namespace.prototype.add = function add(object) {

	    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
	        throw TypeError("object must be a valid nested object");

	    if (!this.nested)
	        this.nested = {};
	    else {
	        var prev = this.get(object.name);
	        if (prev) {
	            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
	                // replace plain namespace but keep existing nested elements and options
	                var nested = prev.nestedArray;
	                for (var i = 0; i < nested.length; ++i)
	                    object.add(nested[i]);
	                this.remove(prev);
	                if (!this.nested)
	                    this.nested = {};
	                object.setOptions(prev.options, true);

	            } else
	                throw Error("duplicate name '" + object.name + "' in " + this);
	        }
	    }
	    this.nested[object.name] = object;
	    object.onAdd(this);
	    return clearCache(this);
	};

	/**
	 * Removes a nested object from this namespace.
	 * @param {ReflectionObject} object Nested object to remove
	 * @returns {Namespace} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `object` is not a member of this namespace
	 */
	Namespace.prototype.remove = function remove(object) {

	    if (!(object instanceof ReflectionObject))
	        throw TypeError("object must be a ReflectionObject");
	    if (object.parent !== this)
	        throw Error(object + " is not a member of " + this);

	    delete this.nested[object.name];
	    if (!Object.keys(this.nested).length)
	        this.nested = undefined;

	    object.onRemove(this);
	    return clearCache(this);
	};

	/**
	 * Defines additial namespaces within this one if not yet existing.
	 * @param {string|string[]} path Path to create
	 * @param {*} [json] Nested types to create from JSON
	 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
	 */
	Namespace.prototype.define = function define(path, json) {

	    if (util.isString(path))
	        path = path.split(".");
	    else if (!Array.isArray(path))
	        throw TypeError("illegal path");
	    if (path && path.length && path[0] === "")
	        throw Error("path must be relative");

	    var ptr = this;
	    while (path.length > 0) {
	        var part = path.shift();
	        if (ptr.nested && ptr.nested[part]) {
	            ptr = ptr.nested[part];
	            if (!(ptr instanceof Namespace))
	                throw Error("path conflicts with non-namespace objects");
	        } else
	            ptr.add(ptr = new Namespace(part));
	    }
	    if (json)
	        ptr.addJSON(json);
	    return ptr;
	};

	/**
	 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
	 * @returns {Namespace} `this`
	 */
	Namespace.prototype.resolveAll = function resolveAll() {
	    var nested = this.nestedArray, i = 0;
	    while (i < nested.length)
	        if (nested[i] instanceof Namespace)
	            nested[i++].resolveAll();
	        else
	            nested[i++].resolve();
	    return this.resolve();
	};

	/**
	 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
	 * @param {string|string[]} path Path to look up
	 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
	 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
	 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
	 */
	Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

	    /* istanbul ignore next */
	    if (typeof filterTypes === "boolean") {
	        parentAlreadyChecked = filterTypes;
	        filterTypes = undefined;
	    } else if (filterTypes && !Array.isArray(filterTypes))
	        filterTypes = [ filterTypes ];

	    if (util.isString(path) && path.length) {
	        if (path === ".")
	            return this.root;
	        path = path.split(".");
	    } else if (!path.length)
	        return this;

	    // Start at root if path is absolute
	    if (path[0] === "")
	        return this.root.lookup(path.slice(1), filterTypes);

	    // Test if the first part matches any nested object, and if so, traverse if path contains more
	    var found = this.get(path[0]);
	    if (found) {
	        if (path.length === 1) {
	            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
	                return found;
	        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
	            return found;

	    // Otherwise try each nested namespace
	    } else
	        for (var i = 0; i < this.nestedArray.length; ++i)
	            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
	                return found;

	    // If there hasn't been a match, try again at the parent
	    if (this.parent === null || parentAlreadyChecked)
	        return null;
	    return this.parent.lookup(path, filterTypes);
	};

	/**
	 * Looks up the reflection object at the specified path, relative to this namespace.
	 * @name NamespaceBase#lookup
	 * @function
	 * @param {string|string[]} path Path to look up
	 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
	 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
	 * @variation 2
	 */
	// lookup(path: string, [parentAlreadyChecked: boolean])

	/**
	 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Type} Looked up type
	 * @throws {Error} If `path` does not point to a type
	 */
	Namespace.prototype.lookupType = function lookupType(path) {
	    var found = this.lookup(path, [ Type ]);
	    if (!found)
	        throw Error("no such type: " + path);
	    return found;
	};

	/**
	 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Enum} Looked up enum
	 * @throws {Error} If `path` does not point to an enum
	 */
	Namespace.prototype.lookupEnum = function lookupEnum(path) {
	    var found = this.lookup(path, [ Enum ]);
	    if (!found)
	        throw Error("no such Enum '" + path + "' in " + this);
	    return found;
	};

	/**
	 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Type} Looked up type or enum
	 * @throws {Error} If `path` does not point to a type or enum
	 */
	Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
	    var found = this.lookup(path, [ Type, Enum ]);
	    if (!found)
	        throw Error("no such Type or Enum '" + path + "' in " + this);
	    return found;
	};

	/**
	 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Service} Looked up service
	 * @throws {Error} If `path` does not point to a service
	 */
	Namespace.prototype.lookupService = function lookupService(path) {
	    var found = this.lookup(path, [ Service ]);
	    if (!found)
	        throw Error("no such Service '" + path + "' in " + this);
	    return found;
	};

	// Sets up cyclic dependencies (called in index-light)
	Namespace._configure = function(Type_, Service_, Enum_) {
	    Type    = Type_;
	    Service = Service_;
	    Enum    = Enum_;
	};
	return namespace;
}

var mapfield;
var hasRequiredMapfield;

function requireMapfield () {
	if (hasRequiredMapfield) return mapfield;
	hasRequiredMapfield = 1;
	mapfield = MapField;

	// extends Field
	var Field = requireField();
	((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

	var types   = requireTypes(),
	    util    = requireUtil$1();

	/**
	 * Constructs a new map field instance.
	 * @classdesc Reflected map field.
	 * @extends FieldBase
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} keyType Key type
	 * @param {string} type Value type
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function MapField(name, id, keyType, type, options, comment) {
	    Field.call(this, name, id, type, undefined, undefined, options, comment);

	    /* istanbul ignore if */
	    if (!util.isString(keyType))
	        throw TypeError("keyType must be a string");

	    /**
	     * Key type.
	     * @type {string}
	     */
	    this.keyType = keyType; // toJSON, marker

	    /**
	     * Resolved key type if not a basic type.
	     * @type {ReflectionObject|null}
	     */
	    this.resolvedKeyType = null;

	    // Overrides Field#map
	    this.map = true;
	}

	/**
	 * Map field descriptor.
	 * @interface IMapField
	 * @extends {IField}
	 * @property {string} keyType Key type
	 */

	/**
	 * Extension map field descriptor.
	 * @interface IExtensionMapField
	 * @extends IMapField
	 * @property {string} extend Extended type
	 */

	/**
	 * Constructs a map field from a map field descriptor.
	 * @param {string} name Field name
	 * @param {IMapField} json Map field descriptor
	 * @returns {MapField} Created map field
	 * @throws {TypeError} If arguments are invalid
	 */
	MapField.fromJSON = function fromJSON(name, json) {
	    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
	};

	/**
	 * Converts this map field to a map field descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IMapField} Map field descriptor
	 */
	MapField.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "keyType" , this.keyType,
	        "type"    , this.type,
	        "id"      , this.id,
	        "extend"  , this.extend,
	        "options" , this.options,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * @override
	 */
	MapField.prototype.resolve = function resolve() {
	    if (this.resolved)
	        return this;

	    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
	    if (types.mapKey[this.keyType] === undefined)
	        throw Error("invalid key type: " + this.keyType);

	    return Field.prototype.resolve.call(this);
	};

	/**
	 * Map field decorator (TypeScript).
	 * @name MapField.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
	 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
	 */
	MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

	    // submessage value: decorate the submessage and use its name as the type
	    if (typeof fieldValueType === "function")
	        fieldValueType = util.decorateType(fieldValueType).name;

	    // enum reference value: create a reflected copy of the enum and keep reuseing it
	    else if (fieldValueType && typeof fieldValueType === "object")
	        fieldValueType = util.decorateEnum(fieldValueType).name;

	    return function mapFieldDecorator(prototype, fieldName) {
	        util.decorateType(prototype.constructor)
	            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
	    };
	};
	return mapfield;
}

var method;
var hasRequiredMethod;

function requireMethod () {
	if (hasRequiredMethod) return method;
	hasRequiredMethod = 1;
	method = Method;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

	var util = requireUtil$1();

	/**
	 * Constructs a new service method instance.
	 * @classdesc Reflected service method.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Method name
	 * @param {string|undefined} type Method type, usually `"rpc"`
	 * @param {string} requestType Request message type
	 * @param {string} responseType Response message type
	 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
	 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] The comment for this method
	 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
	 */
	function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

	    /* istanbul ignore next */
	    if (util.isObject(requestStream)) {
	        options = requestStream;
	        requestStream = responseStream = undefined;
	    } else if (util.isObject(responseStream)) {
	        options = responseStream;
	        responseStream = undefined;
	    }

	    /* istanbul ignore if */
	    if (!(type === undefined || util.isString(type)))
	        throw TypeError("type must be a string");

	    /* istanbul ignore if */
	    if (!util.isString(requestType))
	        throw TypeError("requestType must be a string");

	    /* istanbul ignore if */
	    if (!util.isString(responseType))
	        throw TypeError("responseType must be a string");

	    ReflectionObject.call(this, name, options);

	    /**
	     * Method type.
	     * @type {string}
	     */
	    this.type = type || "rpc"; // toJSON

	    /**
	     * Request type.
	     * @type {string}
	     */
	    this.requestType = requestType; // toJSON, marker

	    /**
	     * Whether requests are streamed or not.
	     * @type {boolean|undefined}
	     */
	    this.requestStream = requestStream ? true : undefined; // toJSON

	    /**
	     * Response type.
	     * @type {string}
	     */
	    this.responseType = responseType; // toJSON

	    /**
	     * Whether responses are streamed or not.
	     * @type {boolean|undefined}
	     */
	    this.responseStream = responseStream ? true : undefined; // toJSON

	    /**
	     * Resolved request type.
	     * @type {Type|null}
	     */
	    this.resolvedRequestType = null;

	    /**
	     * Resolved response type.
	     * @type {Type|null}
	     */
	    this.resolvedResponseType = null;

	    /**
	     * Comment for this method
	     * @type {string|null}
	     */
	    this.comment = comment;

	    /**
	     * Options properly parsed into an object
	     */
	    this.parsedOptions = parsedOptions;
	}

	/**
	 * Method descriptor.
	 * @interface IMethod
	 * @property {string} [type="rpc"] Method type
	 * @property {string} requestType Request type
	 * @property {string} responseType Response type
	 * @property {boolean} [requestStream=false] Whether requests are streamed
	 * @property {boolean} [responseStream=false] Whether responses are streamed
	 * @property {Object.<string,*>} [options] Method options
	 * @property {string} comment Method comments
	 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
	 */

	/**
	 * Constructs a method from a method descriptor.
	 * @param {string} name Method name
	 * @param {IMethod} json Method descriptor
	 * @returns {Method} Created method
	 * @throws {TypeError} If arguments are invalid
	 */
	Method.fromJSON = function fromJSON(name, json) {
	    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
	};

	/**
	 * Converts this method to a method descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IMethod} Method descriptor
	 */
	Method.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
	        "requestType"    , this.requestType,
	        "requestStream"  , this.requestStream,
	        "responseType"   , this.responseType,
	        "responseStream" , this.responseStream,
	        "options"        , this.options,
	        "comment"        , keepComments ? this.comment : undefined,
	        "parsedOptions"  , this.parsedOptions,
	    ]);
	};

	/**
	 * @override
	 */
	Method.prototype.resolve = function resolve() {

	    /* istanbul ignore if */
	    if (this.resolved)
	        return this;

	    this.resolvedRequestType = this.parent.lookupType(this.requestType);
	    this.resolvedResponseType = this.parent.lookupType(this.responseType);

	    return ReflectionObject.prototype.resolve.call(this);
	};
	return method;
}

var service;
var hasRequiredService;

function requireService () {
	if (hasRequiredService) return service;
	hasRequiredService = 1;
	service = Service;

	// extends Namespace
	var Namespace = requireNamespace();
	((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

	var Method = requireMethod(),
	    util   = requireUtil$1(),
	    rpc    = requireRpc();

	/**
	 * Constructs a new service instance.
	 * @classdesc Reflected service.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Service name
	 * @param {Object.<string,*>} [options] Service options
	 * @throws {TypeError} If arguments are invalid
	 */
	function Service(name, options) {
	    Namespace.call(this, name, options);

	    /**
	     * Service methods.
	     * @type {Object.<string,Method>}
	     */
	    this.methods = {}; // toJSON, marker

	    /**
	     * Cached methods as an array.
	     * @type {Method[]|null}
	     * @private
	     */
	    this._methodsArray = null;
	}

	/**
	 * Service descriptor.
	 * @interface IService
	 * @extends INamespace
	 * @property {Object.<string,IMethod>} methods Method descriptors
	 */

	/**
	 * Constructs a service from a service descriptor.
	 * @param {string} name Service name
	 * @param {IService} json Service descriptor
	 * @returns {Service} Created service
	 * @throws {TypeError} If arguments are invalid
	 */
	Service.fromJSON = function fromJSON(name, json) {
	    var service = new Service(name, json.options);
	    /* istanbul ignore else */
	    if (json.methods)
	        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
	            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
	    if (json.nested)
	        service.addJSON(json.nested);
	    service.comment = json.comment;
	    return service;
	};

	/**
	 * Converts this service to a service descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IService} Service descriptor
	 */
	Service.prototype.toJSON = function toJSON(toJSONOptions) {
	    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options" , inherited && inherited.options || undefined,
	        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
	        "nested"  , inherited && inherited.nested || undefined,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Methods of this service as an array for iteration.
	 * @name Service#methodsArray
	 * @type {Method[]}
	 * @readonly
	 */
	Object.defineProperty(Service.prototype, "methodsArray", {
	    get: function() {
	        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
	    }
	});

	function clearCache(service) {
	    service._methodsArray = null;
	    return service;
	}

	/**
	 * @override
	 */
	Service.prototype.get = function get(name) {
	    return this.methods[name]
	        || Namespace.prototype.get.call(this, name);
	};

	/**
	 * @override
	 */
	Service.prototype.resolveAll = function resolveAll() {
	    var methods = this.methodsArray;
	    for (var i = 0; i < methods.length; ++i)
	        methods[i].resolve();
	    return Namespace.prototype.resolve.call(this);
	};

	/**
	 * @override
	 */
	Service.prototype.add = function add(object) {

	    /* istanbul ignore if */
	    if (this.get(object.name))
	        throw Error("duplicate name '" + object.name + "' in " + this);

	    if (object instanceof Method) {
	        this.methods[object.name] = object;
	        object.parent = this;
	        return clearCache(this);
	    }
	    return Namespace.prototype.add.call(this, object);
	};

	/**
	 * @override
	 */
	Service.prototype.remove = function remove(object) {
	    if (object instanceof Method) {

	        /* istanbul ignore if */
	        if (this.methods[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.methods[object.name];
	        object.parent = null;
	        return clearCache(this);
	    }
	    return Namespace.prototype.remove.call(this, object);
	};

	/**
	 * Creates a runtime service using the specified rpc implementation.
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
	 */
	Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
	    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
	    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
	        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
	        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
	            m: method,
	            q: method.resolvedRequestType.ctor,
	            s: method.resolvedResponseType.ctor
	        });
	    }
	    return rpcService;
	};
	return service;
}

var message;
var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return message;
	hasRequiredMessage = 1;
	message = Message;

	var util = requireMinimal();

	/**
	 * Constructs a new message instance.
	 * @classdesc Abstract runtime message.
	 * @constructor
	 * @param {Properties<T>} [properties] Properties to set
	 * @template T extends object = object
	 */
	function Message(properties) {
	    // not used internally
	    if (properties)
	        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	            this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Reference to the reflected type.
	 * @name Message.$type
	 * @type {Type}
	 * @readonly
	 */

	/**
	 * Reference to the reflected type.
	 * @name Message#$type
	 * @type {Type}
	 * @readonly
	 */

	/*eslint-disable valid-jsdoc*/

	/**
	 * Creates a new message of this type using the specified properties.
	 * @param {Object.<string,*>} [properties] Properties to set
	 * @returns {Message<T>} Message instance
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.create = function create(properties) {
	    return this.$type.create(properties);
	};

	/**
	 * Encodes a message of this type.
	 * @param {T|Object.<string,*>} message Message to encode
	 * @param {Writer} [writer] Writer to use
	 * @returns {Writer} Writer
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.encode = function encode(message, writer) {
	    return this.$type.encode(message, writer);
	};

	/**
	 * Encodes a message of this type preceeded by its length as a varint.
	 * @param {T|Object.<string,*>} message Message to encode
	 * @param {Writer} [writer] Writer to use
	 * @returns {Writer} Writer
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.encodeDelimited = function encodeDelimited(message, writer) {
	    return this.$type.encodeDelimited(message, writer);
	};

	/**
	 * Decodes a message of this type.
	 * @name Message.decode
	 * @function
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode
	 * @returns {T} Decoded message
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.decode = function decode(reader) {
	    return this.$type.decode(reader);
	};

	/**
	 * Decodes a message of this type preceeded by its length as a varint.
	 * @name Message.decodeDelimited
	 * @function
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode
	 * @returns {T} Decoded message
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.decodeDelimited = function decodeDelimited(reader) {
	    return this.$type.decodeDelimited(reader);
	};

	/**
	 * Verifies a message of this type.
	 * @name Message.verify
	 * @function
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Message.verify = function verify(message) {
	    return this.$type.verify(message);
	};

	/**
	 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
	 * @param {Object.<string,*>} object Plain object
	 * @returns {T} Message instance
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.fromObject = function fromObject(object) {
	    return this.$type.fromObject(object);
	};

	/**
	 * Creates a plain object from a message of this type. Also converts values to other types if specified.
	 * @param {T} message Message instance
	 * @param {IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.toObject = function toObject(message, options) {
	    return this.$type.toObject(message, options);
	};

	/**
	 * Converts this message to JSON.
	 * @returns {Object.<string,*>} JSON object
	 */
	Message.prototype.toJSON = function toJSON() {
	    return this.$type.toObject(this, util.toJSONOptions);
	};

	/*eslint-enable valid-jsdoc*/
	return message;
}

var decoder_1;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder_1;
	hasRequiredDecoder = 1;
	decoder_1 = decoder;

	var Enum    = require_enum(),
	    types   = requireTypes(),
	    util    = requireUtil$1();

	function missing(field) {
	    return "missing required '" + field.name + "'";
	}

	/**
	 * Generates a decoder specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function decoder(mtype) {
	    /* eslint-disable no-unexpected-multiline */
	    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
	    ("if(!(r instanceof Reader))")
	        ("r=Reader.create(r)")
	    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
	    ("while(r.pos<c){")
	        ("var t=r.uint32()");
	    if (mtype.group) gen
	        ("if((t&7)===4)")
	            ("break");
	    gen
	        ("switch(t>>>3){");

	    var i = 0;
	    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
	        var field = mtype._fieldsArray[i].resolve(),
	            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
	            ref   = "m" + util.safeProp(field.name); gen
	            ("case %i: {", field.id);

	        // Map fields
	        if (field.map) { gen
	                ("if(%s===util.emptyObject)", ref)
	                    ("%s={}", ref)
	                ("var c2 = r.uint32()+r.pos");

	            if (types.defaults[field.keyType] !== undefined) gen
	                ("k=%j", types.defaults[field.keyType]);
	            else gen
	                ("k=null");

	            if (types.defaults[type] !== undefined) gen
	                ("value=%j", types.defaults[type]);
	            else gen
	                ("value=null");

	            gen
	                ("while(r.pos<c2){")
	                    ("var tag2=r.uint32()")
	                    ("switch(tag2>>>3){")
	                        ("case 1: k=r.%s(); break", field.keyType)
	                        ("case 2:");

	            if (types.basic[type] === undefined) gen
	                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
	            else gen
	                            ("value=r.%s()", type);

	            gen
	                            ("break")
	                        ("default:")
	                            ("r.skipType(tag2&7)")
	                            ("break")
	                    ("}")
	                ("}");

	            if (types.long[field.keyType] !== undefined) gen
	                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
	            else gen
	                ("%s[k]=value", ref);

	        // Repeated fields
	        } else if (field.repeated) { gen

	                ("if(!(%s&&%s.length))", ref, ref)
	                    ("%s=[]", ref);

	            // Packable (always check for forward and backward compatiblity)
	            if (types.packed[type] !== undefined) gen
	                ("if((t&7)===2){")
	                    ("var c2=r.uint32()+r.pos")
	                    ("while(r.pos<c2)")
	                        ("%s.push(r.%s())", ref, type)
	                ("}else");

	            // Non-packed
	            if (types.basic[type] === undefined) gen(field.resolvedType.group
	                    ? "%s.push(types[%i].decode(r))"
	                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
	            else gen
	                    ("%s.push(r.%s())", ref, type);

	        // Non-repeated
	        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
	                ? "%s=types[%i].decode(r)"
	                : "%s=types[%i].decode(r,r.uint32())", ref, i);
	        else gen
	                ("%s=r.%s()", ref, type);
	        gen
	                ("break")
	            ("}");
	        // Unknown fields
	    } gen
	            ("default:")
	                ("r.skipType(t&7)")
	                ("break")

	        ("}")
	    ("}");

	    // Field presence
	    for (i = 0; i < mtype._fieldsArray.length; ++i) {
	        var rfield = mtype._fieldsArray[i];
	        if (rfield.required) gen
	    ("if(!m.hasOwnProperty(%j))", rfield.name)
	        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
	    }

	    return gen
	    ("return m");
	    /* eslint-enable no-unexpected-multiline */
	}
	return decoder_1;
}

var verifier_1;
var hasRequiredVerifier;

function requireVerifier () {
	if (hasRequiredVerifier) return verifier_1;
	hasRequiredVerifier = 1;
	verifier_1 = verifier;

	var Enum      = require_enum(),
	    util      = requireUtil$1();

	function invalid(field, expected) {
	    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
	}

	/**
	 * Generates a partial value verifier.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {number} fieldIndex Field index
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genVerifyValue(gen, field, fieldIndex, ref) {
	    /* eslint-disable no-unexpected-multiline */
	    if (field.resolvedType) {
	        if (field.resolvedType instanceof Enum) { gen
	            ("switch(%s){", ref)
	                ("default:")
	                    ("return%j", invalid(field, "enum value"));
	            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
	                ("case %i:", field.resolvedType.values[keys[j]]);
	            gen
	                    ("break")
	            ("}");
	        } else {
	            gen
	            ("{")
	                ("var e=types[%i].verify(%s);", fieldIndex, ref)
	                ("if(e)")
	                    ("return%j+e", field.name + ".")
	            ("}");
	        }
	    } else {
	        switch (field.type) {
	            case "int32":
	            case "uint32":
	            case "sint32":
	            case "fixed32":
	            case "sfixed32": gen
	                ("if(!util.isInteger(%s))", ref)
	                    ("return%j", invalid(field, "integer"));
	                break;
	            case "int64":
	            case "uint64":
	            case "sint64":
	            case "fixed64":
	            case "sfixed64": gen
	                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
	                    ("return%j", invalid(field, "integer|Long"));
	                break;
	            case "float":
	            case "double": gen
	                ("if(typeof %s!==\"number\")", ref)
	                    ("return%j", invalid(field, "number"));
	                break;
	            case "bool": gen
	                ("if(typeof %s!==\"boolean\")", ref)
	                    ("return%j", invalid(field, "boolean"));
	                break;
	            case "string": gen
	                ("if(!util.isString(%s))", ref)
	                    ("return%j", invalid(field, "string"));
	                break;
	            case "bytes": gen
	                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
	                    ("return%j", invalid(field, "buffer"));
	                break;
	        }
	    }
	    return gen;
	    /* eslint-enable no-unexpected-multiline */
	}

	/**
	 * Generates a partial key verifier.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genVerifyKey(gen, field, ref) {
	    /* eslint-disable no-unexpected-multiline */
	    switch (field.keyType) {
	        case "int32":
	        case "uint32":
	        case "sint32":
	        case "fixed32":
	        case "sfixed32": gen
	            ("if(!util.key32Re.test(%s))", ref)
	                ("return%j", invalid(field, "integer key"));
	            break;
	        case "int64":
	        case "uint64":
	        case "sint64":
	        case "fixed64":
	        case "sfixed64": gen
	            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
	                ("return%j", invalid(field, "integer|Long key"));
	            break;
	        case "bool": gen
	            ("if(!util.key2Re.test(%s))", ref)
	                ("return%j", invalid(field, "boolean key"));
	            break;
	    }
	    return gen;
	    /* eslint-enable no-unexpected-multiline */
	}

	/**
	 * Generates a verifier specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function verifier(mtype) {
	    /* eslint-disable no-unexpected-multiline */

	    var gen = util.codegen(["m"], mtype.name + "$verify")
	    ("if(typeof m!==\"object\"||m===null)")
	        ("return%j", "object expected");
	    var oneofs = mtype.oneofsArray,
	        seenFirstField = {};
	    if (oneofs.length) gen
	    ("var p={}");

	    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
	        var field = mtype._fieldsArray[i].resolve(),
	            ref   = "m" + util.safeProp(field.name);

	        if (field.optional) gen
	        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

	        // map fields
	        if (field.map) { gen
	            ("if(!util.isObject(%s))", ref)
	                ("return%j", invalid(field, "object"))
	            ("var k=Object.keys(%s)", ref)
	            ("for(var i=0;i<k.length;++i){");
	                genVerifyKey(gen, field, "k[i]");
	                genVerifyValue(gen, field, i, ref + "[k[i]]")
	            ("}");

	        // repeated fields
	        } else if (field.repeated) { gen
	            ("if(!Array.isArray(%s))", ref)
	                ("return%j", invalid(field, "array"))
	            ("for(var i=0;i<%s.length;++i){", ref);
	                genVerifyValue(gen, field, i, ref + "[i]")
	            ("}");

	        // required or present fields
	        } else {
	            if (field.partOf) {
	                var oneofProp = util.safeProp(field.partOf.name);
	                if (seenFirstField[field.partOf.name] === 1) gen
	            ("if(p%s===1)", oneofProp)
	                ("return%j", field.partOf.name + ": multiple values");
	                seenFirstField[field.partOf.name] = 1;
	                gen
	            ("p%s=1", oneofProp);
	            }
	            genVerifyValue(gen, field, i, ref);
	        }
	        if (field.optional) gen
	        ("}");
	    }
	    return gen
	    ("return null");
	    /* eslint-enable no-unexpected-multiline */
	}
	return verifier_1;
}

var converter = {};

var hasRequiredConverter;

function requireConverter () {
	if (hasRequiredConverter) return converter;
	hasRequiredConverter = 1;
	(function (exports) {
		/**
		 * Runtime message from/to plain object converters.
		 * @namespace
		 */
		var converter = exports;

		var Enum = require_enum(),
		    util = requireUtil$1();

		/**
		 * Generates a partial value fromObject conveter.
		 * @param {Codegen} gen Codegen instance
		 * @param {Field} field Reflected field
		 * @param {number} fieldIndex Field index
		 * @param {string} prop Property reference
		 * @returns {Codegen} Codegen instance
		 * @ignore
		 */
		function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
		    var defaultAlreadyEmitted = false;
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    if (field.resolvedType) {
		        if (field.resolvedType instanceof Enum) { gen
		            ("switch(d%s){", prop);
		            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
		                // enum unknown values passthrough
		                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen
		                    ("default:")
		                        ("if(typeof(d%s)===\"number\"){m%s=d%s;break}", prop, prop, prop);
		                    if (!field.repeated) gen // fallback to default value only for
		                                             // arrays, to avoid leaving holes.
		                        ("break");           // for non-repeated fields, just ignore
		                    defaultAlreadyEmitted = true;
		                }
		                gen
		                ("case%j:", keys[i])
		                ("case %i:", values[keys[i]])
		                    ("m%s=%j", prop, values[keys[i]])
		                    ("break");
		            } gen
		            ("}");
		        } else gen
		            ("if(typeof d%s!==\"object\")", prop)
		                ("throw TypeError(%j)", field.fullName + ": object expected")
		            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
		    } else {
		        var isUnsigned = false;
		        switch (field.type) {
		            case "double":
		            case "float": gen
		                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
		                break;
		            case "uint32":
		            case "fixed32": gen
		                ("m%s=d%s>>>0", prop, prop);
		                break;
		            case "int32":
		            case "sint32":
		            case "sfixed32": gen
		                ("m%s=d%s|0", prop, prop);
		                break;
		            case "uint64":
		                isUnsigned = true;
		                // eslint-disable-next-line no-fallthrough
		            case "int64":
		            case "sint64":
		            case "fixed64":
		            case "sfixed64": gen
		                ("if(util.Long)")
		                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
		                ("else if(typeof d%s===\"string\")", prop)
		                    ("m%s=parseInt(d%s,10)", prop, prop)
		                ("else if(typeof d%s===\"number\")", prop)
		                    ("m%s=d%s", prop, prop)
		                ("else if(typeof d%s===\"object\")", prop)
		                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
		                break;
		            case "bytes": gen
		                ("if(typeof d%s===\"string\")", prop)
		                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
		                ("else if(d%s.length >= 0)", prop)
		                    ("m%s=d%s", prop, prop);
		                break;
		            case "string": gen
		                ("m%s=String(d%s)", prop, prop);
		                break;
		            case "bool": gen
		                ("m%s=Boolean(d%s)", prop, prop);
		                break;
		            /* default: gen
		                ("m%s=d%s", prop, prop);
		                break; */
		        }
		    }
		    return gen;
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}

		/**
		 * Generates a plain object to runtime message converter specific to the specified message type.
		 * @param {Type} mtype Message type
		 * @returns {Codegen} Codegen instance
		 */
		converter.fromObject = function fromObject(mtype) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    var fields = mtype.fieldsArray;
		    var gen = util.codegen(["d"], mtype.name + "$fromObject")
		    ("if(d instanceof this.ctor)")
		        ("return d");
		    if (!fields.length) return gen
		    ("return new this.ctor");
		    gen
		    ("var m=new this.ctor");
		    for (var i = 0; i < fields.length; ++i) {
		        var field  = fields[i].resolve(),
		            prop   = util.safeProp(field.name);

		        // Map fields
		        if (field.map) { gen
		    ("if(d%s){", prop)
		        ("if(typeof d%s!==\"object\")", prop)
		            ("throw TypeError(%j)", field.fullName + ": object expected")
		        ("m%s={}", prop)
		        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
		            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
		        ("}")
		    ("}");

		        // Repeated fields
		        } else if (field.repeated) { gen
		    ("if(d%s){", prop)
		        ("if(!Array.isArray(d%s))", prop)
		            ("throw TypeError(%j)", field.fullName + ": array expected")
		        ("m%s=[]", prop)
		        ("for(var i=0;i<d%s.length;++i){", prop);
		            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
		        ("}")
		    ("}");

		        // Non-repeated fields
		        } else {
		            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
		    ("if(d%s!=null){", prop); // !== undefined && !== null
		        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
		            if (!(field.resolvedType instanceof Enum)) gen
		    ("}");
		        }
		    } return gen
		    ("return m");
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		};

		/**
		 * Generates a partial value toObject converter.
		 * @param {Codegen} gen Codegen instance
		 * @param {Field} field Reflected field
		 * @param {number} fieldIndex Field index
		 * @param {string} prop Property reference
		 * @returns {Codegen} Codegen instance
		 * @ignore
		 */
		function genValuePartial_toObject(gen, field, fieldIndex, prop) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    if (field.resolvedType) {
		        if (field.resolvedType instanceof Enum) gen
		            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
		        else gen
		            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
		    } else {
		        var isUnsigned = false;
		        switch (field.type) {
		            case "double":
		            case "float": gen
		            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
		                break;
		            case "uint64":
		                isUnsigned = true;
		                // eslint-disable-next-line no-fallthrough
		            case "int64":
		            case "sint64":
		            case "fixed64":
		            case "sfixed64": gen
		            ("if(typeof m%s===\"number\")", prop)
		                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
		            ("else") // Long-like
		                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
		                break;
		            case "bytes": gen
		            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
		                break;
		            default: gen
		            ("d%s=m%s", prop, prop);
		                break;
		        }
		    }
		    return gen;
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}

		/**
		 * Generates a runtime message to plain object converter specific to the specified message type.
		 * @param {Type} mtype Message type
		 * @returns {Codegen} Codegen instance
		 */
		converter.toObject = function toObject(mtype) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
		    if (!fields.length)
		        return util.codegen()("return {}");
		    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
		    ("if(!o)")
		        ("o={}")
		    ("var d={}");

		    var repeatedFields = [],
		        mapFields = [],
		        normalFields = [],
		        i = 0;
		    for (; i < fields.length; ++i)
		        if (!fields[i].partOf)
		            ( fields[i].resolve().repeated ? repeatedFields
		            : fields[i].map ? mapFields
		            : normalFields).push(fields[i]);

		    if (repeatedFields.length) { gen
		    ("if(o.arrays||o.defaults){");
		        for (i = 0; i < repeatedFields.length; ++i) gen
		        ("d%s=[]", util.safeProp(repeatedFields[i].name));
		        gen
		    ("}");
		    }

		    if (mapFields.length) { gen
		    ("if(o.objects||o.defaults){");
		        for (i = 0; i < mapFields.length; ++i) gen
		        ("d%s={}", util.safeProp(mapFields[i].name));
		        gen
		    ("}");
		    }

		    if (normalFields.length) { gen
		    ("if(o.defaults){");
		        for (i = 0; i < normalFields.length; ++i) {
		            var field = normalFields[i],
		                prop  = util.safeProp(field.name);
		            if (field.resolvedType instanceof Enum) gen
		        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
		            else if (field.long) gen
		        ("if(util.Long){")
		            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
		            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
		        ("}else")
		            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
		            else if (field.bytes) {
		                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
		                gen
		        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
		        ("else{")
		            ("d%s=%s", prop, arrayDefault)
		            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
		        ("}");
		            } else gen
		        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
		        } gen
		    ("}");
		    }
		    var hasKs2 = false;
		    for (i = 0; i < fields.length; ++i) {
		        var field = fields[i],
		            index = mtype._fieldsArray.indexOf(field),
		            prop  = util.safeProp(field.name);
		        if (field.map) {
		            if (!hasKs2) { hasKs2 = true; gen
		    ("var ks2");
		            } gen
		    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
		        ("d%s={}", prop)
		        ("for(var j=0;j<ks2.length;++j){");
		            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
		        ("}");
		        } else if (field.repeated) { gen
		    ("if(m%s&&m%s.length){", prop, prop)
		        ("d%s=[]", prop)
		        ("for(var j=0;j<m%s.length;++j){", prop);
		            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
		        ("}");
		        } else { gen
		    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
		        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
		        if (field.partOf) gen
		        ("if(o.oneofs)")
		            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
		        }
		        gen
		    ("}");
		    }
		    return gen
		    ("return d");
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}; 
	} (converter));
	return converter;
}

var wrappers = {};

var hasRequiredWrappers;

function requireWrappers () {
	if (hasRequiredWrappers) return wrappers;
	hasRequiredWrappers = 1;
	(function (exports) {

		/**
		 * Wrappers for common types.
		 * @type {Object.<string,IWrapper>}
		 * @const
		 */
		var wrappers = exports;

		var Message = requireMessage();

		/**
		 * From object converter part of an {@link IWrapper}.
		 * @typedef WrapperFromObjectConverter
		 * @type {function}
		 * @param {Object.<string,*>} object Plain object
		 * @returns {Message<{}>} Message instance
		 * @this Type
		 */

		/**
		 * To object converter part of an {@link IWrapper}.
		 * @typedef WrapperToObjectConverter
		 * @type {function}
		 * @param {Message<{}>} message Message instance
		 * @param {IConversionOptions} [options] Conversion options
		 * @returns {Object.<string,*>} Plain object
		 * @this Type
		 */

		/**
		 * Common type wrapper part of {@link wrappers}.
		 * @interface IWrapper
		 * @property {WrapperFromObjectConverter} [fromObject] From object converter
		 * @property {WrapperToObjectConverter} [toObject] To object converter
		 */

		// Custom wrapper for Any
		wrappers[".google.protobuf.Any"] = {

		    fromObject: function(object) {

		        // unwrap value type if mapped
		        if (object && object["@type"]) {
		             // Only use fully qualified type name after the last '/'
		            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
		            var type = this.lookup(name);
		            /* istanbul ignore else */
		            if (type) {
		                // type_url does not accept leading "."
		                var type_url = object["@type"].charAt(0) === "." ?
		                    object["@type"].slice(1) : object["@type"];
		                // type_url prefix is optional, but path seperator is required
		                if (type_url.indexOf("/") === -1) {
		                    type_url = "/" + type_url;
		                }
		                return this.create({
		                    type_url: type_url,
		                    value: type.encode(type.fromObject(object)).finish()
		                });
		            }
		        }

		        return this.fromObject(object);
		    },

		    toObject: function(message, options) {

		        // Default prefix
		        var googleApi = "type.googleapis.com/";
		        var prefix = "";
		        var name = "";

		        // decode value if requested and unmapped
		        if (options && options.json && message.type_url && message.value) {
		            // Only use fully qualified type name after the last '/'
		            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
		            // Separate the prefix used
		            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
		            var type = this.lookup(name);
		            /* istanbul ignore else */
		            if (type)
		                message = type.decode(message.value);
		        }

		        // wrap value if unmapped
		        if (!(message instanceof this.ctor) && message instanceof Message) {
		            var object = message.$type.toObject(message, options);
		            var messageName = message.$type.fullName[0] === "." ?
		                message.$type.fullName.slice(1) : message.$type.fullName;
		            // Default to type.googleapis.com prefix if no prefix is used
		            if (prefix === "") {
		                prefix = googleApi;
		            }
		            name = prefix + messageName;
		            object["@type"] = name;
		            return object;
		        }

		        return this.toObject(message, options);
		    }
		}; 
	} (wrappers));
	return wrappers;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;
	type = Type;

	// extends Namespace
	var Namespace = requireNamespace();
	((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

	var Enum      = require_enum(),
	    OneOf     = requireOneof(),
	    Field     = requireField(),
	    MapField  = requireMapfield(),
	    Service   = requireService(),
	    Message   = requireMessage(),
	    Reader    = requireReader(),
	    Writer    = requireWriter(),
	    util      = requireUtil$1(),
	    encoder   = requireEncoder(),
	    decoder   = requireDecoder(),
	    verifier  = requireVerifier(),
	    converter = requireConverter(),
	    wrappers  = requireWrappers();

	/**
	 * Constructs a new reflected message type instance.
	 * @classdesc Reflected message type.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Message name
	 * @param {Object.<string,*>} [options] Declared options
	 */
	function Type(name, options) {
	    Namespace.call(this, name, options);

	    /**
	     * Message fields.
	     * @type {Object.<string,Field>}
	     */
	    this.fields = {};  // toJSON, marker

	    /**
	     * Oneofs declared within this namespace, if any.
	     * @type {Object.<string,OneOf>}
	     */
	    this.oneofs = undefined; // toJSON

	    /**
	     * Extension ranges, if any.
	     * @type {number[][]}
	     */
	    this.extensions = undefined; // toJSON

	    /**
	     * Reserved ranges, if any.
	     * @type {Array.<number[]|string>}
	     */
	    this.reserved = undefined; // toJSON

	    /*?
	     * Whether this type is a legacy group.
	     * @type {boolean|undefined}
	     */
	    this.group = undefined; // toJSON

	    /**
	     * Cached fields by id.
	     * @type {Object.<number,Field>|null}
	     * @private
	     */
	    this._fieldsById = null;

	    /**
	     * Cached fields as an array.
	     * @type {Field[]|null}
	     * @private
	     */
	    this._fieldsArray = null;

	    /**
	     * Cached oneofs as an array.
	     * @type {OneOf[]|null}
	     * @private
	     */
	    this._oneofsArray = null;

	    /**
	     * Cached constructor.
	     * @type {Constructor<{}>}
	     * @private
	     */
	    this._ctor = null;
	}

	Object.defineProperties(Type.prototype, {

	    /**
	     * Message fields by id.
	     * @name Type#fieldsById
	     * @type {Object.<number,Field>}
	     * @readonly
	     */
	    fieldsById: {
	        get: function() {

	            /* istanbul ignore if */
	            if (this._fieldsById)
	                return this._fieldsById;

	            this._fieldsById = {};
	            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
	                var field = this.fields[names[i]],
	                    id = field.id;

	                /* istanbul ignore if */
	                if (this._fieldsById[id])
	                    throw Error("duplicate id " + id + " in " + this);

	                this._fieldsById[id] = field;
	            }
	            return this._fieldsById;
	        }
	    },

	    /**
	     * Fields of this message as an array for iteration.
	     * @name Type#fieldsArray
	     * @type {Field[]}
	     * @readonly
	     */
	    fieldsArray: {
	        get: function() {
	            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
	        }
	    },

	    /**
	     * Oneofs of this message as an array for iteration.
	     * @name Type#oneofsArray
	     * @type {OneOf[]}
	     * @readonly
	     */
	    oneofsArray: {
	        get: function() {
	            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
	        }
	    },

	    /**
	     * The registered constructor, if any registered, otherwise a generic constructor.
	     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
	     * @name Type#ctor
	     * @type {Constructor<{}>}
	     */
	    ctor: {
	        get: function() {
	            return this._ctor || (this.ctor = Type.generateConstructor(this)());
	        },
	        set: function(ctor) {

	            // Ensure proper prototype
	            var prototype = ctor.prototype;
	            if (!(prototype instanceof Message)) {
	                (ctor.prototype = new Message()).constructor = ctor;
	                util.merge(ctor.prototype, prototype);
	            }

	            // Classes and messages reference their reflected type
	            ctor.$type = ctor.prototype.$type = this;

	            // Mix in static methods
	            util.merge(ctor, Message, true);

	            this._ctor = ctor;

	            // Messages have non-enumerable default values on their prototype
	            var i = 0;
	            for (; i < /* initializes */ this.fieldsArray.length; ++i)
	                this._fieldsArray[i].resolve(); // ensures a proper value

	            // Messages have non-enumerable getters and setters for each virtual oneof field
	            var ctorProperties = {};
	            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
	                ctorProperties[this._oneofsArray[i].resolve().name] = {
	                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
	                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
	                };
	            if (i)
	                Object.defineProperties(ctor.prototype, ctorProperties);
	        }
	    }
	});

	/**
	 * Generates a constructor function for the specified type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	Type.generateConstructor = function generateConstructor(mtype) {
	    /* eslint-disable no-unexpected-multiline */
	    var gen = util.codegen(["p"], mtype.name);
	    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
	    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
	        if ((field = mtype._fieldsArray[i]).map) gen
	            ("this%s={}", util.safeProp(field.name));
	        else if (field.repeated) gen
	            ("this%s=[]", util.safeProp(field.name));
	    return gen
	    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
	        ("this[ks[i]]=p[ks[i]]");
	    /* eslint-enable no-unexpected-multiline */
	};

	function clearCache(type) {
	    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
	    delete type.encode;
	    delete type.decode;
	    delete type.verify;
	    return type;
	}

	/**
	 * Message type descriptor.
	 * @interface IType
	 * @extends INamespace
	 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
	 * @property {Object.<string,IField>} fields Field descriptors
	 * @property {number[][]} [extensions] Extension ranges
	 * @property {number[][]} [reserved] Reserved ranges
	 * @property {boolean} [group=false] Whether a legacy group or not
	 */

	/**
	 * Creates a message type from a message type descriptor.
	 * @param {string} name Message name
	 * @param {IType} json Message type descriptor
	 * @returns {Type} Created message type
	 */
	Type.fromJSON = function fromJSON(name, json) {
	    var type = new Type(name, json.options);
	    type.extensions = json.extensions;
	    type.reserved = json.reserved;
	    var names = Object.keys(json.fields),
	        i = 0;
	    for (; i < names.length; ++i)
	        type.add(
	            ( typeof json.fields[names[i]].keyType !== "undefined"
	            ? MapField.fromJSON
	            : Field.fromJSON )(names[i], json.fields[names[i]])
	        );
	    if (json.oneofs)
	        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
	            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
	    if (json.nested)
	        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
	            var nested = json.nested[names[i]];
	            type.add( // most to least likely
	                ( nested.id !== undefined
	                ? Field.fromJSON
	                : nested.fields !== undefined
	                ? Type.fromJSON
	                : nested.values !== undefined
	                ? Enum.fromJSON
	                : nested.methods !== undefined
	                ? Service.fromJSON
	                : Namespace.fromJSON )(names[i], nested)
	            );
	        }
	    if (json.extensions && json.extensions.length)
	        type.extensions = json.extensions;
	    if (json.reserved && json.reserved.length)
	        type.reserved = json.reserved;
	    if (json.group)
	        type.group = true;
	    if (json.comment)
	        type.comment = json.comment;
	    return type;
	};

	/**
	 * Converts this message type to a message type descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IType} Message type descriptor
	 */
	Type.prototype.toJSON = function toJSON(toJSONOptions) {
	    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options"    , inherited && inherited.options || undefined,
	        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
	        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
	        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
	        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
	        "group"      , this.group || undefined,
	        "nested"     , inherited && inherited.nested || undefined,
	        "comment"    , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * @override
	 */
	Type.prototype.resolveAll = function resolveAll() {
	    var fields = this.fieldsArray, i = 0;
	    while (i < fields.length)
	        fields[i++].resolve();
	    var oneofs = this.oneofsArray; i = 0;
	    while (i < oneofs.length)
	        oneofs[i++].resolve();
	    return Namespace.prototype.resolveAll.call(this);
	};

	/**
	 * @override
	 */
	Type.prototype.get = function get(name) {
	    return this.fields[name]
	        || this.oneofs && this.oneofs[name]
	        || this.nested && this.nested[name]
	        || null;
	};

	/**
	 * Adds a nested object to this type.
	 * @param {ReflectionObject} object Nested object to add
	 * @returns {Type} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
	 */
	Type.prototype.add = function add(object) {

	    if (this.get(object.name))
	        throw Error("duplicate name '" + object.name + "' in " + this);

	    if (object instanceof Field && object.extend === undefined) {
	        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
	        // The root object takes care of adding distinct sister-fields to the respective extended
	        // type instead.

	        // avoids calling the getter if not absolutely necessary because it's called quite frequently
	        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
	            throw Error("duplicate id " + object.id + " in " + this);
	        if (this.isReservedId(object.id))
	            throw Error("id " + object.id + " is reserved in " + this);
	        if (this.isReservedName(object.name))
	            throw Error("name '" + object.name + "' is reserved in " + this);

	        if (object.parent)
	            object.parent.remove(object);
	        this.fields[object.name] = object;
	        object.message = this;
	        object.onAdd(this);
	        return clearCache(this);
	    }
	    if (object instanceof OneOf) {
	        if (!this.oneofs)
	            this.oneofs = {};
	        this.oneofs[object.name] = object;
	        object.onAdd(this);
	        return clearCache(this);
	    }
	    return Namespace.prototype.add.call(this, object);
	};

	/**
	 * Removes a nested object from this type.
	 * @param {ReflectionObject} object Nested object to remove
	 * @returns {Type} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `object` is not a member of this type
	 */
	Type.prototype.remove = function remove(object) {
	    if (object instanceof Field && object.extend === undefined) {
	        // See Type#add for the reason why extension fields are excluded here.

	        /* istanbul ignore if */
	        if (!this.fields || this.fields[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.fields[object.name];
	        object.parent = null;
	        object.onRemove(this);
	        return clearCache(this);
	    }
	    if (object instanceof OneOf) {

	        /* istanbul ignore if */
	        if (!this.oneofs || this.oneofs[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.oneofs[object.name];
	        object.parent = null;
	        object.onRemove(this);
	        return clearCache(this);
	    }
	    return Namespace.prototype.remove.call(this, object);
	};

	/**
	 * Tests if the specified id is reserved.
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Type.prototype.isReservedId = function isReservedId(id) {
	    return Namespace.isReservedId(this.reserved, id);
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Type.prototype.isReservedName = function isReservedName(name) {
	    return Namespace.isReservedName(this.reserved, name);
	};

	/**
	 * Creates a new message of this type using the specified properties.
	 * @param {Object.<string,*>} [properties] Properties to set
	 * @returns {Message<{}>} Message instance
	 */
	Type.prototype.create = function create(properties) {
	    return new this.ctor(properties);
	};

	/**
	 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
	 * @returns {Type} `this`
	 */
	Type.prototype.setup = function setup() {
	    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
	    // multiple times (V8, soft-deopt prototype-check).

	    var fullName = this.fullName,
	        types    = [];
	    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
	        types.push(this._fieldsArray[i].resolve().resolvedType);

	    // Replace setup methods with type-specific generated functions
	    this.encode = encoder(this)({
	        Writer : Writer,
	        types  : types,
	        util   : util
	    });
	    this.decode = decoder(this)({
	        Reader : Reader,
	        types  : types,
	        util   : util
	    });
	    this.verify = verifier(this)({
	        types : types,
	        util  : util
	    });
	    this.fromObject = converter.fromObject(this)({
	        types : types,
	        util  : util
	    });
	    this.toObject = converter.toObject(this)({
	        types : types,
	        util  : util
	    });

	    // Inject custom wrappers for common types
	    var wrapper = wrappers[fullName];
	    if (wrapper) {
	        var originalThis = Object.create(this);
	        // if (wrapper.fromObject) {
	            originalThis.fromObject = this.fromObject;
	            this.fromObject = wrapper.fromObject.bind(originalThis);
	        // }
	        // if (wrapper.toObject) {
	            originalThis.toObject = this.toObject;
	            this.toObject = wrapper.toObject.bind(originalThis);
	        // }
	    }

	    return this;
	};

	/**
	 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
	 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
	 * @param {Writer} [writer] Writer to encode to
	 * @returns {Writer} writer
	 */
	Type.prototype.encode = function encode_setup(message, writer) {
	    return this.setup().encode(message, writer); // overrides this method
	};

	/**
	 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
	 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
	 * @param {Writer} [writer] Writer to encode to
	 * @returns {Writer} writer
	 */
	Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
	    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
	};

	/**
	 * Decodes a message of this type.
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Length of the message, if known beforehand
	 * @returns {Message<{}>} Decoded message
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {util.ProtocolError<{}>} If required fields are missing
	 */
	Type.prototype.decode = function decode_setup(reader, length) {
	    return this.setup().decode(reader, length); // overrides this method
	};

	/**
	 * Decodes a message of this type preceeded by its byte length as a varint.
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Message<{}>} Decoded message
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {util.ProtocolError} If required fields are missing
	 */
	Type.prototype.decodeDelimited = function decodeDelimited(reader) {
	    if (!(reader instanceof Reader))
	        reader = Reader.create(reader);
	    return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies that field values are valid and that required fields are present.
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {null|string} `null` if valid, otherwise the reason why it is not
	 */
	Type.prototype.verify = function verify_setup(message) {
	    return this.setup().verify(message); // overrides this method
	};

	/**
	 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
	 * @param {Object.<string,*>} object Plain object to convert
	 * @returns {Message<{}>} Message instance
	 */
	Type.prototype.fromObject = function fromObject(object) {
	    return this.setup().fromObject(object);
	};

	/**
	 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
	 * @interface IConversionOptions
	 * @property {Function} [longs] Long conversion type.
	 * Valid values are `String` and `Number` (the global types).
	 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
	 * @property {Function} [enums] Enum value conversion type.
	 * Only valid value is `String` (the global type).
	 * Defaults to copy the present value, which is the numeric id.
	 * @property {Function} [bytes] Bytes value conversion type.
	 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
	 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
	 * @property {boolean} [defaults=false] Also sets default values on the resulting object
	 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
	 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
	 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
	 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
	 */

	/**
	 * Creates a plain object from a message of this type. Also converts values to other types if specified.
	 * @param {Message<{}>} message Message instance
	 * @param {IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Type.prototype.toObject = function toObject(message, options) {
	    return this.setup().toObject(message, options);
	};

	/**
	 * Decorator function as returned by {@link Type.d} (TypeScript).
	 * @typedef TypeDecorator
	 * @type {function}
	 * @param {Constructor<T>} target Target constructor
	 * @returns {undefined}
	 * @template T extends Message<T>
	 */

	/**
	 * Type decorator (TypeScript).
	 * @param {string} [typeName] Type name, defaults to the constructor's name
	 * @returns {TypeDecorator<T>} Decorator function
	 * @template T extends Message<T>
	 */
	Type.d = function decorateType(typeName) {
	    return function typeDecorator(target) {
	        util.decorateType(target, typeName);
	    };
	};
	return type;
}

var root;
var hasRequiredRoot;

function requireRoot () {
	if (hasRequiredRoot) return root;
	hasRequiredRoot = 1;
	root = Root;

	// extends Namespace
	var Namespace = requireNamespace();
	((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

	var Field   = requireField(),
	    Enum    = require_enum(),
	    OneOf   = requireOneof(),
	    util    = requireUtil$1();

	var Type,   // cyclic
	    parse,  // might be excluded
	    common; // "

	/**
	 * Constructs a new root namespace instance.
	 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {Object.<string,*>} [options] Top level options
	 */
	function Root(options) {
	    Namespace.call(this, "", options);

	    /**
	     * Deferred extension fields.
	     * @type {Field[]}
	     */
	    this.deferred = [];

	    /**
	     * Resolved file names of loaded files.
	     * @type {string[]}
	     */
	    this.files = [];
	}

	/**
	 * Loads a namespace descriptor into a root namespace.
	 * @param {INamespace} json Nameespace descriptor
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
	 * @returns {Root} Root namespace
	 */
	Root.fromJSON = function fromJSON(json, root) {
	    if (!root)
	        root = new Root();
	    if (json.options)
	        root.setOptions(json.options);
	    return root.addJSON(json.nested);
	};

	/**
	 * Resolves the path of an imported file, relative to the importing origin.
	 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
	 * @function
	 * @param {string} origin The file name of the importing file
	 * @param {string} target The file name being imported
	 * @returns {string|null} Resolved path to `target` or `null` to skip the file
	 */
	Root.prototype.resolvePath = util.path.resolve;

	/**
	 * Fetch content from file path or url
	 * This method exists so you can override it with your own logic.
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 */
	Root.prototype.fetch = util.fetch;

	// A symbol-like function to safely signal synchronous loading
	/* istanbul ignore next */
	function SYNC() {} // eslint-disable-line no-empty-function

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} options Parse options
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 */
	Root.prototype.load = function load(filename, options, callback) {
	    if (typeof options === "function") {
	        callback = options;
	        options = undefined;
	    }
	    var self = this;
	    if (!callback)
	        return util.asPromise(load, self, filename, options);

	    var sync = callback === SYNC; // undocumented

	    // Finishes loading by calling the callback (exactly once)
	    function finish(err, root) {
	        /* istanbul ignore if */
	        if (!callback)
	            return;
	        if (sync)
	            throw err;
	        var cb = callback;
	        callback = null;
	        cb(err, root);
	    }

	    // Bundled definition existence checking
	    function getBundledFileName(filename) {
	        var idx = filename.lastIndexOf("google/protobuf/");
	        if (idx > -1) {
	            var altname = filename.substring(idx);
	            if (altname in common) return altname;
	        }
	        return null;
	    }

	    // Processes a single file
	    function process(filename, source) {
	        try {
	            if (util.isString(source) && source.charAt(0) === "{")
	                source = JSON.parse(source);
	            if (!util.isString(source))
	                self.setOptions(source.options).addJSON(source.nested);
	            else {
	                parse.filename = filename;
	                var parsed = parse(source, self, options),
	                    resolved,
	                    i = 0;
	                if (parsed.imports)
	                    for (; i < parsed.imports.length; ++i)
	                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
	                            fetch(resolved);
	                if (parsed.weakImports)
	                    for (i = 0; i < parsed.weakImports.length; ++i)
	                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
	                            fetch(resolved, true);
	            }
	        } catch (err) {
	            finish(err);
	        }
	        if (!sync && !queued)
	            finish(null, self); // only once anyway
	    }

	    // Fetches a single file
	    function fetch(filename, weak) {
	        filename = getBundledFileName(filename) || filename;

	        // Skip if already loaded / attempted
	        if (self.files.indexOf(filename) > -1)
	            return;
	        self.files.push(filename);

	        // Shortcut bundled definitions
	        if (filename in common) {
	            if (sync)
	                process(filename, common[filename]);
	            else {
	                ++queued;
	                setTimeout(function() {
	                    --queued;
	                    process(filename, common[filename]);
	                });
	            }
	            return;
	        }

	        // Otherwise fetch from disk or network
	        if (sync) {
	            var source;
	            try {
	                source = util.fs.readFileSync(filename).toString("utf8");
	            } catch (err) {
	                if (!weak)
	                    finish(err);
	                return;
	            }
	            process(filename, source);
	        } else {
	            ++queued;
	            self.fetch(filename, function(err, source) {
	                --queued;
	                /* istanbul ignore if */
	                if (!callback)
	                    return; // terminated meanwhile
	                if (err) {
	                    /* istanbul ignore else */
	                    if (!weak)
	                        finish(err);
	                    else if (!queued) // can't be covered reliably
	                        finish(null, self);
	                    return;
	                }
	                process(filename, source);
	            });
	        }
	    }
	    var queued = 0;

	    // Assembling the root namespace doesn't require working type
	    // references anymore, so we can load everything in parallel
	    if (util.isString(filename))
	        filename = [ filename ];
	    for (var i = 0, resolved; i < filename.length; ++i)
	        if (resolved = self.resolvePath("", filename[i]))
	            fetch(resolved);

	    if (sync)
	        return self;
	    if (!queued)
	        finish(null, self);
	    return undefined;
	};
	// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
	 * @function Root#load
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @variation 2
	 */
	// function load(filename:string, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
	 * @function Root#load
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {Promise<Root>} Promise
	 * @variation 3
	 */
	// function load(filename:string, [options:IParseOptions]):Promise<Root>

	/**
	 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
	 * @function Root#loadSync
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {Root} Root namespace
	 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
	 */
	Root.prototype.loadSync = function loadSync(filename, options) {
	    if (!util.isNode)
	        throw Error("not supported");
	    return this.load(filename, options, SYNC);
	};

	/**
	 * @override
	 */
	Root.prototype.resolveAll = function resolveAll() {
	    if (this.deferred.length)
	        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
	            return "'extend " + field.extend + "' in " + field.parent.fullName;
	        }).join(", "));
	    return Namespace.prototype.resolveAll.call(this);
	};

	// only uppercased (and thus conflict-free) children are exposed, see below
	var exposeRe = /^[A-Z]/;

	/**
	 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
	 * @param {Root} root Root instance
	 * @param {Field} field Declaring extension field witin the declaring type
	 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
	 * @inner
	 * @ignore
	 */
	function tryHandleExtension(root, field) {
	    var extendedType = field.parent.lookup(field.extend);
	    if (extendedType) {
	        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
	        //do not allow to extend same field twice to prevent the error
	        if (extendedType.get(sisterField.name)) {
	            return true;
	        }
	        sisterField.declaringField = field;
	        field.extensionField = sisterField;
	        extendedType.add(sisterField);
	        return true;
	    }
	    return false;
	}

	/**
	 * Called when any object is added to this root or its sub-namespaces.
	 * @param {ReflectionObject} object Object added
	 * @returns {undefined}
	 * @private
	 */
	Root.prototype._handleAdd = function _handleAdd(object) {
	    if (object instanceof Field) {

	        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
	            if (!tryHandleExtension(this, object))
	                this.deferred.push(object);

	    } else if (object instanceof Enum) {

	        if (exposeRe.test(object.name))
	            object.parent[object.name] = object.values; // expose enum values as property of its parent

	    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

	        if (object instanceof Type) // Try to handle any deferred extensions
	            for (var i = 0; i < this.deferred.length;)
	                if (tryHandleExtension(this, this.deferred[i]))
	                    this.deferred.splice(i, 1);
	                else
	                    ++i;
	        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
	            this._handleAdd(object._nestedArray[j]);
	        if (exposeRe.test(object.name))
	            object.parent[object.name] = object; // expose namespace as property of its parent
	    }

	    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
	    // properties of namespaces just like static code does. This allows using a .d.ts generated for
	    // a static module with reflection-based solutions where the condition is met.
	};

	/**
	 * Called when any object is removed from this root or its sub-namespaces.
	 * @param {ReflectionObject} object Object removed
	 * @returns {undefined}
	 * @private
	 */
	Root.prototype._handleRemove = function _handleRemove(object) {
	    if (object instanceof Field) {

	        if (/* an extension field */ object.extend !== undefined) {
	            if (/* already handled */ object.extensionField) { // remove its sister field
	                object.extensionField.parent.remove(object.extensionField);
	                object.extensionField = null;
	            } else { // cancel the extension
	                var index = this.deferred.indexOf(object);
	                /* istanbul ignore else */
	                if (index > -1)
	                    this.deferred.splice(index, 1);
	            }
	        }

	    } else if (object instanceof Enum) {

	        if (exposeRe.test(object.name))
	            delete object.parent[object.name]; // unexpose enum values

	    } else if (object instanceof Namespace) {

	        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
	            this._handleRemove(object._nestedArray[i]);

	        if (exposeRe.test(object.name))
	            delete object.parent[object.name]; // unexpose namespaces

	    }
	};

	// Sets up cyclic dependencies (called in index-light)
	Root._configure = function(Type_, parse_, common_) {
	    Type   = Type_;
	    parse  = parse_;
	    common = common_;
	};
	return root;
}

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$2.exports;
	hasRequiredUtil$1 = 1;

	/**
	 * Various utility functions.
	 * @namespace
	 */
	var util = util$2.exports = requireMinimal();

	var roots = requireRoots();

	var Type, // cyclic
	    Enum;

	util.codegen = requireCodegen();
	util.fetch   = requireFetch();
	util.path    = requirePath();

	/**
	 * Node's fs module if available.
	 * @type {Object.<string,*>}
	 */
	util.fs = util.inquire("fs");

	/**
	 * Converts an object's values to an array.
	 * @param {Object.<string,*>} object Object to convert
	 * @returns {Array.<*>} Converted array
	 */
	util.toArray = function toArray(object) {
	    if (object) {
	        var keys  = Object.keys(object),
	            array = new Array(keys.length),
	            index = 0;
	        while (index < keys.length)
	            array[index] = object[keys[index++]];
	        return array;
	    }
	    return [];
	};

	/**
	 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
	 * @param {Array.<*>} array Array to convert
	 * @returns {Object.<string,*>} Converted object
	 */
	util.toObject = function toObject(array) {
	    var object = {},
	        index  = 0;
	    while (index < array.length) {
	        var key = array[index++],
	            val = array[index++];
	        if (val !== undefined)
	            object[key] = val;
	    }
	    return object;
	};

	var safePropBackslashRe = /\\/g,
	    safePropQuoteRe     = /"/g;

	/**
	 * Tests whether the specified name is a reserved word in JS.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	util.isReserved = function isReserved(name) {
	    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
	};

	/**
	 * Returns a safe property accessor for the specified property name.
	 * @param {string} prop Property name
	 * @returns {string} Safe accessor
	 */
	util.safeProp = function safeProp(prop) {
	    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
	        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
	    return "." + prop;
	};

	/**
	 * Converts the first character of a string to upper case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.ucFirst = function ucFirst(str) {
	    return str.charAt(0).toUpperCase() + str.substring(1);
	};

	var camelCaseRe = /_([a-z])/g;

	/**
	 * Converts a string to camel case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.camelCase = function camelCase(str) {
	    return str.substring(0, 1)
	         + str.substring(1)
	               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
	};

	/**
	 * Compares reflected fields by id.
	 * @param {Field} a First field
	 * @param {Field} b Second field
	 * @returns {number} Comparison value
	 */
	util.compareFieldsById = function compareFieldsById(a, b) {
	    return a.id - b.id;
	};

	/**
	 * Decorator helper for types (TypeScript).
	 * @param {Constructor<T>} ctor Constructor function
	 * @param {string} [typeName] Type name, defaults to the constructor's name
	 * @returns {Type} Reflected type
	 * @template T extends Message<T>
	 * @property {Root} root Decorators root
	 */
	util.decorateType = function decorateType(ctor, typeName) {

	    /* istanbul ignore if */
	    if (ctor.$type) {
	        if (typeName && ctor.$type.name !== typeName) {
	            util.decorateRoot.remove(ctor.$type);
	            ctor.$type.name = typeName;
	            util.decorateRoot.add(ctor.$type);
	        }
	        return ctor.$type;
	    }

	    /* istanbul ignore next */
	    if (!Type)
	        Type = requireType();

	    var type = new Type(typeName || ctor.name);
	    util.decorateRoot.add(type);
	    type.ctor = ctor; // sets up .encode, .decode etc.
	    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
	    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
	    return type;
	};

	var decorateEnumIndex = 0;

	/**
	 * Decorator helper for enums (TypeScript).
	 * @param {Object} object Enum object
	 * @returns {Enum} Reflected enum
	 */
	util.decorateEnum = function decorateEnum(object) {

	    /* istanbul ignore if */
	    if (object.$type)
	        return object.$type;

	    /* istanbul ignore next */
	    if (!Enum)
	        Enum = require_enum();

	    var enm = new Enum("Enum" + decorateEnumIndex++, object);
	    util.decorateRoot.add(enm);
	    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
	    return enm;
	};


	/**
	 * Sets the value of a property by property path. If a value already exists, it is turned to an array
	 * @param {Object.<string,*>} dst Destination object
	 * @param {string} path dot '.' delimited path of the property to set
	 * @param {Object} value the value to set
	 * @returns {Object.<string,*>} Destination object
	 */
	util.setProperty = function setProperty(dst, path, value) {
	    function setProp(dst, path, value) {
	        var part = path.shift();
	        if (part === "__proto__" || part === "prototype") {
	          return dst;
	        }
	        if (path.length > 0) {
	            dst[part] = setProp(dst[part] || {}, path, value);
	        } else {
	            var prevValue = dst[part];
	            if (prevValue)
	                value = [].concat(prevValue).concat(value);
	            dst[part] = value;
	        }
	        return dst;
	    }

	    if (typeof dst !== "object")
	        throw TypeError("dst must be an object");
	    if (!path)
	        throw TypeError("path must be specified");

	    path = path.split(".");
	    return setProp(dst, path, value);
	};

	/**
	 * Decorator root (TypeScript).
	 * @name util.decorateRoot
	 * @type {Root}
	 * @readonly
	 */
	Object.defineProperty(util, "decorateRoot", {
	    get: function() {
	        return roots["decorated"] || (roots["decorated"] = new (requireRoot())());
	    }
	});
	return util$2.exports;
}

var object;
var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	object = ReflectionObject;

	ReflectionObject.className = "ReflectionObject";

	var util = requireUtil$1();

	var Root; // cyclic

	/**
	 * Constructs a new reflection object instance.
	 * @classdesc Base class of all reflection objects.
	 * @constructor
	 * @param {string} name Object name
	 * @param {Object.<string,*>} [options] Declared options
	 * @abstract
	 */
	function ReflectionObject(name, options) {

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    if (options && !util.isObject(options))
	        throw TypeError("options must be an object");

	    /**
	     * Options.
	     * @type {Object.<string,*>|undefined}
	     */
	    this.options = options; // toJSON

	    /**
	     * Parsed Options.
	     * @type {Array.<Object.<string,*>>|undefined}
	     */
	    this.parsedOptions = null;

	    /**
	     * Unique name within its namespace.
	     * @type {string}
	     */
	    this.name = name;

	    /**
	     * Parent namespace.
	     * @type {Namespace|null}
	     */
	    this.parent = null;

	    /**
	     * Whether already resolved or not.
	     * @type {boolean}
	     */
	    this.resolved = false;

	    /**
	     * Comment text, if any.
	     * @type {string|null}
	     */
	    this.comment = null;

	    /**
	     * Defining file name.
	     * @type {string|null}
	     */
	    this.filename = null;
	}

	Object.defineProperties(ReflectionObject.prototype, {

	    /**
	     * Reference to the root namespace.
	     * @name ReflectionObject#root
	     * @type {Root}
	     * @readonly
	     */
	    root: {
	        get: function() {
	            var ptr = this;
	            while (ptr.parent !== null)
	                ptr = ptr.parent;
	            return ptr;
	        }
	    },

	    /**
	     * Full name including leading dot.
	     * @name ReflectionObject#fullName
	     * @type {string}
	     * @readonly
	     */
	    fullName: {
	        get: function() {
	            var path = [ this.name ],
	                ptr = this.parent;
	            while (ptr) {
	                path.unshift(ptr.name);
	                ptr = ptr.parent;
	            }
	            return path.join(".");
	        }
	    }
	});

	/**
	 * Converts this reflection object to its descriptor representation.
	 * @returns {Object.<string,*>} Descriptor
	 * @abstract
	 */
	ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
	    throw Error(); // not implemented, shouldn't happen
	};

	/**
	 * Called when this object is added to a parent.
	 * @param {ReflectionObject} parent Parent added to
	 * @returns {undefined}
	 */
	ReflectionObject.prototype.onAdd = function onAdd(parent) {
	    if (this.parent && this.parent !== parent)
	        this.parent.remove(this);
	    this.parent = parent;
	    this.resolved = false;
	    var root = parent.root;
	    if (root instanceof Root)
	        root._handleAdd(this);
	};

	/**
	 * Called when this object is removed from a parent.
	 * @param {ReflectionObject} parent Parent removed from
	 * @returns {undefined}
	 */
	ReflectionObject.prototype.onRemove = function onRemove(parent) {
	    var root = parent.root;
	    if (root instanceof Root)
	        root._handleRemove(this);
	    this.parent = null;
	    this.resolved = false;
	};

	/**
	 * Resolves this objects type references.
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.resolve = function resolve() {
	    if (this.resolved)
	        return this;
	    if (this.root instanceof Root)
	        this.resolved = true; // only if part of a root
	    return this;
	};

	/**
	 * Gets an option value.
	 * @param {string} name Option name
	 * @returns {*} Option value or `undefined` if not set
	 */
	ReflectionObject.prototype.getOption = function getOption(name) {
	    if (this.options)
	        return this.options[name];
	    return undefined;
	};

	/**
	 * Sets an option.
	 * @param {string} name Option name
	 * @param {*} value Option value
	 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
	    if (!ifNotSet || !this.options || this.options[name] === undefined)
	        (this.options || (this.options = {}))[name] = value;
	    return this;
	};

	/**
	 * Sets a parsed option.
	 * @param {string} name parsed Option name
	 * @param {*} value Option value
	 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
	    if (!this.parsedOptions) {
	        this.parsedOptions = [];
	    }
	    var parsedOptions = this.parsedOptions;
	    if (propName) {
	        // If setting a sub property of an option then try to merge it
	        // with an existing option
	        var opt = parsedOptions.find(function (opt) {
	            return Object.prototype.hasOwnProperty.call(opt, name);
	        });
	        if (opt) {
	            // If we found an existing option - just merge the property value
	            var newValue = opt[name];
	            util.setProperty(newValue, propName, value);
	        } else {
	            // otherwise, create a new option, set it's property and add it to the list
	            opt = {};
	            opt[name] = util.setProperty({}, propName, value);
	            parsedOptions.push(opt);
	        }
	    } else {
	        // Always create a new option when setting the value of the option itself
	        var newOpt = {};
	        newOpt[name] = value;
	        parsedOptions.push(newOpt);
	    }
	    return this;
	};

	/**
	 * Sets multiple options.
	 * @param {Object.<string,*>} options Options to set
	 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
	    if (options)
	        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
	            this.setOption(keys[i], options[keys[i]], ifNotSet);
	    return this;
	};

	/**
	 * Converts this instance to its string representation.
	 * @returns {string} Class name[, space, full name]
	 */
	ReflectionObject.prototype.toString = function toString() {
	    var className = this.constructor.className,
	        fullName  = this.fullName;
	    if (fullName.length)
	        return className + " " + fullName;
	    return className;
	};

	// Sets up cyclic dependencies (called in index-light)
	ReflectionObject._configure = function(Root_) {
	    Root = Root_;
	};
	return object;
}

var _enum;
var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	_enum = Enum;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

	var Namespace = requireNamespace(),
	    util = requireUtil$1();

	/**
	 * Constructs a new enum instance.
	 * @classdesc Reflected enum.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {Object.<string,number>} [values] Enum values as an object, by name
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] The comment for this enum
	 * @param {Object.<string,string>} [comments] The value comments for this enum
	 * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum
	 */
	function Enum(name, values, options, comment, comments, valuesOptions) {
	    ReflectionObject.call(this, name, options);

	    if (values && typeof values !== "object")
	        throw TypeError("values must be an object");

	    /**
	     * Enum values by id.
	     * @type {Object.<number,string>}
	     */
	    this.valuesById = {};

	    /**
	     * Enum values by name.
	     * @type {Object.<string,number>}
	     */
	    this.values = Object.create(this.valuesById); // toJSON, marker

	    /**
	     * Enum comment text.
	     * @type {string|null}
	     */
	    this.comment = comment;

	    /**
	     * Value comment texts, if any.
	     * @type {Object.<string,string>}
	     */
	    this.comments = comments || {};

	    /**
	     * Values options, if any
	     * @type {Object<string, Object<string, *>>|undefined}
	     */
	    this.valuesOptions = valuesOptions;

	    /**
	     * Reserved ranges, if any.
	     * @type {Array.<number[]|string>}
	     */
	    this.reserved = undefined; // toJSON

	    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
	    // compatible enum. This is used by pbts to write actual enum definitions that work for
	    // static and reflection code alike instead of emitting generic object definitions.

	    if (values)
	        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
	            if (typeof values[keys[i]] === "number") // use forward entries only
	                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
	}

	/**
	 * Enum descriptor.
	 * @interface IEnum
	 * @property {Object.<string,number>} values Enum values
	 * @property {Object.<string,*>} [options] Enum options
	 */

	/**
	 * Constructs an enum from an enum descriptor.
	 * @param {string} name Enum name
	 * @param {IEnum} json Enum descriptor
	 * @returns {Enum} Created enum
	 * @throws {TypeError} If arguments are invalid
	 */
	Enum.fromJSON = function fromJSON(name, json) {
	    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
	    enm.reserved = json.reserved;
	    return enm;
	};

	/**
	 * Converts this enum to an enum descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IEnum} Enum descriptor
	 */
	Enum.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options"       , this.options,
	        "valuesOptions" , this.valuesOptions,
	        "values"        , this.values,
	        "reserved"      , this.reserved && this.reserved.length ? this.reserved : undefined,
	        "comment"       , keepComments ? this.comment : undefined,
	        "comments"      , keepComments ? this.comments : undefined
	    ]);
	};

	/**
	 * Adds a value to this enum.
	 * @param {string} name Value name
	 * @param {number} id Value id
	 * @param {string} [comment] Comment, if any
	 * @param {Object.<string, *>|undefined} [options] Options, if any
	 * @returns {Enum} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a value with this name or id
	 */
	Enum.prototype.add = function add(name, id, comment, options) {
	    // utilized by the parser but not by .fromJSON

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    if (!util.isInteger(id))
	        throw TypeError("id must be an integer");

	    if (this.values[name] !== undefined)
	        throw Error("duplicate name '" + name + "' in " + this);

	    if (this.isReservedId(id))
	        throw Error("id " + id + " is reserved in " + this);

	    if (this.isReservedName(name))
	        throw Error("name '" + name + "' is reserved in " + this);

	    if (this.valuesById[id] !== undefined) {
	        if (!(this.options && this.options.allow_alias))
	            throw Error("duplicate id " + id + " in " + this);
	        this.values[name] = id;
	    } else
	        this.valuesById[this.values[name] = id] = name;

	    if (options) {
	        if (this.valuesOptions === undefined)
	            this.valuesOptions = {};
	        this.valuesOptions[name] = options || null;
	    }

	    this.comments[name] = comment || null;
	    return this;
	};

	/**
	 * Removes a value from this enum
	 * @param {string} name Value name
	 * @returns {Enum} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `name` is not a name of this enum
	 */
	Enum.prototype.remove = function remove(name) {

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    var val = this.values[name];
	    if (val == null)
	        throw Error("name '" + name + "' does not exist in " + this);

	    delete this.valuesById[val];
	    delete this.values[name];
	    delete this.comments[name];
	    if (this.valuesOptions)
	        delete this.valuesOptions[name];

	    return this;
	};

	/**
	 * Tests if the specified id is reserved.
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Enum.prototype.isReservedId = function isReservedId(id) {
	    return Namespace.isReservedId(this.reserved, id);
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Enum.prototype.isReservedName = function isReservedName(name) {
	    return Namespace.isReservedName(this.reserved, name);
	};
	return _enum;
}

var encoder_1;
var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder_1;
	hasRequiredEncoder = 1;
	encoder_1 = encoder;

	var Enum     = require_enum(),
	    types    = requireTypes(),
	    util     = requireUtil$1();

	/**
	 * Generates a partial message type encoder.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {number} fieldIndex Field index
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genTypePartial(gen, field, fieldIndex, ref) {
	    return field.resolvedType.group
	        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
	        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
	}

	/**
	 * Generates an encoder specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function encoder(mtype) {
	    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
	    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
	    ("if(!w)")
	        ("w=Writer.create()");

	    var i, ref;

	    // "when a message is serialized its known fields should be written sequentially by field number"
	    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

	    for (var i = 0; i < fields.length; ++i) {
	        var field    = fields[i].resolve(),
	            index    = mtype._fieldsArray.indexOf(field),
	            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
	            wireType = types.basic[type];
	            ref      = "m" + util.safeProp(field.name);

	        // Map fields
	        if (field.map) {
	            gen
	    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
	        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
	            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
	            if (wireType === undefined) gen
	            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
	            else gen
	            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
	            gen
	        ("}")
	    ("}");

	            // Repeated fields
	        } else if (field.repeated) { gen
	    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

	            // Packed repeated
	            if (field.packed && types.packed[type] !== undefined) { gen

	        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
	        ("for(var i=0;i<%s.length;++i)", ref)
	            ("w.%s(%s[i])", type, ref)
	        ("w.ldelim()");

	            // Non-packed
	            } else { gen

	        ("for(var i=0;i<%s.length;++i)", ref);
	                if (wireType === undefined)
	            genTypePartial(gen, field, index, ref + "[i]");
	                else gen
	            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

	            } gen
	    ("}");

	        // Non-repeated
	        } else {
	            if (field.optional) gen
	    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

	            if (wireType === undefined)
	        genTypePartial(gen, field, index, ref);
	            else gen
	        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

	        }
	    }

	    return gen
	    ("return w");
	    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
	}
	return encoder_1;
}

var hasRequiredIndexLight;

function requireIndexLight () {
	if (hasRequiredIndexLight) return indexLight.exports;
	hasRequiredIndexLight = 1;
	var protobuf = indexLight.exports = requireIndexMinimal();

	protobuf.build = "light";

	/**
	 * A node-style callback as used by {@link load} and {@link Root#load}.
	 * @typedef LoadCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any, otherwise `null`
	 * @param {Root} [root] Root, if there hasn't been an error
	 * @returns {undefined}
	 */

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} root Root namespace, defaults to create a new one if omitted.
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @see {@link Root#load}
	 */
	function load(filename, root, callback) {
	    if (typeof root === "function") {
	        callback = root;
	        root = new protobuf.Root();
	    } else if (!root)
	        root = new protobuf.Root();
	    return root.load(filename, callback);
	}

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
	 * @name load
	 * @function
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @see {@link Root#load}
	 * @variation 2
	 */
	// function load(filename:string, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
	 * @name load
	 * @function
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
	 * @returns {Promise<Root>} Promise
	 * @see {@link Root#load}
	 * @variation 3
	 */
	// function load(filename:string, [root:Root]):Promise<Root>

	protobuf.load = load;

	/**
	 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
	 * @returns {Root} Root namespace
	 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
	 * @see {@link Root#loadSync}
	 */
	function loadSync(filename, root) {
	    if (!root)
	        root = new protobuf.Root();
	    return root.loadSync(filename);
	}

	protobuf.loadSync = loadSync;

	// Serialization
	protobuf.encoder          = requireEncoder();
	protobuf.decoder          = requireDecoder();
	protobuf.verifier         = requireVerifier();
	protobuf.converter        = requireConverter();

	// Reflection
	protobuf.ReflectionObject = requireObject();
	protobuf.Namespace        = requireNamespace();
	protobuf.Root             = requireRoot();
	protobuf.Enum             = require_enum();
	protobuf.Type             = requireType();
	protobuf.Field            = requireField();
	protobuf.OneOf            = requireOneof();
	protobuf.MapField         = requireMapfield();
	protobuf.Service          = requireService();
	protobuf.Method           = requireMethod();

	// Runtime
	protobuf.Message          = requireMessage();
	protobuf.wrappers         = requireWrappers();

	// Utility
	protobuf.types            = requireTypes();
	protobuf.util             = requireUtil$1();

	// Set up possibly cyclic reflection dependencies
	protobuf.ReflectionObject._configure(protobuf.Root);
	protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
	protobuf.Root._configure(protobuf.Type);
	protobuf.Field._configure(protobuf.Type);
	return indexLight.exports;
}

var tokenize_1;
var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize_1;
	hasRequiredTokenize = 1;
	tokenize_1 = tokenize;

	var delimRe        = /[\s{}=;:[\],'"()<>]/g,
	    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
	    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

	var setCommentRe = /^ *[*/]+ */,
	    setCommentAltRe = /^\s*\*?\/*/,
	    setCommentSplitRe = /\n/g,
	    whitespaceRe = /\s/,
	    unescapeRe = /\\(.?)/g;

	var unescapeMap = {
	    "0": "\0",
	    "r": "\r",
	    "n": "\n",
	    "t": "\t"
	};

	/**
	 * Unescapes a string.
	 * @param {string} str String to unescape
	 * @returns {string} Unescaped string
	 * @property {Object.<string,string>} map Special characters map
	 * @memberof tokenize
	 */
	function unescape(str) {
	    return str.replace(unescapeRe, function($0, $1) {
	        switch ($1) {
	            case "\\":
	            case "":
	                return $1;
	            default:
	                return unescapeMap[$1] || "";
	        }
	    });
	}

	tokenize.unescape = unescape;

	/**
	 * Gets the next token and advances.
	 * @typedef TokenizerHandleNext
	 * @type {function}
	 * @returns {string|null} Next token or `null` on eof
	 */

	/**
	 * Peeks for the next token.
	 * @typedef TokenizerHandlePeek
	 * @type {function}
	 * @returns {string|null} Next token or `null` on eof
	 */

	/**
	 * Pushes a token back to the stack.
	 * @typedef TokenizerHandlePush
	 * @type {function}
	 * @param {string} token Token
	 * @returns {undefined}
	 */

	/**
	 * Skips the next token.
	 * @typedef TokenizerHandleSkip
	 * @type {function}
	 * @param {string} expected Expected token
	 * @param {boolean} [optional=false] If optional
	 * @returns {boolean} Whether the token matched
	 * @throws {Error} If the token didn't match and is not optional
	 */

	/**
	 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
	 * @typedef TokenizerHandleCmnt
	 * @type {function}
	 * @param {number} [line] Line number
	 * @returns {string|null} Comment text or `null` if none
	 */

	/**
	 * Handle object returned from {@link tokenize}.
	 * @interface ITokenizerHandle
	 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
	 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
	 * @property {TokenizerHandlePush} push Pushes a token back to the stack
	 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
	 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
	 * @property {number} line Current line number
	 */

	/**
	 * Tokenizes the given .proto source and returns an object with useful utility functions.
	 * @param {string} source Source contents
	 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
	 * @returns {ITokenizerHandle} Tokenizer handle
	 */
	function tokenize(source, alternateCommentMode) {
	    /* eslint-disable callback-return */
	    source = source.toString();

	    var offset = 0,
	        length = source.length,
	        line = 1,
	        lastCommentLine = 0,
	        comments = {};

	    var stack = [];

	    var stringDelim = null;

	    /* istanbul ignore next */
	    /**
	     * Creates an error for illegal syntax.
	     * @param {string} subject Subject
	     * @returns {Error} Error created
	     * @inner
	     */
	    function illegal(subject) {
	        return Error("illegal " + subject + " (line " + line + ")");
	    }

	    /**
	     * Reads a string till its end.
	     * @returns {string} String read
	     * @inner
	     */
	    function readString() {
	        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
	        re.lastIndex = offset - 1;
	        var match = re.exec(source);
	        if (!match)
	            throw illegal("string");
	        offset = re.lastIndex;
	        push(stringDelim);
	        stringDelim = null;
	        return unescape(match[1]);
	    }

	    /**
	     * Gets the character at `pos` within the source.
	     * @param {number} pos Position
	     * @returns {string} Character
	     * @inner
	     */
	    function charAt(pos) {
	        return source.charAt(pos);
	    }

	    /**
	     * Sets the current comment text.
	     * @param {number} start Start offset
	     * @param {number} end End offset
	     * @param {boolean} isLeading set if a leading comment
	     * @returns {undefined}
	     * @inner
	     */
	    function setComment(start, end, isLeading) {
	        var comment = {
	            type: source.charAt(start++),
	            lineEmpty: false,
	            leading: isLeading,
	        };
	        var lookback;
	        if (alternateCommentMode) {
	            lookback = 2;  // alternate comment parsing: "//" or "/*"
	        } else {
	            lookback = 3;  // "///" or "/**"
	        }
	        var commentOffset = start - lookback,
	            c;
	        do {
	            if (--commentOffset < 0 ||
	                    (c = source.charAt(commentOffset)) === "\n") {
	                comment.lineEmpty = true;
	                break;
	            }
	        } while (c === " " || c === "\t");
	        var lines = source
	            .substring(start, end)
	            .split(setCommentSplitRe);
	        for (var i = 0; i < lines.length; ++i)
	            lines[i] = lines[i]
	                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
	                .trim();
	        comment.text = lines
	            .join("\n")
	            .trim();

	        comments[line] = comment;
	        lastCommentLine = line;
	    }

	    function isDoubleSlashCommentLine(startOffset) {
	        var endOffset = findEndOfLine(startOffset);

	        // see if remaining line matches comment pattern
	        var lineText = source.substring(startOffset, endOffset);
	        var isComment = /^\s*\/\//.test(lineText);
	        return isComment;
	    }

	    function findEndOfLine(cursor) {
	        // find end of cursor's line
	        var endOffset = cursor;
	        while (endOffset < length && charAt(endOffset) !== "\n") {
	            endOffset++;
	        }
	        return endOffset;
	    }

	    /**
	     * Obtains the next token.
	     * @returns {string|null} Next token or `null` on eof
	     * @inner
	     */
	    function next() {
	        if (stack.length > 0)
	            return stack.shift();
	        if (stringDelim)
	            return readString();
	        var repeat,
	            prev,
	            curr,
	            start,
	            isDoc,
	            isLeadingComment = offset === 0;
	        do {
	            if (offset === length)
	                return null;
	            repeat = false;
	            while (whitespaceRe.test(curr = charAt(offset))) {
	                if (curr === "\n") {
	                    isLeadingComment = true;
	                    ++line;
	                }
	                if (++offset === length)
	                    return null;
	            }

	            if (charAt(offset) === "/") {
	                if (++offset === length) {
	                    throw illegal("comment");
	                }
	                if (charAt(offset) === "/") { // Line
	                    if (!alternateCommentMode) {
	                        // check for triple-slash comment
	                        isDoc = charAt(start = offset + 1) === "/";

	                        while (charAt(++offset) !== "\n") {
	                            if (offset === length) {
	                                return null;
	                            }
	                        }
	                        ++offset;
	                        if (isDoc) {
	                            setComment(start, offset - 1, isLeadingComment);
	                            // Trailing comment cannot not be multi-line,
	                            // so leading comment state should be reset to handle potential next comments
	                            isLeadingComment = true;
	                        }
	                        ++line;
	                        repeat = true;
	                    } else {
	                        // check for double-slash comments, consolidating consecutive lines
	                        start = offset;
	                        isDoc = false;
	                        if (isDoubleSlashCommentLine(offset - 1)) {
	                            isDoc = true;
	                            do {
	                                offset = findEndOfLine(offset);
	                                if (offset === length) {
	                                    break;
	                                }
	                                offset++;
	                                if (!isLeadingComment) {
	                                    // Trailing comment cannot not be multi-line
	                                    break;
	                                }
	                            } while (isDoubleSlashCommentLine(offset));
	                        } else {
	                            offset = Math.min(length, findEndOfLine(offset) + 1);
	                        }
	                        if (isDoc) {
	                            setComment(start, offset, isLeadingComment);
	                            isLeadingComment = true;
	                        }
	                        line++;
	                        repeat = true;
	                    }
	                } else if ((curr = charAt(offset)) === "*") { /* Block */
	                    // check for /** (regular comment mode) or /* (alternate comment mode)
	                    start = offset + 1;
	                    isDoc = alternateCommentMode || charAt(start) === "*";
	                    do {
	                        if (curr === "\n") {
	                            ++line;
	                        }
	                        if (++offset === length) {
	                            throw illegal("comment");
	                        }
	                        prev = curr;
	                        curr = charAt(offset);
	                    } while (prev !== "*" || curr !== "/");
	                    ++offset;
	                    if (isDoc) {
	                        setComment(start, offset - 2, isLeadingComment);
	                        isLeadingComment = true;
	                    }
	                    repeat = true;
	                } else {
	                    return "/";
	                }
	            }
	        } while (repeat);

	        // offset !== length if we got here

	        var end = offset;
	        delimRe.lastIndex = 0;
	        var delim = delimRe.test(charAt(end++));
	        if (!delim)
	            while (end < length && !delimRe.test(charAt(end)))
	                ++end;
	        var token = source.substring(offset, offset = end);
	        if (token === "\"" || token === "'")
	            stringDelim = token;
	        return token;
	    }

	    /**
	     * Pushes a token back to the stack.
	     * @param {string} token Token
	     * @returns {undefined}
	     * @inner
	     */
	    function push(token) {
	        stack.push(token);
	    }

	    /**
	     * Peeks for the next token.
	     * @returns {string|null} Token or `null` on eof
	     * @inner
	     */
	    function peek() {
	        if (!stack.length) {
	            var token = next();
	            if (token === null)
	                return null;
	            push(token);
	        }
	        return stack[0];
	    }

	    /**
	     * Skips a token.
	     * @param {string} expected Expected token
	     * @param {boolean} [optional=false] Whether the token is optional
	     * @returns {boolean} `true` when skipped, `false` if not
	     * @throws {Error} When a required token is not present
	     * @inner
	     */
	    function skip(expected, optional) {
	        var actual = peek(),
	            equals = actual === expected;
	        if (equals) {
	            next();
	            return true;
	        }
	        if (!optional)
	            throw illegal("token '" + actual + "', '" + expected + "' expected");
	        return false;
	    }

	    /**
	     * Gets a comment.
	     * @param {number} [trailingLine] Line number if looking for a trailing comment
	     * @returns {string|null} Comment text
	     * @inner
	     */
	    function cmnt(trailingLine) {
	        var ret = null;
	        var comment;
	        if (trailingLine === undefined) {
	            comment = comments[line - 1];
	            delete comments[line - 1];
	            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
	                ret = comment.leading ? comment.text : null;
	            }
	        } else {
	            /* istanbul ignore else */
	            if (lastCommentLine < trailingLine) {
	                peek();
	            }
	            comment = comments[trailingLine];
	            delete comments[trailingLine];
	            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
	                ret = comment.leading ? null : comment.text;
	            }
	        }
	        return ret;
	    }

	    return Object.defineProperty({
	        next: next,
	        peek: peek,
	        push: push,
	        skip: skip,
	        cmnt: cmnt
	    }, "line", {
	        get: function() { return line; }
	    });
	    /* eslint-enable callback-return */
	}
	return tokenize_1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	parse_1 = parse;

	parse.filename = null;
	parse.defaults = { keepCase: false };

	var tokenize  = requireTokenize(),
	    Root      = requireRoot(),
	    Type      = requireType(),
	    Field     = requireField(),
	    MapField  = requireMapfield(),
	    OneOf     = requireOneof(),
	    Enum      = require_enum(),
	    Service   = requireService(),
	    Method    = requireMethod(),
	    types     = requireTypes(),
	    util      = requireUtil$1();

	var base10Re    = /^[1-9][0-9]*$/,
	    base10NegRe = /^-?[1-9][0-9]*$/,
	    base16Re    = /^0[x][0-9a-fA-F]+$/,
	    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
	    base8Re     = /^0[0-7]+$/,
	    base8NegRe  = /^-?0[0-7]+$/,
	    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
	    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
	    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
	    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

	/**
	 * Result object returned from {@link parse}.
	 * @interface IParserResult
	 * @property {string|undefined} package Package name, if declared
	 * @property {string[]|undefined} imports Imports, if any
	 * @property {string[]|undefined} weakImports Weak imports, if any
	 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
	 * @property {Root} root Populated root instance
	 */

	/**
	 * Options modifying the behavior of {@link parse}.
	 * @interface IParseOptions
	 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
	 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
	 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
	 */

	/**
	 * Options modifying the behavior of JSON serialization.
	 * @interface IToJSONOptions
	 * @property {boolean} [keepComments=false] Serializes comments.
	 */

	/**
	 * Parses the given .proto source and returns an object with the parsed contents.
	 * @param {string} source Source contents
	 * @param {Root} root Root to populate
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {IParserResult} Parser result
	 * @property {string} filename=null Currently processing file name for error reporting, if known
	 * @property {IParseOptions} defaults Default {@link IParseOptions}
	 */
	function parse(source, root, options) {
	    /* eslint-disable callback-return */
	    if (!(root instanceof Root)) {
	        options = root;
	        root = new Root();
	    }
	    if (!options)
	        options = parse.defaults;

	    var preferTrailingComment = options.preferTrailingComment || false;
	    var tn = tokenize(source, options.alternateCommentMode || false),
	        next = tn.next,
	        push = tn.push,
	        peek = tn.peek,
	        skip = tn.skip,
	        cmnt = tn.cmnt;

	    var head = true,
	        pkg,
	        imports,
	        weakImports,
	        syntax,
	        isProto3 = false;

	    var ptr = root;

	    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

	    /* istanbul ignore next */
	    function illegal(token, name, insideTryCatch) {
	        var filename = parse.filename;
	        if (!insideTryCatch)
	            parse.filename = null;
	        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
	    }

	    function readString() {
	        var values = [],
	            token;
	        do {
	            /* istanbul ignore if */
	            if ((token = next()) !== "\"" && token !== "'")
	                throw illegal(token);

	            values.push(next());
	            skip(token);
	            token = peek();
	        } while (token === "\"" || token === "'");
	        return values.join("");
	    }

	    function readValue(acceptTypeRef) {
	        var token = next();
	        switch (token) {
	            case "'":
	            case "\"":
	                push(token);
	                return readString();
	            case "true": case "TRUE":
	                return true;
	            case "false": case "FALSE":
	                return false;
	        }
	        try {
	            return parseNumber(token, /* insideTryCatch */ true);
	        } catch (e) {

	            /* istanbul ignore else */
	            if (typeRefRe.test(token))
	                return token;

	            /* istanbul ignore next */
	            throw illegal(token, "value");
	        }
	    }

	    function readRanges(target, acceptStrings) {
	        var token, start;
	        do {
	            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
	                target.push(readString());
	            else
	                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
	        } while (skip(",", true));
	        skip(";");
	    }

	    function parseNumber(token, insideTryCatch) {
	        var sign = 1;
	        if (token.charAt(0) === "-") {
	            sign = -1;
	            token = token.substring(1);
	        }
	        switch (token) {
	            case "inf": case "INF": case "Inf":
	                return sign * Infinity;
	            case "nan": case "NAN": case "Nan": case "NaN":
	                return NaN;
	            case "0":
	                return 0;
	        }
	        if (base10Re.test(token))
	            return sign * parseInt(token, 10);
	        if (base16Re.test(token))
	            return sign * parseInt(token, 16);
	        if (base8Re.test(token))
	            return sign * parseInt(token, 8);

	        /* istanbul ignore else */
	        if (numberRe.test(token))
	            return sign * parseFloat(token);

	        /* istanbul ignore next */
	        throw illegal(token, "number", insideTryCatch);
	    }

	    function parseId(token, acceptNegative) {
	        switch (token) {
	            case "max": case "MAX": case "Max":
	                return 536870911;
	            case "0":
	                return 0;
	        }

	        /* istanbul ignore if */
	        if (!acceptNegative && token.charAt(0) === "-")
	            throw illegal(token, "id");

	        if (base10NegRe.test(token))
	            return parseInt(token, 10);
	        if (base16NegRe.test(token))
	            return parseInt(token, 16);

	        /* istanbul ignore else */
	        if (base8NegRe.test(token))
	            return parseInt(token, 8);

	        /* istanbul ignore next */
	        throw illegal(token, "id");
	    }

	    function parsePackage() {

	        /* istanbul ignore if */
	        if (pkg !== undefined)
	            throw illegal("package");

	        pkg = next();

	        /* istanbul ignore if */
	        if (!typeRefRe.test(pkg))
	            throw illegal(pkg, "name");

	        ptr = ptr.define(pkg);
	        skip(";");
	    }

	    function parseImport() {
	        var token = peek();
	        var whichImports;
	        switch (token) {
	            case "weak":
	                whichImports = weakImports || (weakImports = []);
	                next();
	                break;
	            case "public":
	                next();
	                // eslint-disable-next-line no-fallthrough
	            default:
	                whichImports = imports || (imports = []);
	                break;
	        }
	        token = readString();
	        skip(";");
	        whichImports.push(token);
	    }

	    function parseSyntax() {
	        skip("=");
	        syntax = readString();
	        isProto3 = syntax === "proto3";

	        /* istanbul ignore if */
	        if (!isProto3 && syntax !== "proto2")
	            throw illegal(syntax, "syntax");

	        skip(";");
	    }

	    function parseCommon(parent, token) {
	        switch (token) {

	            case "option":
	                parseOption(parent, token);
	                skip(";");
	                return true;

	            case "message":
	                parseType(parent, token);
	                return true;

	            case "enum":
	                parseEnum(parent, token);
	                return true;

	            case "service":
	                parseService(parent, token);
	                return true;

	            case "extend":
	                parseExtension(parent, token);
	                return true;
	        }
	        return false;
	    }

	    function ifBlock(obj, fnIf, fnElse) {
	        var trailingLine = tn.line;
	        if (obj) {
	            if(typeof obj.comment !== "string") {
	              obj.comment = cmnt(); // try block-type comment
	            }
	            obj.filename = parse.filename;
	        }
	        if (skip("{", true)) {
	            var token;
	            while ((token = next()) !== "}")
	                fnIf(token);
	            skip(";", true);
	        } else {
	            if (fnElse)
	                fnElse();
	            skip(";");
	            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
	                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
	        }
	    }

	    function parseType(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "type name");

	        var type = new Type(token);
	        ifBlock(type, function parseType_block(token) {
	            if (parseCommon(type, token))
	                return;

	            switch (token) {

	                case "map":
	                    parseMapField(type);
	                    break;

	                case "required":
	                case "repeated":
	                    parseField(type, token);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(type, "proto3_optional");
	                    } else {
	                        parseField(type, "optional");
	                    }
	                    break;

	                case "oneof":
	                    parseOneOf(type, token);
	                    break;

	                case "extensions":
	                    readRanges(type.extensions || (type.extensions = []));
	                    break;

	                case "reserved":
	                    readRanges(type.reserved || (type.reserved = []), true);
	                    break;

	                default:
	                    /* istanbul ignore if */
	                    if (!isProto3 || !typeRefRe.test(token))
	                        throw illegal(token);

	                    push(token);
	                    parseField(type, "optional");
	                    break;
	            }
	        });
	        parent.add(type);
	    }

	    function parseField(parent, rule, extend) {
	        var type = next();
	        if (type === "group") {
	            parseGroup(parent, rule);
	            return;
	        }
	        // Type names can consume multiple tokens, in multiple variants:
	        //    package.subpackage   field       tokens: "package.subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package . subpackage field       tokens: "package" "." "subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package.  subpackage field       tokens: "package." "subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package  .subpackage field       tokens: "package" ".subpackage" [TYPE NAME ENDS HERE] "field"
	        // Keep reading tokens until we get a type name with no period at the end,
	        // and the next token does not start with a period.
	        while (type.endsWith(".") || peek().startsWith(".")) {
	            type += next();
	        }

	        /* istanbul ignore if */
	        if (!typeRefRe.test(type))
	            throw illegal(type, "type");

	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        name = applyCase(name);
	        skip("=");

	        var field = new Field(name, parseId(next()), type, rule, extend);
	        ifBlock(field, function parseField_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(field, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseField_line() {
	            parseInlineOptions(field);
	        });

	        if (rule === "proto3_optional") {
	            // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
	            var oneof = new OneOf("_" + name);
	            field.setOption("proto3_optional", true);
	            oneof.add(field);
	            parent.add(oneof);
	        } else {
	            parent.add(field);
	        }

	        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
	        // parsing proto2 descriptors without the option, where applicable. This must be done for
	        // all known packable types and anything that could be an enum (= is not a basic type).
	        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
	            field.setOption("packed", false, /* ifNotSet */ true);
	    }

	    function parseGroup(parent, rule) {
	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        var fieldName = util.lcFirst(name);
	        if (name === fieldName)
	            name = util.ucFirst(name);
	        skip("=");
	        var id = parseId(next());
	        var type = new Type(name);
	        type.group = true;
	        var field = new Field(fieldName, id, name, rule);
	        field.filename = parse.filename;
	        ifBlock(type, function parseGroup_block(token) {
	            switch (token) {

	                case "option":
	                    parseOption(type, token);
	                    skip(";");
	                    break;

	                case "required":
	                case "repeated":
	                    parseField(type, token);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(type, "proto3_optional");
	                    } else {
	                        parseField(type, "optional");
	                    }
	                    break;

	                case "message":
	                    parseType(type, token);
	                    break;

	                case "enum":
	                    parseEnum(type, token);
	                    break;

	                /* istanbul ignore next */
	                default:
	                    throw illegal(token); // there are no groups with proto3 semantics
	            }
	        });
	        parent.add(type)
	              .add(field);
	    }

	    function parseMapField(parent) {
	        skip("<");
	        var keyType = next();

	        /* istanbul ignore if */
	        if (types.mapKey[keyType] === undefined)
	            throw illegal(keyType, "type");

	        skip(",");
	        var valueType = next();

	        /* istanbul ignore if */
	        if (!typeRefRe.test(valueType))
	            throw illegal(valueType, "type");

	        skip(">");
	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        skip("=");
	        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
	        ifBlock(field, function parseMapField_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(field, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseMapField_line() {
	            parseInlineOptions(field);
	        });
	        parent.add(field);
	    }

	    function parseOneOf(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var oneof = new OneOf(applyCase(token));
	        ifBlock(oneof, function parseOneOf_block(token) {
	            if (token === "option") {
	                parseOption(oneof, token);
	                skip(";");
	            } else {
	                push(token);
	                parseField(oneof, "optional");
	            }
	        });
	        parent.add(oneof);
	    }

	    function parseEnum(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var enm = new Enum(token);
	        ifBlock(enm, function parseEnum_block(token) {
	          switch(token) {
	            case "option":
	              parseOption(enm, token);
	              skip(";");
	              break;

	            case "reserved":
	              readRanges(enm.reserved || (enm.reserved = []), true);
	              break;

	            default:
	              parseEnumValue(enm, token);
	          }
	        });
	        parent.add(enm);
	    }

	    function parseEnumValue(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token))
	            throw illegal(token, "name");

	        skip("=");
	        var value = parseId(next(), true),
	            dummy = {
	                options: undefined
	            };
	        dummy.setOption = function(name, value) {
	            if (this.options === undefined)
	                this.options = {};
	            this.options[name] = value;
	        };
	        ifBlock(dummy, function parseEnumValue_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(dummy, token); // skip
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseEnumValue_line() {
	            parseInlineOptions(dummy); // skip
	        });
	        parent.add(token, value, dummy.comment, dummy.options);
	    }

	    function parseOption(parent, token) {
	        var isCustom = skip("(", true);

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token, "name");

	        var name = token;
	        var option = name;
	        var propName;

	        if (isCustom) {
	            skip(")");
	            name = "(" + name + ")";
	            option = name;
	            token = peek();
	            if (fqTypeRefRe.test(token)) {
	                propName = token.slice(1); //remove '.' before property name
	                name += token;
	                next();
	            }
	        }
	        skip("=");
	        var optionValue = parseOptionValue(parent, name);
	        setParsedOption(parent, option, optionValue, propName);
	    }

	    function parseOptionValue(parent, name) {
	        // { a: "foo" b { c: "bar" } }
	        if (skip("{", true)) {
	            var objectResult = {};

	            while (!skip("}", true)) {
	                /* istanbul ignore if */
	                if (!nameRe.test(token = next())) {
	                    throw illegal(token, "name");
	                }
	                if (token === null) {
	                  throw illegal(token, "end of input");
	                }

	                var value;
	                var propName = token;

	                skip(":", true);

	                if (peek() === "{")
	                    value = parseOptionValue(parent, name + "." + token);
	                else if (peek() === "[") {
	                    // option (my_option) = {
	                    //     repeated_value: [ "foo", "bar" ]
	                    // };
	                    value = [];
	                    var lastValue;
	                    if (skip("[", true)) {
	                        do {
	                            lastValue = readValue();
	                            value.push(lastValue);
	                        } while (skip(",", true));
	                        skip("]");
	                        if (typeof lastValue !== "undefined") {
	                            setOption(parent, name + "." + token, lastValue);
	                        }
	                    }
	                } else {
	                    value = readValue();
	                    setOption(parent, name + "." + token, value);
	                }

	                var prevValue = objectResult[propName];

	                if (prevValue)
	                    value = [].concat(prevValue).concat(value);

	                objectResult[propName] = value;

	                // Semicolons and commas can be optional
	                skip(",", true);
	                skip(";", true);
	            }

	            return objectResult;
	        }

	        var simpleValue = readValue();
	        setOption(parent, name, simpleValue);
	        return simpleValue;
	        // Does not enforce a delimiter to be universal
	    }

	    function setOption(parent, name, value) {
	        if (parent.setOption)
	            parent.setOption(name, value);
	    }

	    function setParsedOption(parent, name, value, propName) {
	        if (parent.setParsedOption)
	            parent.setParsedOption(name, value, propName);
	    }

	    function parseInlineOptions(parent) {
	        if (skip("[", true)) {
	            do {
	                parseOption(parent, "option");
	            } while (skip(",", true));
	            skip("]");
	        }
	        return parent;
	    }

	    function parseService(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "service name");

	        var service = new Service(token);
	        ifBlock(service, function parseService_block(token) {
	            if (parseCommon(service, token))
	                return;

	            /* istanbul ignore else */
	            if (token === "rpc")
	                parseMethod(service, token);
	            else
	                throw illegal(token);
	        });
	        parent.add(service);
	    }

	    function parseMethod(parent, token) {
	        // Get the comment of the preceding line now (if one exists) in case the
	        // method is defined across multiple lines.
	        var commentText = cmnt();

	        var type = token;

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var name = token,
	            requestType, requestStream,
	            responseType, responseStream;

	        skip("(");
	        if (skip("stream", true))
	            requestStream = true;

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token);

	        requestType = token;
	        skip(")"); skip("returns"); skip("(");
	        if (skip("stream", true))
	            responseStream = true;

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token);

	        responseType = token;
	        skip(")");

	        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
	        method.comment = commentText;
	        ifBlock(method, function parseMethod_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(method, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        });
	        parent.add(method);
	    }

	    function parseExtension(parent, token) {

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token, "reference");

	        var reference = token;
	        ifBlock(null, function parseExtension_block(token) {
	            switch (token) {

	                case "required":
	                case "repeated":
	                    parseField(parent, token, reference);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(parent, "proto3_optional", reference);
	                    } else {
	                        parseField(parent, "optional", reference);
	                    }
	                    break;

	                default:
	                    /* istanbul ignore if */
	                    if (!isProto3 || !typeRefRe.test(token))
	                        throw illegal(token);
	                    push(token);
	                    parseField(parent, "optional", reference);
	                    break;
	            }
	        });
	    }

	    var token;
	    while ((token = next()) !== null) {
	        switch (token) {

	            case "package":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parsePackage();
	                break;

	            case "import":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parseImport();
	                break;

	            case "syntax":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parseSyntax();
	                break;

	            case "option":

	                parseOption(ptr, token);
	                skip(";");
	                break;

	            default:

	                /* istanbul ignore else */
	                if (parseCommon(ptr, token)) {
	                    head = false;
	                    continue;
	                }

	                /* istanbul ignore next */
	                throw illegal(token);
	        }
	    }

	    parse.filename = null;
	    return {
	        "package"     : pkg,
	        "imports"     : imports,
	         weakImports  : weakImports,
	         syntax       : syntax,
	         root         : root
	    };
	}

	/**
	 * Parses the given .proto source and returns an object with the parsed contents.
	 * @name parse
	 * @function
	 * @param {string} source Source contents
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {IParserResult} Parser result
	 * @property {string} filename=null Currently processing file name for error reporting, if known
	 * @property {IParseOptions} defaults Default {@link IParseOptions}
	 * @variation 2
	 */
	return parse_1;
}

var common_1;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common_1;
	hasRequiredCommon = 1;
	common_1 = common;

	var commonRe = /\/|\./;

	/**
	 * Provides common type definitions.
	 * Can also be used to provide additional google types or your own custom types.
	 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
	 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
	 * @returns {undefined}
	 * @property {INamespace} google/protobuf/any.proto Any
	 * @property {INamespace} google/protobuf/duration.proto Duration
	 * @property {INamespace} google/protobuf/empty.proto Empty
	 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
	 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
	 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
	 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
	 * @example
	 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
	 * protobuf.common("descriptor", descriptorJson);
	 *
	 * // manually provides a custom definition (uses my.foo namespace)
	 * protobuf.common("my/foo/bar.proto", myFooBarJson);
	 */
	function common(name, json) {
	    if (!commonRe.test(name)) {
	        name = "google/protobuf/" + name + ".proto";
	        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
	    }
	    common[name] = json;
	}

	// Not provided because of limited use (feel free to discuss or to provide yourself):
	//
	// google/protobuf/descriptor.proto
	// google/protobuf/source_context.proto
	// google/protobuf/type.proto
	//
	// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
	// the repository or package within the google/protobuf directory.

	common("any", {

	    /**
	     * Properties of a google.protobuf.Any message.
	     * @interface IAny
	     * @type {Object}
	     * @property {string} [typeUrl]
	     * @property {Uint8Array} [bytes]
	     * @memberof common
	     */
	    Any: {
	        fields: {
	            type_url: {
	                type: "string",
	                id: 1
	            },
	            value: {
	                type: "bytes",
	                id: 2
	            }
	        }
	    }
	});

	var timeType;

	common("duration", {

	    /**
	     * Properties of a google.protobuf.Duration message.
	     * @interface IDuration
	     * @type {Object}
	     * @property {number|Long} [seconds]
	     * @property {number} [nanos]
	     * @memberof common
	     */
	    Duration: timeType = {
	        fields: {
	            seconds: {
	                type: "int64",
	                id: 1
	            },
	            nanos: {
	                type: "int32",
	                id: 2
	            }
	        }
	    }
	});

	common("timestamp", {

	    /**
	     * Properties of a google.protobuf.Timestamp message.
	     * @interface ITimestamp
	     * @type {Object}
	     * @property {number|Long} [seconds]
	     * @property {number} [nanos]
	     * @memberof common
	     */
	    Timestamp: timeType
	});

	common("empty", {

	    /**
	     * Properties of a google.protobuf.Empty message.
	     * @interface IEmpty
	     * @memberof common
	     */
	    Empty: {
	        fields: {}
	    }
	});

	common("struct", {

	    /**
	     * Properties of a google.protobuf.Struct message.
	     * @interface IStruct
	     * @type {Object}
	     * @property {Object.<string,IValue>} [fields]
	     * @memberof common
	     */
	    Struct: {
	        fields: {
	            fields: {
	                keyType: "string",
	                type: "Value",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Value message.
	     * @interface IValue
	     * @type {Object}
	     * @property {string} [kind]
	     * @property {0} [nullValue]
	     * @property {number} [numberValue]
	     * @property {string} [stringValue]
	     * @property {boolean} [boolValue]
	     * @property {IStruct} [structValue]
	     * @property {IListValue} [listValue]
	     * @memberof common
	     */
	    Value: {
	        oneofs: {
	            kind: {
	                oneof: [
	                    "nullValue",
	                    "numberValue",
	                    "stringValue",
	                    "boolValue",
	                    "structValue",
	                    "listValue"
	                ]
	            }
	        },
	        fields: {
	            nullValue: {
	                type: "NullValue",
	                id: 1
	            },
	            numberValue: {
	                type: "double",
	                id: 2
	            },
	            stringValue: {
	                type: "string",
	                id: 3
	            },
	            boolValue: {
	                type: "bool",
	                id: 4
	            },
	            structValue: {
	                type: "Struct",
	                id: 5
	            },
	            listValue: {
	                type: "ListValue",
	                id: 6
	            }
	        }
	    },

	    NullValue: {
	        values: {
	            NULL_VALUE: 0
	        }
	    },

	    /**
	     * Properties of a google.protobuf.ListValue message.
	     * @interface IListValue
	     * @type {Object}
	     * @property {Array.<IValue>} [values]
	     * @memberof common
	     */
	    ListValue: {
	        fields: {
	            values: {
	                rule: "repeated",
	                type: "Value",
	                id: 1
	            }
	        }
	    }
	});

	common("wrappers", {

	    /**
	     * Properties of a google.protobuf.DoubleValue message.
	     * @interface IDoubleValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    DoubleValue: {
	        fields: {
	            value: {
	                type: "double",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.FloatValue message.
	     * @interface IFloatValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    FloatValue: {
	        fields: {
	            value: {
	                type: "float",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Int64Value message.
	     * @interface IInt64Value
	     * @type {Object}
	     * @property {number|Long} [value]
	     * @memberof common
	     */
	    Int64Value: {
	        fields: {
	            value: {
	                type: "int64",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.UInt64Value message.
	     * @interface IUInt64Value
	     * @type {Object}
	     * @property {number|Long} [value]
	     * @memberof common
	     */
	    UInt64Value: {
	        fields: {
	            value: {
	                type: "uint64",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Int32Value message.
	     * @interface IInt32Value
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    Int32Value: {
	        fields: {
	            value: {
	                type: "int32",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.UInt32Value message.
	     * @interface IUInt32Value
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    UInt32Value: {
	        fields: {
	            value: {
	                type: "uint32",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.BoolValue message.
	     * @interface IBoolValue
	     * @type {Object}
	     * @property {boolean} [value]
	     * @memberof common
	     */
	    BoolValue: {
	        fields: {
	            value: {
	                type: "bool",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.StringValue message.
	     * @interface IStringValue
	     * @type {Object}
	     * @property {string} [value]
	     * @memberof common
	     */
	    StringValue: {
	        fields: {
	            value: {
	                type: "string",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.BytesValue message.
	     * @interface IBytesValue
	     * @type {Object}
	     * @property {Uint8Array} [value]
	     * @memberof common
	     */
	    BytesValue: {
	        fields: {
	            value: {
	                type: "bytes",
	                id: 1
	            }
	        }
	    }
	});

	common("field_mask", {

	    /**
	     * Properties of a google.protobuf.FieldMask message.
	     * @interface IDoubleValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    FieldMask: {
	        fields: {
	            paths: {
	                rule: "repeated",
	                type: "string",
	                id: 1
	            }
	        }
	    }
	});

	/**
	 * Gets the root definition of the specified common proto file.
	 *
	 * Bundled definitions are:
	 * - google/protobuf/any.proto
	 * - google/protobuf/duration.proto
	 * - google/protobuf/empty.proto
	 * - google/protobuf/field_mask.proto
	 * - google/protobuf/struct.proto
	 * - google/protobuf/timestamp.proto
	 * - google/protobuf/wrappers.proto
	 *
	 * @param {string} file Proto file name
	 * @returns {INamespace|null} Root definition or `null` if not defined
	 */
	common.get = function get(file) {
	    return common[file] || null;
	};
	return common_1;
}

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src.exports;
	hasRequiredSrc$1 = 1;
	var protobuf = src.exports = requireIndexLight();

	protobuf.build = "full";

	// Parser
	protobuf.tokenize         = requireTokenize();
	protobuf.parse            = requireParse();
	protobuf.common           = requireCommon();

	// Configure parser
	protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
	return src.exports;
}

var protobufjs;
var hasRequiredProtobufjs;

function requireProtobufjs () {
	if (hasRequiredProtobufjs) return protobufjs;
	hasRequiredProtobufjs = 1;
	protobufjs = requireSrc$1();
	return protobufjs;
}

var descriptor = {exports: {}};

var nested$3 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					FileDescriptorSet: {
						fields: {
							file: {
								rule: "repeated",
								type: "FileDescriptorProto",
								id: 1
							}
						}
					},
					FileDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							"package": {
								type: "string",
								id: 2
							},
							dependency: {
								rule: "repeated",
								type: "string",
								id: 3
							},
							publicDependency: {
								rule: "repeated",
								type: "int32",
								id: 10,
								options: {
									packed: false
								}
							},
							weakDependency: {
								rule: "repeated",
								type: "int32",
								id: 11,
								options: {
									packed: false
								}
							},
							messageType: {
								rule: "repeated",
								type: "DescriptorProto",
								id: 4
							},
							enumType: {
								rule: "repeated",
								type: "EnumDescriptorProto",
								id: 5
							},
							service: {
								rule: "repeated",
								type: "ServiceDescriptorProto",
								id: 6
							},
							extension: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 7
							},
							options: {
								type: "FileOptions",
								id: 8
							},
							sourceCodeInfo: {
								type: "SourceCodeInfo",
								id: 9
							},
							syntax: {
								type: "string",
								id: 12
							}
						}
					},
					DescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							field: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 2
							},
							extension: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 6
							},
							nestedType: {
								rule: "repeated",
								type: "DescriptorProto",
								id: 3
							},
							enumType: {
								rule: "repeated",
								type: "EnumDescriptorProto",
								id: 4
							},
							extensionRange: {
								rule: "repeated",
								type: "ExtensionRange",
								id: 5
							},
							oneofDecl: {
								rule: "repeated",
								type: "OneofDescriptorProto",
								id: 8
							},
							options: {
								type: "MessageOptions",
								id: 7
							},
							reservedRange: {
								rule: "repeated",
								type: "ReservedRange",
								id: 9
							},
							reservedName: {
								rule: "repeated",
								type: "string",
								id: 10
							}
						},
						nested: {
							ExtensionRange: {
								fields: {
									start: {
										type: "int32",
										id: 1
									},
									end: {
										type: "int32",
										id: 2
									}
								}
							},
							ReservedRange: {
								fields: {
									start: {
										type: "int32",
										id: 1
									},
									end: {
										type: "int32",
										id: 2
									}
								}
							}
						}
					},
					FieldDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 3
							},
							label: {
								type: "Label",
								id: 4
							},
							type: {
								type: "Type",
								id: 5
							},
							typeName: {
								type: "string",
								id: 6
							},
							extendee: {
								type: "string",
								id: 2
							},
							defaultValue: {
								type: "string",
								id: 7
							},
							oneofIndex: {
								type: "int32",
								id: 9
							},
							jsonName: {
								type: "string",
								id: 10
							},
							options: {
								type: "FieldOptions",
								id: 8
							}
						},
						nested: {
							Type: {
								values: {
									TYPE_DOUBLE: 1,
									TYPE_FLOAT: 2,
									TYPE_INT64: 3,
									TYPE_UINT64: 4,
									TYPE_INT32: 5,
									TYPE_FIXED64: 6,
									TYPE_FIXED32: 7,
									TYPE_BOOL: 8,
									TYPE_STRING: 9,
									TYPE_GROUP: 10,
									TYPE_MESSAGE: 11,
									TYPE_BYTES: 12,
									TYPE_UINT32: 13,
									TYPE_ENUM: 14,
									TYPE_SFIXED32: 15,
									TYPE_SFIXED64: 16,
									TYPE_SINT32: 17,
									TYPE_SINT64: 18
								}
							},
							Label: {
								values: {
									LABEL_OPTIONAL: 1,
									LABEL_REQUIRED: 2,
									LABEL_REPEATED: 3
								}
							}
						}
					},
					OneofDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							options: {
								type: "OneofOptions",
								id: 2
							}
						}
					},
					EnumDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								rule: "repeated",
								type: "EnumValueDescriptorProto",
								id: 2
							},
							options: {
								type: "EnumOptions",
								id: 3
							}
						}
					},
					EnumValueDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 2
							},
							options: {
								type: "EnumValueOptions",
								id: 3
							}
						}
					},
					ServiceDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							method: {
								rule: "repeated",
								type: "MethodDescriptorProto",
								id: 2
							},
							options: {
								type: "ServiceOptions",
								id: 3
							}
						}
					},
					MethodDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							inputType: {
								type: "string",
								id: 2
							},
							outputType: {
								type: "string",
								id: 3
							},
							options: {
								type: "MethodOptions",
								id: 4
							},
							clientStreaming: {
								type: "bool",
								id: 5
							},
							serverStreaming: {
								type: "bool",
								id: 6
							}
						}
					},
					FileOptions: {
						fields: {
							javaPackage: {
								type: "string",
								id: 1
							},
							javaOuterClassname: {
								type: "string",
								id: 8
							},
							javaMultipleFiles: {
								type: "bool",
								id: 10
							},
							javaGenerateEqualsAndHash: {
								type: "bool",
								id: 20,
								options: {
									deprecated: true
								}
							},
							javaStringCheckUtf8: {
								type: "bool",
								id: 27
							},
							optimizeFor: {
								type: "OptimizeMode",
								id: 9,
								options: {
									"default": "SPEED"
								}
							},
							goPackage: {
								type: "string",
								id: 11
							},
							ccGenericServices: {
								type: "bool",
								id: 16
							},
							javaGenericServices: {
								type: "bool",
								id: 17
							},
							pyGenericServices: {
								type: "bool",
								id: 18
							},
							deprecated: {
								type: "bool",
								id: 23
							},
							ccEnableArenas: {
								type: "bool",
								id: 31
							},
							objcClassPrefix: {
								type: "string",
								id: 36
							},
							csharpNamespace: {
								type: "string",
								id: 37
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								38,
								38
							]
						],
						nested: {
							OptimizeMode: {
								values: {
									SPEED: 1,
									CODE_SIZE: 2,
									LITE_RUNTIME: 3
								}
							}
						}
					},
					MessageOptions: {
						fields: {
							messageSetWireFormat: {
								type: "bool",
								id: 1
							},
							noStandardDescriptorAccessor: {
								type: "bool",
								id: 2
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							mapEntry: {
								type: "bool",
								id: 7
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								8,
								8
							]
						]
					},
					FieldOptions: {
						fields: {
							ctype: {
								type: "CType",
								id: 1,
								options: {
									"default": "STRING"
								}
							},
							packed: {
								type: "bool",
								id: 2
							},
							jstype: {
								type: "JSType",
								id: 6,
								options: {
									"default": "JS_NORMAL"
								}
							},
							lazy: {
								type: "bool",
								id: 5
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							weak: {
								type: "bool",
								id: 10
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								4,
								4
							]
						],
						nested: {
							CType: {
								values: {
									STRING: 0,
									CORD: 1,
									STRING_PIECE: 2
								}
							},
							JSType: {
								values: {
									JS_NORMAL: 0,
									JS_STRING: 1,
									JS_NUMBER: 2
								}
							}
						}
					},
					OneofOptions: {
						fields: {
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					EnumOptions: {
						fields: {
							allowAlias: {
								type: "bool",
								id: 2
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					EnumValueOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 1
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					ServiceOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 33
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					MethodOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 33
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					UninterpretedOption: {
						fields: {
							name: {
								rule: "repeated",
								type: "NamePart",
								id: 2
							},
							identifierValue: {
								type: "string",
								id: 3
							},
							positiveIntValue: {
								type: "uint64",
								id: 4
							},
							negativeIntValue: {
								type: "int64",
								id: 5
							},
							doubleValue: {
								type: "double",
								id: 6
							},
							stringValue: {
								type: "bytes",
								id: 7
							},
							aggregateValue: {
								type: "string",
								id: 8
							}
						},
						nested: {
							NamePart: {
								fields: {
									namePart: {
										rule: "required",
										type: "string",
										id: 1
									},
									isExtension: {
										rule: "required",
										type: "bool",
										id: 2
									}
								}
							}
						}
					},
					SourceCodeInfo: {
						fields: {
							location: {
								rule: "repeated",
								type: "Location",
								id: 1
							}
						},
						nested: {
							Location: {
								fields: {
									path: {
										rule: "repeated",
										type: "int32",
										id: 1
									},
									span: {
										rule: "repeated",
										type: "int32",
										id: 2
									},
									leadingComments: {
										type: "string",
										id: 3
									},
									trailingComments: {
										type: "string",
										id: 4
									},
									leadingDetachedComments: {
										rule: "repeated",
										type: "string",
										id: 6
									}
								}
							}
						}
					},
					GeneratedCodeInfo: {
						fields: {
							annotation: {
								rule: "repeated",
								type: "Annotation",
								id: 1
							}
						},
						nested: {
							Annotation: {
								fields: {
									path: {
										rule: "repeated",
										type: "int32",
										id: 1
									},
									sourceFile: {
										type: "string",
										id: 2
									},
									begin: {
										type: "int32",
										id: 3
									},
									end: {
										type: "int32",
										id: 4
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
var require$$4$1 = {
	nested: nested$3
};

var hasRequiredDescriptor;

function requireDescriptor () {
	if (hasRequiredDescriptor) return descriptor.exports;
	hasRequiredDescriptor = 1;
	(function (module, exports) {
		var $protobuf = requireProtobufjs();
		module.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require$$4$1).lookup(".google.protobuf");

		var Namespace = $protobuf.Namespace,
		    Root      = $protobuf.Root,
		    Enum      = $protobuf.Enum,
		    Type      = $protobuf.Type,
		    Field     = $protobuf.Field,
		    MapField  = $protobuf.MapField,
		    OneOf     = $protobuf.OneOf,
		    Service   = $protobuf.Service,
		    Method    = $protobuf.Method;

		// --- Root ---

		/**
		 * Properties of a FileDescriptorSet message.
		 * @interface IFileDescriptorSet
		 * @property {IFileDescriptorProto[]} file Files
		 */

		/**
		 * Properties of a FileDescriptorProto message.
		 * @interface IFileDescriptorProto
		 * @property {string} [name] File name
		 * @property {string} [package] Package
		 * @property {*} [dependency] Not supported
		 * @property {*} [publicDependency] Not supported
		 * @property {*} [weakDependency] Not supported
		 * @property {IDescriptorProto[]} [messageType] Nested message types
		 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
		 * @property {IServiceDescriptorProto[]} [service] Nested services
		 * @property {IFieldDescriptorProto[]} [extension] Nested extension fields
		 * @property {IFileOptions} [options] Options
		 * @property {*} [sourceCodeInfo] Not supported
		 * @property {string} [syntax="proto2"] Syntax
		 */

		/**
		 * Properties of a FileOptions message.
		 * @interface IFileOptions
		 * @property {string} [javaPackage]
		 * @property {string} [javaOuterClassname]
		 * @property {boolean} [javaMultipleFiles]
		 * @property {boolean} [javaGenerateEqualsAndHash]
		 * @property {boolean} [javaStringCheckUtf8]
		 * @property {IFileOptionsOptimizeMode} [optimizeFor=1]
		 * @property {string} [goPackage]
		 * @property {boolean} [ccGenericServices]
		 * @property {boolean} [javaGenericServices]
		 * @property {boolean} [pyGenericServices]
		 * @property {boolean} [deprecated]
		 * @property {boolean} [ccEnableArenas]
		 * @property {string} [objcClassPrefix]
		 * @property {string} [csharpNamespace]
		 */

		/**
		 * Values of he FileOptions.OptimizeMode enum.
		 * @typedef IFileOptionsOptimizeMode
		 * @type {number}
		 * @property {number} SPEED=1
		 * @property {number} CODE_SIZE=2
		 * @property {number} LITE_RUNTIME=3
		 */

		/**
		 * Creates a root from a descriptor set.
		 * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Root} Root instance
		 */
		Root.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.FileDescriptorSet.decode(descriptor);

		    var root = new Root();

		    if (descriptor.file) {
		        var fileDescriptor,
		            filePackage;
		        for (var j = 0, i; j < descriptor.file.length; ++j) {
		            filePackage = root;
		            if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
		                filePackage = root.define(fileDescriptor["package"]);
		            if (fileDescriptor.name && fileDescriptor.name.length)
		                root.files.push(filePackage.filename = fileDescriptor.name);
		            if (fileDescriptor.messageType)
		                for (i = 0; i < fileDescriptor.messageType.length; ++i)
		                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
		            if (fileDescriptor.enumType)
		                for (i = 0; i < fileDescriptor.enumType.length; ++i)
		                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
		            if (fileDescriptor.extension)
		                for (i = 0; i < fileDescriptor.extension.length; ++i)
		                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
		            if (fileDescriptor.service)
		                for (i = 0; i < fileDescriptor.service.length; ++i)
		                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
		            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);
		            if (opts) {
		                var ks = Object.keys(opts);
		                for (i = 0; i < ks.length; ++i)
		                    filePackage.setOption(ks[i], opts[ks[i]]);
		            }
		        }
		    }

		    return root;
		};

		/**
		 * Converts a root to a descriptor set.
		 * @returns {Message<IFileDescriptorSet>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Root.prototype.toDescriptor = function toDescriptor(syntax) {
		    var set = exports.FileDescriptorSet.create();
		    Root_toDescriptorRecursive(this, set.file, syntax);
		    return set;
		};

		// Traverses a namespace and assembles the descriptor set
		function Root_toDescriptorRecursive(ns, files, syntax) {

		    // Create a new file
		    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
		    if (syntax)
		        file.syntax = syntax;
		    if (!(ns instanceof Root))
		        file["package"] = ns.fullName.substring(1);

		    // Add nested types
		    for (var i = 0, nested; i < ns.nestedArray.length; ++i)
		        if ((nested = ns._nestedArray[i]) instanceof Type)
		            file.messageType.push(nested.toDescriptor(syntax));
		        else if (nested instanceof Enum)
		            file.enumType.push(nested.toDescriptor());
		        else if (nested instanceof Field)
		            file.extension.push(nested.toDescriptor(syntax));
		        else if (nested instanceof Service)
		            file.service.push(nested.toDescriptor());
		        else if (nested instanceof /* plain */ Namespace)
		            Root_toDescriptorRecursive(nested, files, syntax); // requires new file

		    // Keep package-level options
		    file.options = toDescriptorOptions(ns.options, exports.FileOptions);

		    // And keep the file only if there is at least one nested object
		    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
		        files.push(file);
		}

		// --- Type ---

		/**
		 * Properties of a DescriptorProto message.
		 * @interface IDescriptorProto
		 * @property {string} [name] Message type name
		 * @property {IFieldDescriptorProto[]} [field] Fields
		 * @property {IFieldDescriptorProto[]} [extension] Extension fields
		 * @property {IDescriptorProto[]} [nestedType] Nested message types
		 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
		 * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges
		 * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs
		 * @property {IMessageOptions} [options] Not supported
		 * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges
		 * @property {string[]} [reservedName] Reserved names
		 */

		/**
		 * Properties of a MessageOptions message.
		 * @interface IMessageOptions
		 * @property {boolean} [mapEntry=false] Whether this message is a map entry
		 */

		/**
		 * Properties of an ExtensionRange message.
		 * @interface IDescriptorProtoExtensionRange
		 * @property {number} [start] Start field id
		 * @property {number} [end] End field id
		 */

		/**
		 * Properties of a ReservedRange message.
		 * @interface IDescriptorProtoReservedRange
		 * @property {number} [start] Start field id
		 * @property {number} [end] End field id
		 */

		var unnamedMessageIndex = 0;

		/**
		 * Creates a type from a descriptor.
		 * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 * @returns {Type} Type instance
		 */
		Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.DescriptorProto.decode(descriptor);

		    // Create the message type
		    var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),
		        i;

		    /* Oneofs */ if (descriptor.oneofDecl)
		        for (i = 0; i < descriptor.oneofDecl.length; ++i)
		            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
		    /* Fields */ if (descriptor.field)
		        for (i = 0; i < descriptor.field.length; ++i) {
		            var field = Field.fromDescriptor(descriptor.field[i], syntax);
		            type.add(field);
		            if (descriptor.field[i].hasOwnProperty("oneofIndex")) // eslint-disable-line no-prototype-builtins
		                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
		        }
		    /* Extension fields */ if (descriptor.extension)
		        for (i = 0; i < descriptor.extension.length; ++i)
		            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
		    /* Nested types */ if (descriptor.nestedType)
		        for (i = 0; i < descriptor.nestedType.length; ++i) {
		            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
		            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
		                type.setOption("map_entry", true);
		        }
		    /* Nested enums */ if (descriptor.enumType)
		        for (i = 0; i < descriptor.enumType.length; ++i)
		            type.add(Enum.fromDescriptor(descriptor.enumType[i]));
		    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {
		        type.extensions = [];
		        for (i = 0; i < descriptor.extensionRange.length; ++i)
		            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);
		    }
		    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
		        type.reserved = [];
		        /* Ranges */ if (descriptor.reservedRange)
		            for (i = 0; i < descriptor.reservedRange.length; ++i)
		                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);
		        /* Names */ if (descriptor.reservedName)
		            for (i = 0; i < descriptor.reservedName.length; ++i)
		                type.reserved.push(descriptor.reservedName[i]);
		    }

		    return type;
		};

		/**
		 * Converts a type to a descriptor.
		 * @returns {Message<IDescriptorProto>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Type.prototype.toDescriptor = function toDescriptor(syntax) {
		    var descriptor = exports.DescriptorProto.create({ name: this.name }),
		        i;

		    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {
		        var fieldDescriptor;
		        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
		        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry
		            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),
		                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),
		                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14
		                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type
		                    : undefined;
		            descriptor.nestedType.push(exports.DescriptorProto.create({
		                name: fieldDescriptor.typeName,
		                field: [
		                    exports.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }), // can't reference a type or enum
		                    exports.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
		                ],
		                options: exports.MessageOptions.create({ mapEntry: true })
		            }));
		        }
		    }
		    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)
		        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
		    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {
		        /* Extension fields */ if (this._nestedArray[i] instanceof Field)
		            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
		        /* Types */ else if (this._nestedArray[i] instanceof Type)
		            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
		        /* Enums */ else if (this._nestedArray[i] instanceof Enum)
		            descriptor.enumType.push(this._nestedArray[i].toDescriptor());
		        // plain nested namespaces become packages instead in Root#toDescriptor
		    }
		    /* Extension ranges */ if (this.extensions)
		        for (i = 0; i < this.extensions.length; ++i)
		            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
		    /* Reserved... */ if (this.reserved)
		        for (i = 0; i < this.reserved.length; ++i)
		            /* Names */ if (typeof this.reserved[i] === "string")
		                descriptor.reservedName.push(this.reserved[i]);
		            /* Ranges */ else
		                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));

		    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);

		    return descriptor;
		};

		// --- Field ---

		/**
		 * Properties of a FieldDescriptorProto message.
		 * @interface IFieldDescriptorProto
		 * @property {string} [name] Field name
		 * @property {number} [number] Field id
		 * @property {IFieldDescriptorProtoLabel} [label] Field rule
		 * @property {IFieldDescriptorProtoType} [type] Field basic type
		 * @property {string} [typeName] Field type name
		 * @property {string} [extendee] Extended type name
		 * @property {string} [defaultValue] Literal default value
		 * @property {number} [oneofIndex] Oneof index if part of a oneof
		 * @property {*} [jsonName] Not supported
		 * @property {IFieldOptions} [options] Field options
		 */

		/**
		 * Values of the FieldDescriptorProto.Label enum.
		 * @typedef IFieldDescriptorProtoLabel
		 * @type {number}
		 * @property {number} LABEL_OPTIONAL=1
		 * @property {number} LABEL_REQUIRED=2
		 * @property {number} LABEL_REPEATED=3
		 */

		/**
		 * Values of the FieldDescriptorProto.Type enum.
		 * @typedef IFieldDescriptorProtoType
		 * @type {number}
		 * @property {number} TYPE_DOUBLE=1
		 * @property {number} TYPE_FLOAT=2
		 * @property {number} TYPE_INT64=3
		 * @property {number} TYPE_UINT64=4
		 * @property {number} TYPE_INT32=5
		 * @property {number} TYPE_FIXED64=6
		 * @property {number} TYPE_FIXED32=7
		 * @property {number} TYPE_BOOL=8
		 * @property {number} TYPE_STRING=9
		 * @property {number} TYPE_GROUP=10
		 * @property {number} TYPE_MESSAGE=11
		 * @property {number} TYPE_BYTES=12
		 * @property {number} TYPE_UINT32=13
		 * @property {number} TYPE_ENUM=14
		 * @property {number} TYPE_SFIXED32=15
		 * @property {number} TYPE_SFIXED64=16
		 * @property {number} TYPE_SINT32=17
		 * @property {number} TYPE_SINT64=18
		 */

		/**
		 * Properties of a FieldOptions message.
		 * @interface IFieldOptions
		 * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)
		 * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)
		 */

		/**
		 * Values of the FieldOptions.JSType enum.
		 * @typedef IFieldOptionsJSType
		 * @type {number}
		 * @property {number} JS_NORMAL=0
		 * @property {number} JS_STRING=1
		 * @property {number} JS_NUMBER=2
		 */

		// copied here from parse.js
		var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;

		/**
		 * Creates a field from a descriptor.
		 * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 * @returns {Field} Field instance
		 */
		Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.DescriptorProto.decode(descriptor);

		    if (typeof descriptor.number !== "number")
		        throw Error("missing field id");

		    // Rewire field type
		    var fieldType;
		    if (descriptor.typeName && descriptor.typeName.length)
		        fieldType = descriptor.typeName;
		    else
		        fieldType = fromDescriptorType(descriptor.type);

		    // Rewire field rule
		    var fieldRule;
		    switch (descriptor.label) {
		        // 0 is reserved for errors
		        case 1: fieldRule = undefined; break;
		        case 2: fieldRule = "required"; break;
		        case 3: fieldRule = "repeated"; break;
		        default: throw Error("illegal label: " + descriptor.label);
		    }

			var extendee = descriptor.extendee;
			if (descriptor.extendee !== undefined) {
				extendee = extendee.length ? extendee : undefined;
			}
		    var field = new Field(
		        descriptor.name.length ? descriptor.name : "field" + descriptor.number,
		        descriptor.number,
		        fieldType,
		        fieldRule,
		        extendee
		    );

		    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);

		    if (descriptor.defaultValue && descriptor.defaultValue.length) {
		        var defaultValue = descriptor.defaultValue;
		        switch (defaultValue) {
		            case "true": case "TRUE":
		                defaultValue = true;
		                break;
		            case "false": case "FALSE":
		                defaultValue = false;
		                break;
		            default:
		                var match = numberRe.exec(defaultValue);
		                if (match)
		                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix
		                break;
		        }
		        field.setOption("default", defaultValue);
		    }

		    if (packableDescriptorType(descriptor.type)) {
		        if (syntax === "proto3") { // defaults to packed=true (internal preset is packed=true)
		            if (descriptor.options && !descriptor.options.packed)
		                field.setOption("packed", false);
		        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false
		            field.setOption("packed", false);
		    }

		    return field;
		};

		/**
		 * Converts a field to a descriptor.
		 * @returns {Message<IFieldDescriptorProto>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Field.prototype.toDescriptor = function toDescriptor(syntax) {
		    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });

		    if (this.map) {

		        descriptor.type = 11; // message
		        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)
		        descriptor.label = 3; // repeated

		    } else {

		        // Rewire field type
		        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
		            case 10: // group
		            case 11: // type
		            case 14: // enum
		                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
		                break;
		        }

		        // Rewire field rule
		        switch (this.rule) {
		            case "repeated": descriptor.label = 3; break;
		            case "required": descriptor.label = 2; break;
		            default: descriptor.label = 1; break;
		        }

		    }

		    // Handle extension field
		    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;

		    // Handle part of oneof
		    if (this.partOf)
		        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
		            throw Error("missing oneof");

		    if (this.options) {
		        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);
		        if (this.options["default"] != null)
		            descriptor.defaultValue = String(this.options["default"]);
		    }

		    if (syntax === "proto3") { // defaults to packed=true
		        if (!this.packed)
		            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;
		    } else if (this.packed) // defaults to packed=false
		        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;

		    return descriptor;
		};

		// --- Enum ---

		/**
		 * Properties of an EnumDescriptorProto message.
		 * @interface IEnumDescriptorProto
		 * @property {string} [name] Enum name
		 * @property {IEnumValueDescriptorProto[]} [value] Enum values
		 * @property {IEnumOptions} [options] Enum options
		 */

		/**
		 * Properties of an EnumValueDescriptorProto message.
		 * @interface IEnumValueDescriptorProto
		 * @property {string} [name] Name
		 * @property {number} [number] Value
		 * @property {*} [options] Not supported
		 */

		/**
		 * Properties of an EnumOptions message.
		 * @interface IEnumOptions
		 * @property {boolean} [allowAlias] Whether aliases are allowed
		 * @property {boolean} [deprecated]
		 */

		var unnamedEnumIndex = 0;

		/**
		 * Creates an enum from a descriptor.
		 * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Enum} Enum instance
		 */
		Enum.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.EnumDescriptorProto.decode(descriptor);

		    // Construct values object
		    var values = {};
		    if (descriptor.value)
		        for (var i = 0; i < descriptor.value.length; ++i) {
		            var name  = descriptor.value[i].name,
		                value = descriptor.value[i].number || 0;
		            values[name && name.length ? name : "NAME" + value] = value;
		        }

		    return new Enum(
		        descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++,
		        values,
		        fromDescriptorOptions(descriptor.options, exports.EnumOptions)
		    );
		};

		/**
		 * Converts an enum to a descriptor.
		 * @returns {Message<IEnumDescriptorProto>} Descriptor
		 */
		Enum.prototype.toDescriptor = function toDescriptor() {

		    // Values
		    var values = [];
		    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
		        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));

		    return exports.EnumDescriptorProto.create({
		        name: this.name,
		        value: values,
		        options: toDescriptorOptions(this.options, exports.EnumOptions)
		    });
		};

		// --- OneOf ---

		/**
		 * Properties of a OneofDescriptorProto message.
		 * @interface IOneofDescriptorProto
		 * @property {string} [name] Oneof name
		 * @property {*} [options] Not supported
		 */

		var unnamedOneofIndex = 0;

		/**
		 * Creates a oneof from a descriptor.
		 * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {OneOf} OneOf instance
		 */
		OneOf.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.OneofDescriptorProto.decode(descriptor);

		    return new OneOf(
		        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here
		        descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++
		        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option
		    );
		};

		/**
		 * Converts a oneof to a descriptor.
		 * @returns {Message<IOneofDescriptorProto>} Descriptor
		 */
		OneOf.prototype.toDescriptor = function toDescriptor() {
		    return exports.OneofDescriptorProto.create({
		        name: this.name
		        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option
		    });
		};

		// --- Service ---

		/**
		 * Properties of a ServiceDescriptorProto message.
		 * @interface IServiceDescriptorProto
		 * @property {string} [name] Service name
		 * @property {IMethodDescriptorProto[]} [method] Methods
		 * @property {IServiceOptions} [options] Options
		 */

		/**
		 * Properties of a ServiceOptions message.
		 * @interface IServiceOptions
		 * @property {boolean} [deprecated]
		 */

		var unnamedServiceIndex = 0;

		/**
		 * Creates a service from a descriptor.
		 * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Service} Service instance
		 */
		Service.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.ServiceDescriptorProto.decode(descriptor);

		    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));
		    if (descriptor.method)
		        for (var i = 0; i < descriptor.method.length; ++i)
		            service.add(Method.fromDescriptor(descriptor.method[i]));

		    return service;
		};

		/**
		 * Converts a service to a descriptor.
		 * @returns {Message<IServiceDescriptorProto>} Descriptor
		 */
		Service.prototype.toDescriptor = function toDescriptor() {

		    // Methods
		    var methods = [];
		    for (var i = 0; i < this.methodsArray.length; ++i)
		        methods.push(this._methodsArray[i].toDescriptor());

		    return exports.ServiceDescriptorProto.create({
		        name: this.name,
		        method: methods,
		        options: toDescriptorOptions(this.options, exports.ServiceOptions)
		    });
		};

		// --- Method ---

		/**
		 * Properties of a MethodDescriptorProto message.
		 * @interface IMethodDescriptorProto
		 * @property {string} [name] Method name
		 * @property {string} [inputType] Request type name
		 * @property {string} [outputType] Response type name
		 * @property {IMethodOptions} [options] Not supported
		 * @property {boolean} [clientStreaming=false] Whether requests are streamed
		 * @property {boolean} [serverStreaming=false] Whether responses are streamed
		 */

		/**
		 * Properties of a MethodOptions message.
		 * @interface IMethodOptions
		 * @property {boolean} [deprecated]
		 */

		var unnamedMethodIndex = 0;

		/**
		 * Creates a method from a descriptor.
		 * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Method} Reflected method instance
		 */
		Method.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.MethodDescriptorProto.decode(descriptor);

		    return new Method(
		        // unnamedMethodIndex is global, not per service, because we have no ref to a service here
		        descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++,
		        "rpc",
		        descriptor.inputType,
		        descriptor.outputType,
		        Boolean(descriptor.clientStreaming),
		        Boolean(descriptor.serverStreaming),
		        fromDescriptorOptions(descriptor.options, exports.MethodOptions)
		    );
		};

		/**
		 * Converts a method to a descriptor.
		 * @returns {Message<IMethodDescriptorProto>} Descriptor
		 */
		Method.prototype.toDescriptor = function toDescriptor() {
		    return exports.MethodDescriptorProto.create({
		        name: this.name,
		        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
		        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
		        clientStreaming: this.requestStream,
		        serverStreaming: this.responseStream,
		        options: toDescriptorOptions(this.options, exports.MethodOptions)
		    });
		};

		// --- utility ---

		// Converts a descriptor type to a protobuf.js basic type
		function fromDescriptorType(type) {
		    switch (type) {
		        // 0 is reserved for errors
		        case 1: return "double";
		        case 2: return "float";
		        case 3: return "int64";
		        case 4: return "uint64";
		        case 5: return "int32";
		        case 6: return "fixed64";
		        case 7: return "fixed32";
		        case 8: return "bool";
		        case 9: return "string";
		        case 12: return "bytes";
		        case 13: return "uint32";
		        case 15: return "sfixed32";
		        case 16: return "sfixed64";
		        case 17: return "sint32";
		        case 18: return "sint64";
		    }
		    throw Error("illegal type: " + type);
		}

		// Tests if a descriptor type is packable
		function packableDescriptorType(type) {
		    switch (type) {
		        case 1: // double
		        case 2: // float
		        case 3: // int64
		        case 4: // uint64
		        case 5: // int32
		        case 6: // fixed64
		        case 7: // fixed32
		        case 8: // bool
		        case 13: // uint32
		        case 14: // enum (!)
		        case 15: // sfixed32
		        case 16: // sfixed64
		        case 17: // sint32
		        case 18: // sint64
		            return true;
		    }
		    return false;
		}

		// Converts a protobuf.js basic type to a descriptor type
		function toDescriptorType(type, resolvedType) {
		    switch (type) {
		        // 0 is reserved for errors
		        case "double": return 1;
		        case "float": return 2;
		        case "int64": return 3;
		        case "uint64": return 4;
		        case "int32": return 5;
		        case "fixed64": return 6;
		        case "fixed32": return 7;
		        case "bool": return 8;
		        case "string": return 9;
		        case "bytes": return 12;
		        case "uint32": return 13;
		        case "sfixed32": return 15;
		        case "sfixed64": return 16;
		        case "sint32": return 17;
		        case "sint64": return 18;
		    }
		    if (resolvedType instanceof Enum)
		        return 14;
		    if (resolvedType instanceof Type)
		        return resolvedType.group ? 10 : 11;
		    throw Error("illegal type: " + type);
		}

		// Converts descriptor options to an options object
		function fromDescriptorOptions(options, type) {
		    if (!options)
		        return undefined;
		    var out = [];
		    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
		        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption")
		            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins
		                val = options[key];
		                if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== undefined)
		                    val = field.resolvedType.valuesById[val];
		                out.push(underScore(key), val);
		            }
		    return out.length ? $protobuf.util.toObject(out) : undefined;
		}

		// Converts an options object to descriptor options
		function toDescriptorOptions(options, type) {
		    if (!options)
		        return undefined;
		    var out = [];
		    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
		        val = options[key = ks[i]];
		        if (key === "default")
		            continue;
		        var field = type.fields[key];
		        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
		            continue;
		        out.push(key, val);
		    }
		    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;
		}

		// Calculates the shortest relative path from `from` to `to`.
		function shortname(from, to) {
		    var fromPath = from.fullName.split("."),
		        toPath = to.fullName.split("."),
		        i = 0,
		        j = 0,
		        k = toPath.length - 1;
		    if (!(from instanceof Root) && to instanceof Namespace)
		        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
		            var other = to.lookup(fromPath[i++], true);
		            if (other !== null && other !== to)
		                break;
		            ++j;
		        }
		    else
		        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);
		    return toPath.slice(j).join(".");
		}

		// copied here from cli/targets/proto.js
		function underScore(str) {
		    return str.substring(0,1)
		         + str.substring(1)
		               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return "_" + $1.toLowerCase(); });
		}

		// --- exports ---

		/**
		 * Reflected file descriptor set.
		 * @name FileDescriptorSet
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected file descriptor proto.
		 * @name FileDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected descriptor proto.
		 * @name DescriptorProto
		 * @type {Type}
		 * @property {Type} ExtensionRange
		 * @property {Type} ReservedRange
		 * @const
		 * @tstype $protobuf.Type & {
		 *     ExtensionRange: $protobuf.Type,
		 *     ReservedRange: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected field descriptor proto.
		 * @name FieldDescriptorProto
		 * @type {Type}
		 * @property {Enum} Label
		 * @property {Enum} Type
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Label: $protobuf.Enum,
		 *     Type: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected oneof descriptor proto.
		 * @name OneofDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum descriptor proto.
		 * @name EnumDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected service descriptor proto.
		 * @name ServiceDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum value descriptor proto.
		 * @name EnumValueDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected method descriptor proto.
		 * @name MethodDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected file options.
		 * @name FileOptions
		 * @type {Type}
		 * @property {Enum} OptimizeMode
		 * @const
		 * @tstype $protobuf.Type & {
		 *     OptimizeMode: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected message options.
		 * @name MessageOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected field options.
		 * @name FieldOptions
		 * @type {Type}
		 * @property {Enum} CType
		 * @property {Enum} JSType
		 * @const
		 * @tstype $protobuf.Type & {
		 *     CType: $protobuf.Enum,
		 *     JSType: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected oneof options.
		 * @name OneofOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum options.
		 * @name EnumOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum value options.
		 * @name EnumValueOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected service options.
		 * @name ServiceOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected method options.
		 * @name MethodOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected uninterpretet option.
		 * @name UninterpretedOption
		 * @type {Type}
		 * @property {Type} NamePart
		 * @const
		 * @tstype $protobuf.Type & {
		 *     NamePart: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected source code info.
		 * @name SourceCodeInfo
		 * @type {Type}
		 * @property {Type} Location
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Location: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected generated code info.
		 * @name GeneratedCodeInfo
		 * @type {Type}
		 * @property {Type} Annotation
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Annotation: $protobuf.Type
		 * }
		 */ 
	} (descriptor, descriptor.exports));
	return descriptor.exports;
}

var util$1 = {};

var nested$2 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					Api: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							methods: {
								rule: "repeated",
								type: "Method",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							},
							version: {
								type: "string",
								id: 4
							},
							sourceContext: {
								type: "SourceContext",
								id: 5
							},
							mixins: {
								rule: "repeated",
								type: "Mixin",
								id: 6
							},
							syntax: {
								type: "Syntax",
								id: 7
							}
						}
					},
					Method: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							requestTypeUrl: {
								type: "string",
								id: 2
							},
							requestStreaming: {
								type: "bool",
								id: 3
							},
							responseTypeUrl: {
								type: "string",
								id: 4
							},
							responseStreaming: {
								type: "bool",
								id: 5
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 6
							},
							syntax: {
								type: "Syntax",
								id: 7
							}
						}
					},
					Mixin: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							root: {
								type: "string",
								id: 2
							}
						}
					},
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					},
					Option: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								type: "Any",
								id: 2
							}
						}
					},
					Syntax: {
						values: {
							SYNTAX_PROTO2: 0,
							SYNTAX_PROTO3: 1
						}
					}
				}
			}
		}
	}
};
var require$$3 = {
	nested: nested$2
};

var nested$1 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					}
				}
			}
		}
	}
};
var require$$5 = {
	nested: nested$1
};

var nested = {
	google: {
		nested: {
			protobuf: {
				nested: {
					Type: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							fields: {
								rule: "repeated",
								type: "Field",
								id: 2
							},
							oneofs: {
								rule: "repeated",
								type: "string",
								id: 3
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 4
							},
							sourceContext: {
								type: "SourceContext",
								id: 5
							},
							syntax: {
								type: "Syntax",
								id: 6
							}
						}
					},
					Field: {
						fields: {
							kind: {
								type: "Kind",
								id: 1
							},
							cardinality: {
								type: "Cardinality",
								id: 2
							},
							number: {
								type: "int32",
								id: 3
							},
							name: {
								type: "string",
								id: 4
							},
							typeUrl: {
								type: "string",
								id: 6
							},
							oneofIndex: {
								type: "int32",
								id: 7
							},
							packed: {
								type: "bool",
								id: 8
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 9
							},
							jsonName: {
								type: "string",
								id: 10
							},
							defaultValue: {
								type: "string",
								id: 11
							}
						},
						nested: {
							Kind: {
								values: {
									TYPE_UNKNOWN: 0,
									TYPE_DOUBLE: 1,
									TYPE_FLOAT: 2,
									TYPE_INT64: 3,
									TYPE_UINT64: 4,
									TYPE_INT32: 5,
									TYPE_FIXED64: 6,
									TYPE_FIXED32: 7,
									TYPE_BOOL: 8,
									TYPE_STRING: 9,
									TYPE_GROUP: 10,
									TYPE_MESSAGE: 11,
									TYPE_BYTES: 12,
									TYPE_UINT32: 13,
									TYPE_ENUM: 14,
									TYPE_SFIXED32: 15,
									TYPE_SFIXED64: 16,
									TYPE_SINT32: 17,
									TYPE_SINT64: 18
								}
							},
							Cardinality: {
								values: {
									CARDINALITY_UNKNOWN: 0,
									CARDINALITY_OPTIONAL: 1,
									CARDINALITY_REQUIRED: 2,
									CARDINALITY_REPEATED: 3
								}
							}
						}
					},
					Enum: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							enumvalue: {
								rule: "repeated",
								type: "EnumValue",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							},
							sourceContext: {
								type: "SourceContext",
								id: 4
							},
							syntax: {
								type: "Syntax",
								id: 5
							}
						}
					},
					EnumValue: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							}
						}
					},
					Option: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								type: "Any",
								id: 2
							}
						}
					},
					Syntax: {
						values: {
							SYNTAX_PROTO2: 0,
							SYNTAX_PROTO3: 1
						}
					},
					Any: {
						fields: {
							type_url: {
								type: "string",
								id: 1
							},
							value: {
								type: "bytes",
								id: 2
							}
						}
					},
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					}
				}
			}
		}
	}
};
var require$$6 = {
	nested: nested
};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util$1;
	hasRequiredUtil = 1;
	/**
	 * @license
	 * Copyright 2018 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(util$1, "__esModule", { value: true });
	util$1.addCommonProtos = util$1.loadProtosWithOptionsSync = util$1.loadProtosWithOptions = void 0;
	const fs = require$$0;
	const path = require$$1$3;
	const Protobuf = requireProtobufjs();
	function addIncludePathResolver(root, includePaths) {
	    const originalResolvePath = root.resolvePath;
	    root.resolvePath = (origin, target) => {
	        if (path.isAbsolute(target)) {
	            return target;
	        }
	        for (const directory of includePaths) {
	            const fullPath = path.join(directory, target);
	            try {
	                fs.accessSync(fullPath, fs.constants.R_OK);
	                return fullPath;
	            }
	            catch (err) {
	                continue;
	            }
	        }
	        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
	        return originalResolvePath(origin, target);
	    };
	}
	async function loadProtosWithOptions(filename, options) {
	    const root = new Protobuf.Root();
	    options = options || {};
	    if (!!options.includeDirs) {
	        if (!Array.isArray(options.includeDirs)) {
	            return Promise.reject(new Error('The includeDirs option must be an array'));
	        }
	        addIncludePathResolver(root, options.includeDirs);
	    }
	    const loadedRoot = await root.load(filename, options);
	    loadedRoot.resolveAll();
	    return loadedRoot;
	}
	util$1.loadProtosWithOptions = loadProtosWithOptions;
	function loadProtosWithOptionsSync(filename, options) {
	    const root = new Protobuf.Root();
	    options = options || {};
	    if (!!options.includeDirs) {
	        if (!Array.isArray(options.includeDirs)) {
	            throw new Error('The includeDirs option must be an array');
	        }
	        addIncludePathResolver(root, options.includeDirs);
	    }
	    const loadedRoot = root.loadSync(filename, options);
	    loadedRoot.resolveAll();
	    return loadedRoot;
	}
	util$1.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
	/**
	 * Load Google's well-known proto files that aren't exposed by Protobuf.js.
	 */
	function addCommonProtos() {
	    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,
	    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.
	    // Using constant strings for compatibility with tools like Webpack
	    const apiDescriptor = require$$3;
	    const descriptorDescriptor = require$$4$1;
	    const sourceContextDescriptor = require$$5;
	    const typeDescriptor = require$$6;
	    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);
	}
	util$1.addCommonProtos = addCommonProtos;
	
	return util$1;
}

var umd = {exports: {}};

var hasRequiredUmd;

function requireUmd () {
	if (hasRequiredUmd) return umd.exports;
	hasRequiredUmd = 1;
	(function (module, exports) {
		// GENERATED FILE. DO NOT EDIT.
		var Long = (function(exports) {
		  
		  Object.defineProperty(exports, "__esModule", {
		    value: true
		  });
		  exports.default = void 0;
		  
		  /**
		   * @license
		   * Copyright 2009 The Closure Library Authors
		   * Copyright 2020 Daniel Wirtz / The long.js Authors.
		   *
		   * Licensed under the Apache License, Version 2.0 (the "License");
		   * you may not use this file except in compliance with the License.
		   * You may obtain a copy of the License at
		   *
		   *     http://www.apache.org/licenses/LICENSE-2.0
		   *
		   * Unless required by applicable law or agreed to in writing, software
		   * distributed under the License is distributed on an "AS IS" BASIS,
		   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		   * See the License for the specific language governing permissions and
		   * limitations under the License.
		   *
		   * SPDX-License-Identifier: Apache-2.0
		   */
		  // WebAssembly optimizations to do native i64 multiplication and divide
		  var wasm = null;
		  
		  try {
		    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
		  } catch (e) {// no wasm support :(
		  }
		  /**
		   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
		   *  See the from* functions below for more convenient ways of constructing Longs.
		   * @exports Long
		   * @class A Long class for representing a 64 bit two's-complement integer value.
		   * @param {number} low The low (signed) 32 bits of the long
		   * @param {number} high The high (signed) 32 bits of the long
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @constructor
		   */
		  
		  
		  function Long(low, high, unsigned) {
		    /**
		     * The low 32 bits as a signed value.
		     * @type {number}
		     */
		    this.low = low | 0;
		    /**
		     * The high 32 bits as a signed value.
		     * @type {number}
		     */
		  
		    this.high = high | 0;
		    /**
		     * Whether unsigned or not.
		     * @type {boolean}
		     */
		  
		    this.unsigned = !!unsigned;
		  } // The internal representation of a long is the two given signed, 32-bit values.
		  // We use 32-bit pieces because these are the size of integers on which
		  // Javascript performs bit-operations.  For operations like addition and
		  // multiplication, we split each number into 16 bit pieces, which can easily be
		  // multiplied within Javascript's floating-point representation without overflow
		  // or change in sign.
		  //
		  // In the algorithms below, we frequently reduce the negative case to the
		  // positive case by negating the input(s) and then post-processing the result.
		  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
		  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
		  // a positive number, it overflows back into a negative).  Not handling this
		  // case would often result in infinite recursion.
		  //
		  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
		  // methods on which they depend.
		  
		  /**
		   * An indicator used to reliably determine if an object is a Long or not.
		   * @type {boolean}
		   * @const
		   * @private
		   */
		  
		  
		  Long.prototype.__isLong__;
		  Object.defineProperty(Long.prototype, "__isLong__", {
		    value: true
		  });
		  /**
		   * @function
		   * @param {*} obj Object
		   * @returns {boolean}
		   * @inner
		   */
		  
		  function isLong(obj) {
		    return (obj && obj["__isLong__"]) === true;
		  }
		  /**
		   * @function
		   * @param {*} value number
		   * @returns {number}
		   * @inner
		   */
		  
		  
		  function ctz32(value) {
		    var c = Math.clz32(value & -value);
		    return value ? 31 - c : c;
		  }
		  /**
		   * Tests if the specified object is a Long.
		   * @function
		   * @param {*} obj Object
		   * @returns {boolean}
		   */
		  
		  
		  Long.isLong = isLong;
		  /**
		   * A cache of the Long representations of small integer values.
		   * @type {!Object}
		   * @inner
		   */
		  
		  var INT_CACHE = {};
		  /**
		   * A cache of the Long representations of small unsigned integer values.
		   * @type {!Object}
		   * @inner
		   */
		  
		  var UINT_CACHE = {};
		  /**
		   * @param {number} value
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromInt(value, unsigned) {
		    var obj, cachedObj, cache;
		  
		    if (unsigned) {
		      value >>>= 0;
		  
		      if (cache = 0 <= value && value < 256) {
		        cachedObj = UINT_CACHE[value];
		        if (cachedObj) return cachedObj;
		      }
		  
		      obj = fromBits(value, 0, true);
		      if (cache) UINT_CACHE[value] = obj;
		      return obj;
		    } else {
		      value |= 0;
		  
		      if (cache = -128 <= value && value < 128) {
		        cachedObj = INT_CACHE[value];
		        if (cachedObj) return cachedObj;
		      }
		  
		      obj = fromBits(value, value < 0 ? -1 : 0, false);
		      if (cache) INT_CACHE[value] = obj;
		      return obj;
		    }
		  }
		  /**
		   * Returns a Long representing the given 32 bit integer value.
		   * @function
		   * @param {number} value The 32 bit integer in question
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromInt = fromInt;
		  /**
		   * @param {number} value
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromNumber(value, unsigned) {
		    if (isNaN(value)) return unsigned ? UZERO : ZERO;
		  
		    if (unsigned) {
		      if (value < 0) return UZERO;
		      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
		    } else {
		      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
		      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
		    }
		  
		    if (value < 0) return fromNumber(-value, unsigned).neg();
		    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
		  }
		  /**
		   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
		   * @function
		   * @param {number} value The number in question
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromNumber = fromNumber;
		  /**
		   * @param {number} lowBits
		   * @param {number} highBits
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromBits(lowBits, highBits, unsigned) {
		    return new Long(lowBits, highBits, unsigned);
		  }
		  /**
		   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
		   *  assumed to use 32 bits.
		   * @function
		   * @param {number} lowBits The low 32 bits
		   * @param {number} highBits The high 32 bits
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBits = fromBits;
		  /**
		   * @function
		   * @param {number} base
		   * @param {number} exponent
		   * @returns {number}
		   * @inner
		   */
		  
		  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
		  
		  /**
		   * @param {string} str
		   * @param {(boolean|number)=} unsigned
		   * @param {number=} radix
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromString(str, unsigned, radix) {
		    if (str.length === 0) throw Error('empty string');
		  
		    if (typeof unsigned === 'number') {
		      // For goog.math.long compatibility
		      radix = unsigned;
		      unsigned = false;
		    } else {
		      unsigned = !!unsigned;
		    }
		  
		    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
		    radix = radix || 10;
		    if (radix < 2 || 36 < radix) throw RangeError('radix');
		    var p;
		    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
		      return fromString(str.substring(1), unsigned, radix).neg();
		    } // Do several (8) digits each time through the loop, so as to
		    // minimize the calls to the very expensive emulated div.
		  
		    var radixToPower = fromNumber(pow_dbl(radix, 8));
		    var result = ZERO;
		  
		    for (var i = 0; i < str.length; i += 8) {
		      var size = Math.min(8, str.length - i),
		          value = parseInt(str.substring(i, i + size), radix);
		  
		      if (size < 8) {
		        var power = fromNumber(pow_dbl(radix, size));
		        result = result.mul(power).add(fromNumber(value));
		      } else {
		        result = result.mul(radixToPower);
		        result = result.add(fromNumber(value));
		      }
		    }
		  
		    result.unsigned = unsigned;
		    return result;
		  }
		  /**
		   * Returns a Long representation of the given string, written using the specified radix.
		   * @function
		   * @param {string} str The textual representation of the Long
		   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
		   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromString = fromString;
		  /**
		   * @function
		   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromValue(val, unsigned) {
		    if (typeof val === 'number') return fromNumber(val, unsigned);
		    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
		  
		    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
		  }
		  /**
		   * Converts the specified value to a Long using the appropriate from* function for its type.
		   * @function
		   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long}
		   */
		  
		  
		  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
		  // no runtime penalty for these.
		  
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_16_DBL = 1 << 16;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_24_DBL = 1 << 24;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
		  /**
		   * @type {!Long}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var ZERO = fromInt(0);
		  /**
		   * Signed zero.
		   * @type {!Long}
		   */
		  
		  Long.ZERO = ZERO;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var UZERO = fromInt(0, true);
		  /**
		   * Unsigned zero.
		   * @type {!Long}
		   */
		  
		  Long.UZERO = UZERO;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var ONE = fromInt(1);
		  /**
		   * Signed one.
		   * @type {!Long}
		   */
		  
		  Long.ONE = ONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var UONE = fromInt(1, true);
		  /**
		   * Unsigned one.
		   * @type {!Long}
		   */
		  
		  Long.UONE = UONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var NEG_ONE = fromInt(-1);
		  /**
		   * Signed negative one.
		   * @type {!Long}
		   */
		  
		  Long.NEG_ONE = NEG_ONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
		  /**
		   * Maximum signed value.
		   * @type {!Long}
		   */
		  
		  Long.MAX_VALUE = MAX_VALUE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
		  /**
		   * Maximum unsigned value.
		   * @type {!Long}
		   */
		  
		  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
		  /**
		   * Minimum signed value.
		   * @type {!Long}
		   */
		  
		  Long.MIN_VALUE = MIN_VALUE;
		  /**
		   * @alias Long.prototype
		   * @inner
		   */
		  
		  var LongPrototype = Long.prototype;
		  /**
		   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  LongPrototype.toInt = function toInt() {
		    return this.unsigned ? this.low >>> 0 : this.low;
		  };
		  /**
		   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  
		  LongPrototype.toNumber = function toNumber() {
		    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
		    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
		  };
		  /**
		   * Converts the Long to a string written in the specified radix.
		   * @this {!Long}
		   * @param {number=} radix Radix (2-36), defaults to 10
		   * @returns {string}
		   * @override
		   * @throws {RangeError} If `radix` is out of range
		   */
		  
		  
		  LongPrototype.toString = function toString(radix) {
		    radix = radix || 10;
		    if (radix < 2 || 36 < radix) throw RangeError('radix');
		    if (this.isZero()) return '0';
		  
		    if (this.isNegative()) {
		      // Unsigned Longs are never negative
		      if (this.eq(MIN_VALUE)) {
		        // We need to change the Long value before it can be negated, so we remove
		        // the bottom-most digit in this base and then recurse to do the rest.
		        var radixLong = fromNumber(radix),
		            div = this.div(radixLong),
		            rem1 = div.mul(radixLong).sub(this);
		        return div.toString(radix) + rem1.toInt().toString(radix);
		      } else return '-' + this.neg().toString(radix);
		    } // Do several (6) digits each time through the loop, so as to
		    // minimize the calls to the very expensive emulated div.
		  
		  
		    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
		        rem = this;
		    var result = '';
		  
		    while (true) {
		      var remDiv = rem.div(radixToPower),
		          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
		          digits = intval.toString(radix);
		      rem = remDiv;
		      if (rem.isZero()) return digits + result;else {
		        while (digits.length < 6) digits = '0' + digits;
		  
		        result = '' + digits + result;
		      }
		    }
		  };
		  /**
		   * Gets the high 32 bits as a signed integer.
		   * @this {!Long}
		   * @returns {number} Signed high bits
		   */
		  
		  
		  LongPrototype.getHighBits = function getHighBits() {
		    return this.high;
		  };
		  /**
		   * Gets the high 32 bits as an unsigned integer.
		   * @this {!Long}
		   * @returns {number} Unsigned high bits
		   */
		  
		  
		  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
		    return this.high >>> 0;
		  };
		  /**
		   * Gets the low 32 bits as a signed integer.
		   * @this {!Long}
		   * @returns {number} Signed low bits
		   */
		  
		  
		  LongPrototype.getLowBits = function getLowBits() {
		    return this.low;
		  };
		  /**
		   * Gets the low 32 bits as an unsigned integer.
		   * @this {!Long}
		   * @returns {number} Unsigned low bits
		   */
		  
		  
		  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
		    return this.low >>> 0;
		  };
		  /**
		   * Gets the number of bits needed to represent the absolute value of this Long.
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  
		  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
		    if (this.isNegative()) // Unsigned Longs are never negative
		      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
		    var val = this.high != 0 ? this.high : this.low;
		  
		    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
		  
		    return this.high != 0 ? bit + 33 : bit + 1;
		  };
		  /**
		   * Tests if this Long's value equals zero.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isZero = function isZero() {
		    return this.high === 0 && this.low === 0;
		  };
		  /**
		   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.eqz = LongPrototype.isZero;
		  /**
		   * Tests if this Long's value is negative.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  LongPrototype.isNegative = function isNegative() {
		    return !this.unsigned && this.high < 0;
		  };
		  /**
		   * Tests if this Long's value is positive or zero.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isPositive = function isPositive() {
		    return this.unsigned || this.high >= 0;
		  };
		  /**
		   * Tests if this Long's value is odd.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isOdd = function isOdd() {
		    return (this.low & 1) === 1;
		  };
		  /**
		   * Tests if this Long's value is even.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isEven = function isEven() {
		    return (this.low & 1) === 0;
		  };
		  /**
		   * Tests if this Long's value equals the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.equals = function equals(other) {
		    if (!isLong(other)) other = fromValue(other);
		    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
		    return this.high === other.high && this.low === other.low;
		  };
		  /**
		   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.eq = LongPrototype.equals;
		  /**
		   * Tests if this Long's value differs from the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.notEquals = function notEquals(other) {
		    return !this.eq(
		    /* validates */
		    other);
		  };
		  /**
		   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.neq = LongPrototype.notEquals;
		  /**
		   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.ne = LongPrototype.notEquals;
		  /**
		   * Tests if this Long's value is less than the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.lessThan = function lessThan(other) {
		    return this.comp(
		    /* validates */
		    other) < 0;
		  };
		  /**
		   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.lt = LongPrototype.lessThan;
		  /**
		   * Tests if this Long's value is less than or equal the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
		    return this.comp(
		    /* validates */
		    other) <= 0;
		  };
		  /**
		   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.lte = LongPrototype.lessThanOrEqual;
		  /**
		   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.le = LongPrototype.lessThanOrEqual;
		  /**
		   * Tests if this Long's value is greater than the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.greaterThan = function greaterThan(other) {
		    return this.comp(
		    /* validates */
		    other) > 0;
		  };
		  /**
		   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.gt = LongPrototype.greaterThan;
		  /**
		   * Tests if this Long's value is greater than or equal the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
		    return this.comp(
		    /* validates */
		    other) >= 0;
		  };
		  /**
		   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
		  /**
		   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
		  /**
		   * Compares this Long's value with the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
		   *  if the given one is greater
		   */
		  
		  LongPrototype.compare = function compare(other) {
		    if (!isLong(other)) other = fromValue(other);
		    if (this.eq(other)) return 0;
		    var thisNeg = this.isNegative(),
		        otherNeg = other.isNegative();
		    if (thisNeg && !otherNeg) return -1;
		    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
		  
		    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
		  
		    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
		  };
		  /**
		   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
		   *  if the given one is greater
		   */
		  
		  
		  LongPrototype.comp = LongPrototype.compare;
		  /**
		   * Negates this Long's value.
		   * @this {!Long}
		   * @returns {!Long} Negated Long
		   */
		  
		  LongPrototype.negate = function negate() {
		    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
		    return this.not().add(ONE);
		  };
		  /**
		   * Negates this Long's value. This is an alias of {@link Long#negate}.
		   * @function
		   * @returns {!Long} Negated Long
		   */
		  
		  
		  LongPrototype.neg = LongPrototype.negate;
		  /**
		   * Returns the sum of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} addend Addend
		   * @returns {!Long} Sum
		   */
		  
		  LongPrototype.add = function add(addend) {
		    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
		  
		    var a48 = this.high >>> 16;
		    var a32 = this.high & 0xFFFF;
		    var a16 = this.low >>> 16;
		    var a00 = this.low & 0xFFFF;
		    var b48 = addend.high >>> 16;
		    var b32 = addend.high & 0xFFFF;
		    var b16 = addend.low >>> 16;
		    var b00 = addend.low & 0xFFFF;
		    var c48 = 0,
		        c32 = 0,
		        c16 = 0,
		        c00 = 0;
		    c00 += a00 + b00;
		    c16 += c00 >>> 16;
		    c00 &= 0xFFFF;
		    c16 += a16 + b16;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c32 += a32 + b32;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c48 += a48 + b48;
		    c48 &= 0xFFFF;
		    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		  };
		  /**
		   * Returns the difference of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} subtrahend Subtrahend
		   * @returns {!Long} Difference
		   */
		  
		  
		  LongPrototype.subtract = function subtract(subtrahend) {
		    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
		    return this.add(subtrahend.neg());
		  };
		  /**
		   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
		   * @function
		   * @param {!Long|number|string} subtrahend Subtrahend
		   * @returns {!Long} Difference
		   */
		  
		  
		  LongPrototype.sub = LongPrototype.subtract;
		  /**
		   * Returns the product of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} multiplier Multiplier
		   * @returns {!Long} Product
		   */
		  
		  LongPrototype.multiply = function multiply(multiplier) {
		    if (this.isZero()) return this;
		    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
		  
		    if (wasm) {
		      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
		    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
		    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
		  
		    if (this.isNegative()) {
		      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
		    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
		  
		  
		    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
		    // We can skip products that would overflow.
		  
		    var a48 = this.high >>> 16;
		    var a32 = this.high & 0xFFFF;
		    var a16 = this.low >>> 16;
		    var a00 = this.low & 0xFFFF;
		    var b48 = multiplier.high >>> 16;
		    var b32 = multiplier.high & 0xFFFF;
		    var b16 = multiplier.low >>> 16;
		    var b00 = multiplier.low & 0xFFFF;
		    var c48 = 0,
		        c32 = 0,
		        c16 = 0,
		        c00 = 0;
		    c00 += a00 * b00;
		    c16 += c00 >>> 16;
		    c00 &= 0xFFFF;
		    c16 += a16 * b00;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c16 += a00 * b16;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c32 += a32 * b00;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c32 += a16 * b16;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c32 += a00 * b32;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
		    c48 &= 0xFFFF;
		    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		  };
		  /**
		   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
		   * @function
		   * @param {!Long|number|string} multiplier Multiplier
		   * @returns {!Long} Product
		   */
		  
		  
		  LongPrototype.mul = LongPrototype.multiply;
		  /**
		   * Returns this Long divided by the specified. The result is signed if this Long is signed or
		   *  unsigned if this Long is unsigned.
		   * @this {!Long}
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Quotient
		   */
		  
		  LongPrototype.divide = function divide(divisor) {
		    if (!isLong(divisor)) divisor = fromValue(divisor);
		    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
		  
		    if (wasm) {
		      // guard against signed division overflow: the largest
		      // negative number / -1 would be 1 larger than the largest
		      // positive number, due to two's complement.
		      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
		        // be consistent with non-wasm code path
		        return this;
		      }
		  
		      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
		    var approx, rem, res;
		  
		    if (!this.unsigned) {
		      // This section is only relevant for signed longs and is derived from the
		      // closure library as a whole.
		      if (this.eq(MIN_VALUE)) {
		        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
		        else if (divisor.eq(MIN_VALUE)) return ONE;else {
		          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
		          var halfThis = this.shr(1);
		          approx = halfThis.div(divisor).shl(1);
		  
		          if (approx.eq(ZERO)) {
		            return divisor.isNegative() ? ONE : NEG_ONE;
		          } else {
		            rem = this.sub(divisor.mul(approx));
		            res = approx.add(rem.div(divisor));
		            return res;
		          }
		        }
		      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
		  
		      if (this.isNegative()) {
		        if (divisor.isNegative()) return this.neg().div(divisor.neg());
		        return this.neg().div(divisor).neg();
		      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
		  
		      res = ZERO;
		    } else {
		      // The algorithm below has not been made for unsigned longs. It's therefore
		      // required to take special care of the MSB prior to running it.
		      if (!divisor.unsigned) divisor = divisor.toUnsigned();
		      if (divisor.gt(this)) return UZERO;
		      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
		        return UONE;
		      res = UZERO;
		    } // Repeat the following until the remainder is less than other:  find a
		    // floating-point that approximates remainder / other *from below*, add this
		    // into the result, and subtract it from the remainder.  It is critical that
		    // the approximate value is less than or equal to the real value so that the
		    // remainder never becomes negative.
		  
		  
		    rem = this;
		  
		    while (rem.gte(divisor)) {
		      // Approximate the result of division. This may be a little greater or
		      // smaller than the actual value.
		      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
		      // the smallest non-fractional digit, whichever is larger.
		  
		      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
		          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
		          // Decrease the approximation until it is smaller than the remainder.  Note
		      // that if it is too large, the product overflows and is negative.
		      approxRes = fromNumber(approx),
		          approxRem = approxRes.mul(divisor);
		  
		      while (approxRem.isNegative() || approxRem.gt(rem)) {
		        approx -= delta;
		        approxRes = fromNumber(approx, this.unsigned);
		        approxRem = approxRes.mul(divisor);
		      } // We know the answer can't be zero... and actually, zero would cause
		      // infinite recursion since we would make no progress.
		  
		  
		      if (approxRes.isZero()) approxRes = ONE;
		      res = res.add(approxRes);
		      rem = rem.sub(approxRem);
		    }
		  
		    return res;
		  };
		  /**
		   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Quotient
		   */
		  
		  
		  LongPrototype.div = LongPrototype.divide;
		  /**
		   * Returns this Long modulo the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  LongPrototype.modulo = function modulo(divisor) {
		    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
		  
		    if (wasm) {
		      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    return this.sub(this.div(divisor).mul(divisor));
		  };
		  /**
		   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  
		  LongPrototype.mod = LongPrototype.modulo;
		  /**
		   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  LongPrototype.rem = LongPrototype.modulo;
		  /**
		   * Returns the bitwise NOT of this Long.
		   * @this {!Long}
		   * @returns {!Long}
		   */
		  
		  LongPrototype.not = function not() {
		    return fromBits(~this.low, ~this.high, this.unsigned);
		  };
		  /**
		   * Returns count leading zeros of this Long.
		   * @this {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.countLeadingZeros = function countLeadingZeros() {
		    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
		  };
		  /**
		   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
		   * @function
		   * @param {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.clz = LongPrototype.countLeadingZeros;
		  /**
		   * Returns count trailing zeros of this Long.
		   * @this {!Long}
		   * @returns {!number}
		   */
		  
		  LongPrototype.countTrailingZeros = function countTrailingZeros() {
		    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
		  };
		  /**
		   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
		   * @function
		   * @param {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.ctz = LongPrototype.countTrailingZeros;
		  /**
		   * Returns the bitwise AND of this Long and the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  LongPrototype.and = function and(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
		  };
		  /**
		   * Returns the bitwise OR of this Long and the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  
		  LongPrototype.or = function or(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
		  };
		  /**
		   * Returns the bitwise XOR of this Long and the given one.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  
		  LongPrototype.xor = function xor(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits shifted to the left by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shiftLeft = function shiftLeft(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shl = LongPrototype.shiftLeft;
		  /**
		   * Returns this Long with bits arithmetically shifted to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shiftRight = function shiftRight(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shr = LongPrototype.shiftRight;
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
		    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
		    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
		  /**
		   * Returns this Long with bits rotated to the left by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  LongPrototype.rotateLeft = function rotateLeft(numBits) {
		    var b;
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
		  
		    if (numBits < 32) {
		      b = 32 - numBits;
		      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
		    }
		  
		    numBits -= 32;
		    b = 32 - numBits;
		    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  
		  LongPrototype.rotl = LongPrototype.rotateLeft;
		  /**
		   * Returns this Long with bits rotated to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  LongPrototype.rotateRight = function rotateRight(numBits) {
		    var b;
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
		  
		    if (numBits < 32) {
		      b = 32 - numBits;
		      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
		    }
		  
		    numBits -= 32;
		    b = 32 - numBits;
		    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  
		  LongPrototype.rotr = LongPrototype.rotateRight;
		  /**
		   * Converts this Long to signed.
		   * @this {!Long}
		   * @returns {!Long} Signed long
		   */
		  
		  LongPrototype.toSigned = function toSigned() {
		    if (!this.unsigned) return this;
		    return fromBits(this.low, this.high, false);
		  };
		  /**
		   * Converts this Long to unsigned.
		   * @this {!Long}
		   * @returns {!Long} Unsigned long
		   */
		  
		  
		  LongPrototype.toUnsigned = function toUnsigned() {
		    if (this.unsigned) return this;
		    return fromBits(this.low, this.high, true);
		  };
		  /**
		   * Converts this Long to its byte representation.
		   * @param {boolean=} le Whether little or big endian, defaults to big endian
		   * @this {!Long}
		   * @returns {!Array.<number>} Byte representation
		   */
		  
		  
		  LongPrototype.toBytes = function toBytes(le) {
		    return le ? this.toBytesLE() : this.toBytesBE();
		  };
		  /**
		   * Converts this Long to its little endian byte representation.
		   * @this {!Long}
		   * @returns {!Array.<number>} Little endian byte representation
		   */
		  
		  
		  LongPrototype.toBytesLE = function toBytesLE() {
		    var hi = this.high,
		        lo = this.low;
		    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
		  };
		  /**
		   * Converts this Long to its big endian byte representation.
		   * @this {!Long}
		   * @returns {!Array.<number>} Big endian byte representation
		   */
		  
		  
		  LongPrototype.toBytesBE = function toBytesBE() {
		    var hi = this.high,
		        lo = this.low;
		    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
		  };
		  /**
		   * Creates a Long from its byte representation.
		   * @param {!Array.<number>} bytes Byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @param {boolean=} le Whether little or big endian, defaults to big endian
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
		    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
		  };
		  /**
		   * Creates a Long from its little endian byte representation.
		   * @param {!Array.<number>} bytes Little endian byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
		    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
		  };
		  /**
		   * Creates a Long from its big endian byte representation.
		   * @param {!Array.<number>} bytes Big endian byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
		    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
		  };
		  
		  var _default = Long;
		  exports.default = _default;
		  return "default" in exports ? exports.default : exports;
		})({});
		module.exports = Long; 
	} (umd));
	return umd.exports;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src$1;
	hasRequiredSrc = 1;
	/**
	 * @license
	 * Copyright 2018 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(src$1, "__esModule", { value: true });
	src$1.loadFileDescriptorSetFromObject = src$1.loadFileDescriptorSetFromBuffer = src$1.fromJSON = src$1.loadSync = src$1.load = src$1.isAnyExtension = src$1.Long = void 0;
	const camelCase = requireLodash_camelcase();
	const Protobuf = requireProtobufjs();
	const descriptor = requireDescriptor();
	const util_1 = requireUtil();
	const Long = requireUmd();
	src$1.Long = Long;
	function isAnyExtension(obj) {
	    return ('@type' in obj) && (typeof obj['@type'] === 'string');
	}
	src$1.isAnyExtension = isAnyExtension;
	const descriptorOptions = {
	    longs: String,
	    enums: String,
	    bytes: String,
	    defaults: true,
	    oneofs: true,
	    json: true,
	};
	function joinName(baseName, name) {
	    if (baseName === '') {
	        return name;
	    }
	    else {
	        return baseName + '.' + name;
	    }
	}
	function isHandledReflectionObject(obj) {
	    return (obj instanceof Protobuf.Service ||
	        obj instanceof Protobuf.Type ||
	        obj instanceof Protobuf.Enum);
	}
	function isNamespaceBase(obj) {
	    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
	}
	function getAllHandledReflectionObjects(obj, parentName) {
	    const objName = joinName(parentName, obj.name);
	    if (isHandledReflectionObject(obj)) {
	        return [[objName, obj]];
	    }
	    else {
	        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {
	            return Object.keys(obj.nested)
	                .map(name => {
	                return getAllHandledReflectionObjects(obj.nested[name], objName);
	            })
	                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
	        }
	    }
	    return [];
	}
	function createDeserializer(cls, options) {
	    return function deserialize(argBuf) {
	        return cls.toObject(cls.decode(argBuf), options);
	    };
	}
	function createSerializer(cls) {
	    return function serialize(arg) {
	        if (Array.isArray(arg)) {
	            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
	        }
	        const message = cls.fromObject(arg);
	        return cls.encode(message).finish();
	    };
	}
	function createMethodDefinition(method, serviceName, options, fileDescriptors) {
	    /* This is only ever called after the corresponding root.resolveAll(), so we
	     * can assume that the resolved request and response types are non-null */
	    const requestType = method.resolvedRequestType;
	    const responseType = method.resolvedResponseType;
	    return {
	        path: '/' + serviceName + '/' + method.name,
	        requestStream: !!method.requestStream,
	        responseStream: !!method.responseStream,
	        requestSerialize: createSerializer(requestType),
	        requestDeserialize: createDeserializer(requestType, options),
	        responseSerialize: createSerializer(responseType),
	        responseDeserialize: createDeserializer(responseType, options),
	        // TODO(murgatroid99): Find a better way to handle this
	        originalName: camelCase(method.name),
	        requestType: createMessageDefinition(requestType, fileDescriptors),
	        responseType: createMessageDefinition(responseType, fileDescriptors),
	    };
	}
	function createServiceDefinition(service, name, options, fileDescriptors) {
	    const def = {};
	    for (const method of service.methodsArray) {
	        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
	    }
	    return def;
	}
	function createMessageDefinition(message, fileDescriptors) {
	    const messageDescriptor = message.toDescriptor('proto3');
	    return {
	        format: 'Protocol Buffer 3 DescriptorProto',
	        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
	        fileDescriptorProtos: fileDescriptors,
	    };
	}
	function createEnumDefinition(enumType, fileDescriptors) {
	    const enumDescriptor = enumType.toDescriptor('proto3');
	    return {
	        format: 'Protocol Buffer 3 EnumDescriptorProto',
	        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
	        fileDescriptorProtos: fileDescriptors,
	    };
	}
	/**
	 * function createDefinition(obj: Protobuf.Service, name: string, options:
	 * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,
	 * name: string, options: Options): MessageTypeDefinition; function
	 * createDefinition(obj: Protobuf.Enum, name: string, options: Options):
	 * EnumTypeDefinition;
	 */
	function createDefinition(obj, name, options, fileDescriptors) {
	    if (obj instanceof Protobuf.Service) {
	        return createServiceDefinition(obj, name, options, fileDescriptors);
	    }
	    else if (obj instanceof Protobuf.Type) {
	        return createMessageDefinition(obj, fileDescriptors);
	    }
	    else if (obj instanceof Protobuf.Enum) {
	        return createEnumDefinition(obj, fileDescriptors);
	    }
	    else {
	        throw new Error('Type mismatch in reflection object handling');
	    }
	}
	function createPackageDefinition(root, options) {
	    const def = {};
	    root.resolveAll();
	    const descriptorList = root.toDescriptor('proto3').file;
	    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
	    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {
	        def[name] = createDefinition(obj, name, options, bufferList);
	    }
	    return def;
	}
	function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
	    options = options || {};
	    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
	    root.resolveAll();
	    return createPackageDefinition(root, options);
	}
	/**
	 * Load a .proto file with the specified options.
	 * @param filename One or multiple file paths to load. Can be an absolute path
	 *     or relative to an include path.
	 * @param options.keepCase Preserve field names. The default is to change them
	 *     to camel case.
	 * @param options.longs The type that should be used to represent `long` values.
	 *     Valid options are `Number` and `String`. Defaults to a `Long` object type
	 *     from a library.
	 * @param options.enums The type that should be used to represent `enum` values.
	 *     The only valid option is `String`. Defaults to the numeric value.
	 * @param options.bytes The type that should be used to represent `bytes`
	 *     values. Valid options are `Array` and `String`. The default is to use
	 *     `Buffer`.
	 * @param options.defaults Set default values on output objects. Defaults to
	 *     `false`.
	 * @param options.arrays Set empty arrays for missing array values even if
	 *     `defaults` is `false`. Defaults to `false`.
	 * @param options.objects Set empty objects for missing object values even if
	 *     `defaults` is `false`. Defaults to `false`.
	 * @param options.oneofs Set virtual oneof properties to the present field's
	 *     name
	 * @param options.json Represent Infinity and NaN as strings in float fields,
	 *     and automatically decode google.protobuf.Any values.
	 * @param options.includeDirs Paths to search for imported `.proto` files.
	 */
	function load(filename, options) {
	    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {
	        return createPackageDefinition(loadedRoot, options);
	    });
	}
	src$1.load = load;
	function loadSync(filename, options) {
	    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
	    return createPackageDefinition(loadedRoot, options);
	}
	src$1.loadSync = loadSync;
	function fromJSON(json, options) {
	    options = options || {};
	    const loadedRoot = Protobuf.Root.fromJSON(json);
	    loadedRoot.resolveAll();
	    return createPackageDefinition(loadedRoot, options);
	}
	src$1.fromJSON = fromJSON;
	function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
	    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
	    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
	}
	src$1.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
	function loadFileDescriptorSetFromObject(descriptorSet, options) {
	    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
	    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
	}
	src$1.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
	(0, util_1.addCommonProtos)();
	
	return src$1;
}

var hasRequiredChannelz;

function requireChannelz () {
	if (hasRequiredChannelz) return channelz;
	hasRequiredChannelz = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelz, "__esModule", { value: true });
	channelz.setup = channelz.getChannelzServiceDefinition = channelz.getChannelzHandlers = channelz.unregisterChannelzRef = channelz.registerChannelzSocket = channelz.registerChannelzServer = channelz.registerChannelzSubchannel = channelz.registerChannelzChannel = channelz.ChannelzCallTrackerStub = channelz.ChannelzCallTracker = channelz.ChannelzChildrenTrackerStub = channelz.ChannelzChildrenTracker = channelz.ChannelzTrace = channelz.ChannelzTraceStub = void 0;
	const net_1 = require$$0$3;
	const ordered_map_1 = require$$1;
	const connectivity_state_1 = connectivityState;
	const constants_1 = constants;
	const subchannel_address_1 = subchannelAddress;
	const admin_1 = requireAdmin();
	const make_client_1 = requireMakeClient();
	function channelRefToMessage(ref) {
	    return {
	        channel_id: ref.id,
	        name: ref.name,
	    };
	}
	function subchannelRefToMessage(ref) {
	    return {
	        subchannel_id: ref.id,
	        name: ref.name,
	    };
	}
	function serverRefToMessage(ref) {
	    return {
	        server_id: ref.id,
	    };
	}
	function socketRefToMessage(ref) {
	    return {
	        socket_id: ref.id,
	        name: ref.name,
	    };
	}
	/**
	 * The loose upper bound on the number of events that should be retained in a
	 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
	 * number that should be large enough to contain the recent relevant
	 * information, but small enough to not use excessive memory.
	 */
	const TARGET_RETAINED_TRACES = 32;
	/**
	 * Default number of sockets/servers/channels/subchannels to return
	 */
	const DEFAULT_MAX_RESULTS = 100;
	class ChannelzTraceStub {
	    constructor() {
	        this.events = [];
	        this.creationTimestamp = new Date();
	        this.eventsLogged = 0;
	    }
	    addTrace() { }
	    getTraceMessage() {
	        return {
	            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
	            num_events_logged: this.eventsLogged,
	            events: [],
	        };
	    }
	}
	channelz.ChannelzTraceStub = ChannelzTraceStub;
	class ChannelzTrace {
	    constructor() {
	        this.events = [];
	        this.eventsLogged = 0;
	        this.creationTimestamp = new Date();
	    }
	    addTrace(severity, description, child) {
	        const timestamp = new Date();
	        this.events.push({
	            description: description,
	            severity: severity,
	            timestamp: timestamp,
	            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,
	            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,
	        });
	        // Whenever the trace array gets too large, discard the first half
	        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
	            this.events = this.events.slice(TARGET_RETAINED_TRACES);
	        }
	        this.eventsLogged += 1;
	    }
	    getTraceMessage() {
	        return {
	            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
	            num_events_logged: this.eventsLogged,
	            events: this.events.map(event => {
	                return {
	                    description: event.description,
	                    severity: event.severity,
	                    timestamp: dateToProtoTimestamp(event.timestamp),
	                    channel_ref: event.childChannel
	                        ? channelRefToMessage(event.childChannel)
	                        : null,
	                    subchannel_ref: event.childSubchannel
	                        ? subchannelRefToMessage(event.childSubchannel)
	                        : null,
	                };
	            }),
	        };
	    }
	}
	channelz.ChannelzTrace = ChannelzTrace;
	class ChannelzChildrenTracker {
	    constructor() {
	        this.channelChildren = new ordered_map_1.OrderedMap();
	        this.subchannelChildren = new ordered_map_1.OrderedMap();
	        this.socketChildren = new ordered_map_1.OrderedMap();
	        this.trackerMap = {
	            ["channel" /* EntityTypes.channel */]: this.channelChildren,
	            ["subchannel" /* EntityTypes.subchannel */]: this.subchannelChildren,
	            ["socket" /* EntityTypes.socket */]: this.socketChildren,
	        };
	    }
	    refChild(child) {
	        const tracker = this.trackerMap[child.kind];
	        const trackedChild = tracker.find(child.id);
	        if (trackedChild.equals(tracker.end())) {
	            tracker.setElement(child.id, {
	                ref: child,
	                count: 1,
	            }, trackedChild);
	        }
	        else {
	            trackedChild.pointer[1].count += 1;
	        }
	    }
	    unrefChild(child) {
	        const tracker = this.trackerMap[child.kind];
	        const trackedChild = tracker.getElementByKey(child.id);
	        if (trackedChild !== undefined) {
	            trackedChild.count -= 1;
	            if (trackedChild.count === 0) {
	                tracker.eraseElementByKey(child.id);
	            }
	        }
	    }
	    getChildLists() {
	        return {
	            channels: this.channelChildren,
	            subchannels: this.subchannelChildren,
	            sockets: this.socketChildren,
	        };
	    }
	}
	channelz.ChannelzChildrenTracker = ChannelzChildrenTracker;
	class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
	    refChild() { }
	    unrefChild() { }
	}
	channelz.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;
	class ChannelzCallTracker {
	    constructor() {
	        this.callsStarted = 0;
	        this.callsSucceeded = 0;
	        this.callsFailed = 0;
	        this.lastCallStartedTimestamp = null;
	    }
	    addCallStarted() {
	        this.callsStarted += 1;
	        this.lastCallStartedTimestamp = new Date();
	    }
	    addCallSucceeded() {
	        this.callsSucceeded += 1;
	    }
	    addCallFailed() {
	        this.callsFailed += 1;
	    }
	}
	channelz.ChannelzCallTracker = ChannelzCallTracker;
	class ChannelzCallTrackerStub extends ChannelzCallTracker {
	    addCallStarted() { }
	    addCallSucceeded() { }
	    addCallFailed() { }
	}
	channelz.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
	const entityMaps = {
	    ["channel" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),
	    ["subchannel" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),
	    ["server" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),
	    ["socket" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap(),
	};
	const generateRegisterFn = (kind) => {
	    let nextId = 1;
	    function getNextId() {
	        return nextId++;
	    }
	    const entityMap = entityMaps[kind];
	    return (name, getInfo, channelzEnabled) => {
	        const id = getNextId();
	        const ref = { id, name, kind };
	        if (channelzEnabled) {
	            entityMap.setElement(id, { ref, getInfo });
	        }
	        return ref;
	    };
	};
	channelz.registerChannelzChannel = generateRegisterFn("channel" /* EntityTypes.channel */);
	channelz.registerChannelzSubchannel = generateRegisterFn("subchannel" /* EntityTypes.subchannel */);
	channelz.registerChannelzServer = generateRegisterFn("server" /* EntityTypes.server */);
	channelz.registerChannelzSocket = generateRegisterFn("socket" /* EntityTypes.socket */);
	function unregisterChannelzRef(ref) {
	    entityMaps[ref.kind].eraseElementByKey(ref.id);
	}
	channelz.unregisterChannelzRef = unregisterChannelzRef;
	/**
	 * Parse a single section of an IPv6 address as two bytes
	 * @param addressSection A hexadecimal string of length up to 4
	 * @returns The pair of bytes representing this address section
	 */
	function parseIPv6Section(addressSection) {
	    const numberValue = Number.parseInt(addressSection, 16);
	    return [(numberValue / 256) | 0, numberValue % 256];
	}
	/**
	 * Parse a chunk of an IPv6 address string to some number of bytes
	 * @param addressChunk Some number of segments of up to 4 hexadecimal
	 *   characters each, joined by colons.
	 * @returns The list of bytes representing this address chunk
	 */
	function parseIPv6Chunk(addressChunk) {
	    if (addressChunk === '') {
	        return [];
	    }
	    const bytePairs = addressChunk
	        .split(':')
	        .map(section => parseIPv6Section(section));
	    const result = [];
	    return result.concat(...bytePairs);
	}
	/**
	 * Converts an IPv4 or IPv6 address from string representation to binary
	 * representation
	 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
	 * @returns
	 */
	function ipAddressStringToBuffer(ipAddress) {
	    if ((0, net_1.isIPv4)(ipAddress)) {
	        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));
	    }
	    else if ((0, net_1.isIPv6)(ipAddress)) {
	        let leftSection;
	        let rightSection;
	        const doubleColonIndex = ipAddress.indexOf('::');
	        if (doubleColonIndex === -1) {
	            leftSection = ipAddress;
	            rightSection = '';
	        }
	        else {
	            leftSection = ipAddress.substring(0, doubleColonIndex);
	            rightSection = ipAddress.substring(doubleColonIndex + 2);
	        }
	        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
	        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
	        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
	        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
	    }
	    else {
	        return null;
	    }
	}
	function connectivityStateToMessage(state) {
	    switch (state) {
	        case connectivity_state_1.ConnectivityState.CONNECTING:
	            return {
	                state: 'CONNECTING',
	            };
	        case connectivity_state_1.ConnectivityState.IDLE:
	            return {
	                state: 'IDLE',
	            };
	        case connectivity_state_1.ConnectivityState.READY:
	            return {
	                state: 'READY',
	            };
	        case connectivity_state_1.ConnectivityState.SHUTDOWN:
	            return {
	                state: 'SHUTDOWN',
	            };
	        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
	            return {
	                state: 'TRANSIENT_FAILURE',
	            };
	        default:
	            return {
	                state: 'UNKNOWN',
	            };
	    }
	}
	function dateToProtoTimestamp(date) {
	    if (!date) {
	        return null;
	    }
	    const millisSinceEpoch = date.getTime();
	    return {
	        seconds: (millisSinceEpoch / 1000) | 0,
	        nanos: (millisSinceEpoch % 1000) * 1000000,
	    };
	}
	function getChannelMessage(channelEntry) {
	    const resolvedInfo = channelEntry.getInfo();
	    const channelRef = [];
	    const subchannelRef = [];
	    resolvedInfo.children.channels.forEach(el => {
	        channelRef.push(channelRefToMessage(el[1].ref));
	    });
	    resolvedInfo.children.subchannels.forEach(el => {
	        subchannelRef.push(subchannelRefToMessage(el[1].ref));
	    });
	    return {
	        ref: channelRefToMessage(channelEntry.ref),
	        data: {
	            target: resolvedInfo.target,
	            state: connectivityStateToMessage(resolvedInfo.state),
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        channel_ref: channelRef,
	        subchannel_ref: subchannelRef,
	    };
	}
	function GetChannel(call, callback) {
	    const channelId = parseInt(call.request.channel_id, 10);
	    const channelEntry = entityMaps["channel" /* EntityTypes.channel */].getElementByKey(channelId);
	    if (channelEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No channel data found for id ' + channelId,
	        });
	        return;
	    }
	    callback(null, { channel: getChannelMessage(channelEntry) });
	}
	function GetTopChannels(call, callback) {
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const resultList = [];
	    const startId = parseInt(call.request.start_channel_id, 10);
	    const channelEntries = entityMaps["channel" /* EntityTypes.channel */];
	    let i;
	    for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(getChannelMessage(i.pointer[1]));
	    }
	    callback(null, {
	        channel: resultList,
	        end: i.equals(channelEntries.end()),
	    });
	}
	function getServerMessage(serverEntry) {
	    const resolvedInfo = serverEntry.getInfo();
	    const listenSocket = [];
	    resolvedInfo.listenerChildren.sockets.forEach(el => {
	        listenSocket.push(socketRefToMessage(el[1].ref));
	    });
	    return {
	        ref: serverRefToMessage(serverEntry.ref),
	        data: {
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        listen_socket: listenSocket,
	    };
	}
	function GetServer(call, callback) {
	    const serverId = parseInt(call.request.server_id, 10);
	    const serverEntries = entityMaps["server" /* EntityTypes.server */];
	    const serverEntry = serverEntries.getElementByKey(serverId);
	    if (serverEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No server data found for id ' + serverId,
	        });
	        return;
	    }
	    callback(null, { server: getServerMessage(serverEntry) });
	}
	function GetServers(call, callback) {
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const startId = parseInt(call.request.start_server_id, 10);
	    const serverEntries = entityMaps["server" /* EntityTypes.server */];
	    const resultList = [];
	    let i;
	    for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(getServerMessage(i.pointer[1]));
	    }
	    callback(null, {
	        server: resultList,
	        end: i.equals(serverEntries.end()),
	    });
	}
	function GetSubchannel(call, callback) {
	    const subchannelId = parseInt(call.request.subchannel_id, 10);
	    const subchannelEntry = entityMaps["subchannel" /* EntityTypes.subchannel */].getElementByKey(subchannelId);
	    if (subchannelEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No subchannel data found for id ' + subchannelId,
	        });
	        return;
	    }
	    const resolvedInfo = subchannelEntry.getInfo();
	    const listenSocket = [];
	    resolvedInfo.children.sockets.forEach(el => {
	        listenSocket.push(socketRefToMessage(el[1].ref));
	    });
	    const subchannelMessage = {
	        ref: subchannelRefToMessage(subchannelEntry.ref),
	        data: {
	            target: resolvedInfo.target,
	            state: connectivityStateToMessage(resolvedInfo.state),
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        socket_ref: listenSocket,
	    };
	    callback(null, { subchannel: subchannelMessage });
	}
	function subchannelAddressToAddressMessage(subchannelAddress) {
	    var _a;
	    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
	        return {
	            address: 'tcpip_address',
	            tcpip_address: {
	                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,
	                port: subchannelAddress.port,
	            },
	        };
	    }
	    else {
	        return {
	            address: 'uds_address',
	            uds_address: {
	                filename: subchannelAddress.path,
	            },
	        };
	    }
	}
	function GetSocket(call, callback) {
	    var _a, _b, _c, _d, _e;
	    const socketId = parseInt(call.request.socket_id, 10);
	    const socketEntry = entityMaps["socket" /* EntityTypes.socket */].getElementByKey(socketId);
	    if (socketEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No socket data found for id ' + socketId,
	        });
	        return;
	    }
	    const resolvedInfo = socketEntry.getInfo();
	    const securityMessage = resolvedInfo.security
	        ? {
	            model: 'tls',
	            tls: {
	                cipher_suite: resolvedInfo.security.cipherSuiteStandardName
	                    ? 'standard_name'
	                    : 'other_name',
	                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,
	                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,
	                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,
	                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,
	            },
	        }
	        : null;
	    const socketMessage = {
	        ref: socketRefToMessage(socketEntry.ref),
	        local: resolvedInfo.localAddress
	            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)
	            : null,
	        remote: resolvedInfo.remoteAddress
	            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)
	            : null,
	        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,
	        security: securityMessage,
	        data: {
	            keep_alives_sent: resolvedInfo.keepAlivesSent,
	            streams_started: resolvedInfo.streamsStarted,
	            streams_succeeded: resolvedInfo.streamsSucceeded,
	            streams_failed: resolvedInfo.streamsFailed,
	            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
	            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
	            messages_received: resolvedInfo.messagesReceived,
	            messages_sent: resolvedInfo.messagesSent,
	            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
	            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
	            local_flow_control_window: resolvedInfo.localFlowControlWindow
	                ? { value: resolvedInfo.localFlowControlWindow }
	                : null,
	            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow
	                ? { value: resolvedInfo.remoteFlowControlWindow }
	                : null,
	        },
	    };
	    callback(null, { socket: socketMessage });
	}
	function GetServerSockets(call, callback) {
	    const serverId = parseInt(call.request.server_id, 10);
	    const serverEntry = entityMaps["server" /* EntityTypes.server */].getElementByKey(serverId);
	    if (serverEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No server data found for id ' + serverId,
	        });
	        return;
	    }
	    const startId = parseInt(call.request.start_socket_id, 10);
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const resolvedInfo = serverEntry.getInfo();
	    // If we wanted to include listener sockets in the result, this line would
	    // instead say
	    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
	    const allSockets = resolvedInfo.sessionChildren.sockets;
	    const resultList = [];
	    let i;
	    for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(socketRefToMessage(i.pointer[1].ref));
	    }
	    callback(null, {
	        socket_ref: resultList,
	        end: i.equals(allSockets.end()),
	    });
	}
	function getChannelzHandlers() {
	    return {
	        GetChannel,
	        GetTopChannels,
	        GetServer,
	        GetServers,
	        GetSubchannel,
	        GetSocket,
	        GetServerSockets,
	    };
	}
	channelz.getChannelzHandlers = getChannelzHandlers;
	let loadedChannelzDefinition = null;
	function getChannelzServiceDefinition() {
	    if (loadedChannelzDefinition) {
	        return loadedChannelzDefinition;
	    }
	    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at
	     * runtime for users who will not use/enable channelz. */
	    const loaderLoadSync = requireSrc()
	        .loadSync;
	    const loadedProto = loaderLoadSync('channelz.proto', {
	        keepCase: true,
	        longs: String,
	        enums: String,
	        defaults: true,
	        oneofs: true,
	        includeDirs: [`${__dirname}/../../proto`],
	    });
	    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
	    loadedChannelzDefinition =
	        channelzGrpcObject.grpc.channelz.v1.Channelz.service;
	    return loadedChannelzDefinition;
	}
	channelz.getChannelzServiceDefinition = getChannelzServiceDefinition;
	function setup() {
	    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
	}
	channelz.setup = setup;
	
	return channelz;
}

var hasRequiredSubchannel;

function requireSubchannel () {
	if (hasRequiredSubchannel) return subchannel;
	hasRequiredSubchannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannel, "__esModule", { value: true });
	subchannel.Subchannel = void 0;
	const connectivity_state_1 = connectivityState;
	const backoff_timeout_1 = requireBackoffTimeout();
	const logging = logging$8;
	const constants_1 = constants;
	const uri_parser_1 = uriParser;
	const subchannel_address_1 = subchannelAddress;
	const channelz_1 = requireChannelz();
	const TRACER_NAME = 'subchannel';
	/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
	 * have a constant for the max signed 32 bit integer, so this is a simple way
	 * to calculate it */
	const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
	class Subchannel {
	    /**
	     * A class representing a connection to a single backend.
	     * @param channelTarget The target string for the channel as a whole
	     * @param subchannelAddress The address for the backend that this subchannel
	     *     will connect to
	     * @param options The channel options, plus any specific subchannel options
	     *     for this subchannel
	     * @param credentials The channel credentials used to establish this
	     *     connection
	     */
	    constructor(channelTarget, subchannelAddress, options, credentials, connector) {
	        var _a;
	        this.channelTarget = channelTarget;
	        this.subchannelAddress = subchannelAddress;
	        this.options = options;
	        this.credentials = credentials;
	        this.connector = connector;
	        /**
	         * The subchannel's current connectivity state. Invariant: `session` === `null`
	         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
	         */
	        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The underlying http2 session used to make requests.
	         */
	        this.transport = null;
	        /**
	         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
	         * CONNECTING instead of IDLE when the backoff timeout ends.
	         */
	        this.continueConnecting = false;
	        /**
	         * A list of listener functions that will be called whenever the connectivity
	         * state changes. Will be modified by `addConnectivityStateListener` and
	         * `removeConnectivityStateListener`
	         */
	        this.stateListeners = new Set();
	        /**
	         * Tracks channels and subchannel pools with references to this subchannel
	         */
	        this.refcount = 0;
	        // Channelz info
	        this.channelzEnabled = true;
	        const backoffOptions = {
	            initialDelay: options['grpc.initial_reconnect_backoff_ms'],
	            maxDelay: options['grpc.max_reconnect_backoff_ms'],
	        };
	        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
	            this.handleBackoffTimer();
	        }, backoffOptions);
	        this.backoffTimeout.unref();
	        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
	        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;
	        if (options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	            this.channelzTrace = new channelz_1.ChannelzTraceStub();
	            this.callTracker = new channelz_1.ChannelzCallTrackerStub();
	            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
	        }
	        else {
	            this.channelzTrace = new channelz_1.ChannelzTrace();
	            this.callTracker = new channelz_1.ChannelzCallTracker();
	            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
	            this.streamTracker = new channelz_1.ChannelzCallTracker();
	        }
	        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
	        this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');
	        this.trace('Subchannel constructed with options ' +
	            JSON.stringify(options, undefined, 2));
	    }
	    getChannelzInfo() {
	        return {
	            state: this.connectivityState,
	            trace: this.channelzTrace,
	            callTracker: this.callTracker,
	            children: this.childrenTracker.getChildLists(),
	            target: this.subchannelAddressString,
	        };
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    refTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    handleBackoffTimer() {
	        if (this.continueConnecting) {
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
	        }
	        else {
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
	        }
	    }
	    /**
	     * Start a backoff timer with the current nextBackoff timeout
	     */
	    startBackoff() {
	        this.backoffTimeout.runOnce();
	    }
	    stopBackoff() {
	        this.backoffTimeout.stop();
	        this.backoffTimeout.reset();
	    }
	    startConnectingInternal() {
	        let options = this.options;
	        if (options['grpc.keepalive_time_ms']) {
	            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
	            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });
	        }
	        this.connector
	            .connect(this.subchannelAddress, this.credentials, options)
	            .then(transport => {
	            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
	                this.transport = transport;
	                if (this.channelzEnabled) {
	                    this.childrenTracker.refChild(transport.getChannelzRef());
	                }
	                transport.addDisconnectListener(tooManyPings => {
	                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
	                    if (tooManyPings && this.keepaliveTime > 0) {
	                        this.keepaliveTime *= 2;
	                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
	                    }
	                });
	            }
	            else {
	                /* If we can't transition from CONNECTING to READY here, we will
	                 * not be using this transport, so release its resources. */
	                transport.shutdown();
	            }
	        }, error => {
	            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
	        });
	    }
	    /**
	     * Initiate a state transition from any element of oldStates to the new
	     * state. If the current connectivityState is not in oldStates, do nothing.
	     * @param oldStates The set of states to transition from
	     * @param newState The state to transition to
	     * @returns True if the state changed, false otherwise
	     */
	    transitionToState(oldStates, newState, errorMessage) {
	        var _a, _b;
	        if (oldStates.indexOf(this.connectivityState) === -1) {
	            return false;
	        }
	        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
	        }
	        const previousState = this.connectivityState;
	        this.connectivityState = newState;
	        switch (newState) {
	            case connectivity_state_1.ConnectivityState.READY:
	                this.stopBackoff();
	                break;
	            case connectivity_state_1.ConnectivityState.CONNECTING:
	                this.startBackoff();
	                this.startConnectingInternal();
	                this.continueConnecting = false;
	                break;
	            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
	                if (this.channelzEnabled && this.transport) {
	                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
	                }
	                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();
	                this.transport = null;
	                /* If the backoff timer has already ended by the time we get to the
	                 * TRANSIENT_FAILURE state, we want to immediately transition out of
	                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */
	                if (!this.backoffTimeout.isRunning()) {
	                    process.nextTick(() => {
	                        this.handleBackoffTimer();
	                    });
	                }
	                break;
	            case connectivity_state_1.ConnectivityState.IDLE:
	                if (this.channelzEnabled && this.transport) {
	                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
	                }
	                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();
	                this.transport = null;
	                break;
	            default:
	                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
	        }
	        for (const listener of this.stateListeners) {
	            listener(this, previousState, newState, this.keepaliveTime, errorMessage);
	        }
	        return true;
	    }
	    ref() {
	        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));
	        this.refcount += 1;
	    }
	    unref() {
	        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));
	        this.refcount -= 1;
	        if (this.refcount === 0) {
	            this.channelzTrace.addTrace('CT_INFO', 'Shutting down');
	            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	            process.nextTick(() => {
	                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
	            });
	        }
	    }
	    unrefIfOneRef() {
	        if (this.refcount === 1) {
	            this.unref();
	            return true;
	        }
	        return false;
	    }
	    createCall(metadata, host, method, listener) {
	        if (!this.transport) {
	            throw new Error('Cannot create call, subchannel not READY');
	        }
	        let statsTracker;
	        if (this.channelzEnabled) {
	            this.callTracker.addCallStarted();
	            this.streamTracker.addCallStarted();
	            statsTracker = {
	                onCallEnd: status => {
	                    if (status.code === constants_1.Status.OK) {
	                        this.callTracker.addCallSucceeded();
	                    }
	                    else {
	                        this.callTracker.addCallFailed();
	                    }
	                },
	            };
	        }
	        else {
	            statsTracker = {};
	        }
	        return this.transport.createCall(metadata, host, method, listener, statsTracker);
	    }
	    /**
	     * If the subchannel is currently IDLE, start connecting and switch to the
	     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
	     * the next time it would transition to IDLE, start connecting again instead.
	     * Otherwise, do nothing.
	     */
	    startConnecting() {
	        process.nextTick(() => {
	            /* First, try to transition from IDLE to connecting. If that doesn't happen
	             * because the state is not currently IDLE, check if it is
	             * TRANSIENT_FAILURE, and if so indicate that it should go back to
	             * connecting after the backoff timer ends. Otherwise do nothing */
	            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
	                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                    this.continueConnecting = true;
	                }
	            }
	        });
	    }
	    /**
	     * Get the subchannel's current connectivity state.
	     */
	    getConnectivityState() {
	        return this.connectivityState;
	    }
	    /**
	     * Add a listener function to be called whenever the subchannel's
	     * connectivity state changes.
	     * @param listener
	     */
	    addConnectivityStateListener(listener) {
	        this.stateListeners.add(listener);
	    }
	    /**
	     * Remove a listener previously added with `addConnectivityStateListener`
	     * @param listener A reference to a function previously passed to
	     *     `addConnectivityStateListener`
	     */
	    removeConnectivityStateListener(listener) {
	        this.stateListeners.delete(listener);
	    }
	    /**
	     * Reset the backoff timeout, and immediately start connecting if in backoff.
	     */
	    resetBackoff() {
	        process.nextTick(() => {
	            this.backoffTimeout.reset();
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
	        });
	    }
	    getAddress() {
	        return this.subchannelAddressString;
	    }
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    isHealthy() {
	        return true;
	    }
	    addHealthStateWatcher(listener) {
	        // Do nothing with the listener
	    }
	    removeHealthStateWatcher(listener) {
	        // Do nothing with the listener
	    }
	    getRealSubchannel() {
	        return this;
	    }
	    realSubchannelEquals(other) {
	        return other.getRealSubchannel() === this;
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        if (newKeepaliveTime > this.keepaliveTime) {
	            this.keepaliveTime = newKeepaliveTime;
	        }
	    }
	}
	subchannel.Subchannel = Subchannel;
	
	return subchannel;
}

var transport = {};

var http_proxy = {};

var resolverDns = {};

var hasRequiredResolverDns;

function requireResolverDns () {
	if (hasRequiredResolverDns) return resolverDns;
	hasRequiredResolverDns = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.setup = exports.DEFAULT_PORT = void 0;
		const resolver_1 = resolver;
		const dns = require$$1$4;
		const util = require$$2;
		const service_config_1 = requireServiceConfig();
		const constants_1 = constants;
		const metadata_1 = metadata;
		const logging = logging$8;
		const constants_2 = constants;
		const uri_parser_1 = uriParser;
		const net_1 = require$$0$3;
		const backoff_timeout_1 = requireBackoffTimeout();
		const TRACER_NAME = 'dns_resolver';
		function trace(text) {
		    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
		}
		/**
		 * The default TCP port to connect to if not explicitly specified in the target.
		 */
		exports.DEFAULT_PORT = 443;
		const DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;
		const resolveTxtPromise = util.promisify(dns.resolveTxt);
		const dnsLookupPromise = util.promisify(dns.lookup);
		/**
		 * Resolver implementation that handles DNS names and IP addresses.
		 */
		class DnsResolver {
		    constructor(target, listener, channelOptions) {
		        var _a, _b, _c;
		        this.target = target;
		        this.listener = listener;
		        this.pendingLookupPromise = null;
		        this.pendingTxtPromise = null;
		        this.latestLookupResult = null;
		        this.latestServiceConfig = null;
		        this.latestServiceConfigError = null;
		        this.continueResolving = false;
		        this.isNextResolutionTimerRunning = false;
		        this.isServiceConfigEnabled = true;
		        this.returnedIpResult = false;
		        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
		        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
		        if (hostPort === null) {
		            this.ipResult = null;
		            this.dnsHostname = null;
		            this.port = null;
		        }
		        else {
		            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
		                this.ipResult = [
		                    {
		                        addresses: [
		                            {
		                                host: hostPort.host,
		                                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,
		                            },
		                        ],
		                    },
		                ];
		                this.dnsHostname = null;
		                this.port = null;
		            }
		            else {
		                this.ipResult = null;
		                this.dnsHostname = hostPort.host;
		                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;
		            }
		        }
		        this.percentage = Math.random() * 100;
		        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {
		            this.isServiceConfigEnabled = false;
		        }
		        this.defaultResolutionError = {
		            code: constants_1.Status.UNAVAILABLE,
		            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
		            metadata: new metadata_1.Metadata(),
		        };
		        const backoffOptions = {
		            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
		            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
		        };
		        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
		            if (this.continueResolving) {
		                this.startResolutionWithBackoff();
		            }
		        }, backoffOptions);
		        this.backoff.unref();
		        this.minTimeBetweenResolutionsMs =
		            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
		        this.nextResolutionTimer = setTimeout(() => { }, 0);
		        clearTimeout(this.nextResolutionTimer);
		    }
		    /**
		     * If the target is an IP address, just provide that address as a result.
		     * Otherwise, initiate A, AAAA, and TXT lookups
		     */
		    startResolution() {
		        if (this.ipResult !== null) {
		            if (!this.returnedIpResult) {
		                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));
		                setImmediate(() => {
		                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
		                });
		                this.returnedIpResult = true;
		            }
		            this.backoff.stop();
		            this.backoff.reset();
		            this.stopNextResolutionTimer();
		            return;
		        }
		        if (this.dnsHostname === null) {
		            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));
		            setImmediate(() => {
		                this.listener.onError({
		                    code: constants_1.Status.UNAVAILABLE,
		                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
		                    metadata: new metadata_1.Metadata(),
		                });
		            });
		            this.stopNextResolutionTimer();
		        }
		        else {
		            if (this.pendingLookupPromise !== null) {
		                return;
		            }
		            trace('Looking up DNS hostname ' + this.dnsHostname);
		            /* We clear out latestLookupResult here to ensure that it contains the
		             * latest result since the last time we started resolving. That way, the
		             * TXT resolution handler can use it, but only if it finishes second. We
		             * don't clear out any previous service config results because it's
		             * better to use a service config that's slightly out of date than to
		             * revert to an effectively blank one. */
		            this.latestLookupResult = null;
		            const hostname = this.dnsHostname;
		            /* We lookup both address families here and then split them up later
		             * because when looking up a single family, dns.lookup outputs an error
		             * if the name exists but there are no records for that family, and that
		             * error is indistinguishable from other kinds of errors */
		            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });
		            this.pendingLookupPromise.then(addressList => {
		                if (this.pendingLookupPromise === null) {
		                    return;
		                }
		                this.pendingLookupPromise = null;
		                this.backoff.reset();
		                this.backoff.stop();
		                const subchannelAddresses = addressList.map(addr => ({ host: addr.address, port: +this.port }));
		                this.latestLookupResult = subchannelAddresses.map(address => ({
		                    addresses: [address],
		                }));
		                const allAddressesString = '[' +
		                    subchannelAddresses
		                        .map(addr => addr.host + ':' + addr.port)
		                        .join(',') +
		                    ']';
		                trace('Resolved addresses for target ' +
		                    (0, uri_parser_1.uriToString)(this.target) +
		                    ': ' +
		                    allAddressesString);
		                if (this.latestLookupResult.length === 0) {
		                    this.listener.onError(this.defaultResolutionError);
		                    return;
		                }
		                /* If the TXT lookup has not yet finished, both of the last two
		                 * arguments will be null, which is the equivalent of getting an
		                 * empty TXT response. When the TXT lookup does finish, its handler
		                 * can update the service config by using the same address list */
		                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
		            }, err => {
		                if (this.pendingLookupPromise === null) {
		                    return;
		                }
		                trace('Resolution error for target ' +
		                    (0, uri_parser_1.uriToString)(this.target) +
		                    ': ' +
		                    err.message);
		                this.pendingLookupPromise = null;
		                this.stopNextResolutionTimer();
		                this.listener.onError(this.defaultResolutionError);
		            });
		            /* If there already is a still-pending TXT resolution, we can just use
		             * that result when it comes in */
		            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
		                /* We handle the TXT query promise differently than the others because
		                 * the name resolution attempt as a whole is a success even if the TXT
		                 * lookup fails */
		                this.pendingTxtPromise = resolveTxtPromise(hostname);
		                this.pendingTxtPromise.then(txtRecord => {
		                    if (this.pendingTxtPromise === null) {
		                        return;
		                    }
		                    this.pendingTxtPromise = null;
		                    try {
		                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
		                    }
		                    catch (err) {
		                        this.latestServiceConfigError = {
		                            code: constants_1.Status.UNAVAILABLE,
		                            details: `Parsing service config failed with error ${err.message}`,
		                            metadata: new metadata_1.Metadata(),
		                        };
		                    }
		                    if (this.latestLookupResult !== null) {
		                        /* We rely here on the assumption that calling this function with
		                         * identical parameters will be essentialy idempotent, and calling
		                         * it with the same address list and a different service config
		                         * should result in a fast and seamless switchover. */
		                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
		                    }
		                }, err => {
		                    /* If TXT lookup fails we should do nothing, which means that we
		                     * continue to use the result of the most recent successful lookup,
		                     * or the default null config object if there has never been a
		                     * successful lookup. We do not set the latestServiceConfigError
		                     * here because that is specifically used for response validation
		                     * errors. We still need to handle this error so that it does not
		                     * bubble up as an unhandled promise rejection. */
		                });
		            }
		        }
		    }
		    startNextResolutionTimer() {
		        var _a, _b;
		        clearTimeout(this.nextResolutionTimer);
		        this.nextResolutionTimer = setTimeout(() => {
		            this.stopNextResolutionTimer();
		            if (this.continueResolving) {
		                this.startResolutionWithBackoff();
		            }
		        }, this.minTimeBetweenResolutionsMs);
		        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
		        this.isNextResolutionTimerRunning = true;
		    }
		    stopNextResolutionTimer() {
		        clearTimeout(this.nextResolutionTimer);
		        this.isNextResolutionTimerRunning = false;
		    }
		    startResolutionWithBackoff() {
		        if (this.pendingLookupPromise === null) {
		            this.continueResolving = false;
		            this.backoff.runOnce();
		            this.startNextResolutionTimer();
		            this.startResolution();
		        }
		    }
		    updateResolution() {
		        /* If there is a pending lookup, just let it finish. Otherwise, if the
		         * nextResolutionTimer or backoff timer is running, set the
		         * continueResolving flag to resolve when whichever of those timers
		         * fires. Otherwise, start resolving immediately. */
		        if (this.pendingLookupPromise === null) {
		            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
		                if (this.isNextResolutionTimerRunning) {
		                    trace('resolution update delayed by "min time between resolutions" rate limit');
		                }
		                else {
		                    trace('resolution update delayed by backoff timer until ' +
		                        this.backoff.getEndTime().toISOString());
		                }
		                this.continueResolving = true;
		            }
		            else {
		                this.startResolutionWithBackoff();
		            }
		        }
		    }
		    /**
		     * Reset the resolver to the same state it had when it was created. In-flight
		     * DNS requests cannot be cancelled, but they are discarded and their results
		     * will be ignored.
		     */
		    destroy() {
		        this.continueResolving = false;
		        this.backoff.reset();
		        this.backoff.stop();
		        this.stopNextResolutionTimer();
		        this.pendingLookupPromise = null;
		        this.pendingTxtPromise = null;
		        this.latestLookupResult = null;
		        this.latestServiceConfig = null;
		        this.latestServiceConfigError = null;
		        this.returnedIpResult = false;
		    }
		    /**
		     * Get the default authority for the given target. For IP targets, that is
		     * the IP address. For DNS targets, it is the hostname.
		     * @param target
		     */
		    static getDefaultAuthority(target) {
		        return target.path;
		    }
		}
		/**
		 * Set up the DNS resolver class by registering it as the handler for the
		 * "dns:" prefix and as the default resolver.
		 */
		function setup() {
		    (0, resolver_1.registerResolver)('dns', DnsResolver);
		    (0, resolver_1.registerDefaultScheme)('dns');
		}
		exports.setup = setup;
		
	} (resolverDns));
	return resolverDns;
}

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(http_proxy, "__esModule", { value: true });
http_proxy.getProxiedConnection = http_proxy.mapProxyName = void 0;
const logging_1 = logging$8;
const constants_1$9 = constants;
const resolver_1$1 = resolver;
const http = require$$3$1;
const tls = require$$0$1;
const logging$6 = logging$8;
const subchannel_address_1$1 = subchannelAddress;
const uri_parser_1$2 = uriParser;
const url_1 = require$$7;
const resolver_dns_1 = requireResolverDns();
const TRACER_NAME$5 = 'proxy';
function trace(text) {
    logging$6.trace(constants_1$9.LogVerbosity.DEBUG, TRACER_NAME$5, text);
}
function getProxyInfo() {
    let proxyEnv = '';
    let envVar = '';
    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
     * fallback behavior can be removed if there's a demand for it.
     */
    if (process.env.grpc_proxy) {
        envVar = 'grpc_proxy';
        proxyEnv = process.env.grpc_proxy;
    }
    else if (process.env.https_proxy) {
        envVar = 'https_proxy';
        proxyEnv = process.env.https_proxy;
    }
    else if (process.env.http_proxy) {
        envVar = 'http_proxy';
        proxyEnv = process.env.http_proxy;
    }
    else {
        return {};
    }
    let proxyUrl;
    try {
        proxyUrl = new url_1.URL(proxyEnv);
    }
    catch (e) {
        (0, logging_1.log)(constants_1$9.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
    }
    if (proxyUrl.protocol !== 'http:') {
        (0, logging_1.log)(constants_1$9.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
    }
    let userCred = null;
    if (proxyUrl.username) {
        if (proxyUrl.password) {
            (0, logging_1.log)(constants_1$9.LogVerbosity.INFO, 'userinfo found in proxy URI');
            userCred = `${proxyUrl.username}:${proxyUrl.password}`;
        }
        else {
            userCred = proxyUrl.username;
        }
    }
    const hostname = proxyUrl.hostname;
    let port = proxyUrl.port;
    /* The proxy URL uses the scheme "http:", which has a default port number of
     * 80. We need to set that explicitly here if it is omitted because otherwise
     * it will use gRPC's default port 443. */
    if (port === '') {
        port = '80';
    }
    const result = {
        address: `${hostname}:${port}`,
    };
    if (userCred) {
        result.creds = userCred;
    }
    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);
    return result;
}
function getNoProxyHostList() {
    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
    let noProxyStr = process.env.no_grpc_proxy;
    let envVar = 'no_grpc_proxy';
    if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = 'no_proxy';
    }
    if (noProxyStr) {
        trace('No proxy server list set by environment variable ' + envVar);
        return noProxyStr.split(',');
    }
    else {
        return [];
    }
}
function mapProxyName(target, options) {
    var _a;
    const noProxyResult = {
        target: target,
        extraOptions: {},
    };
    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
    }
    if (target.scheme === 'unix') {
        return noProxyResult;
    }
    const proxyInfo = getProxyInfo();
    if (!proxyInfo.address) {
        return noProxyResult;
    }
    const hostPort = (0, uri_parser_1$2.splitHostPort)(target.path);
    if (!hostPort) {
        return noProxyResult;
    }
    const serverHost = hostPort.host;
    for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1$2.uriToString)(target));
            return noProxyResult;
        }
    }
    const extraOptions = {
        'grpc.http_connect_target': (0, uri_parser_1$2.uriToString)(target),
    };
    if (proxyInfo.creds) {
        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
    }
    return {
        target: {
            scheme: 'dns',
            path: proxyInfo.address,
        },
        extraOptions: extraOptions,
    };
}
http_proxy.mapProxyName = mapProxyName;
function getProxiedConnection(address, channelOptions, connectionOptions) {
    var _a;
    if (!('grpc.http_connect_target' in channelOptions)) {
        return Promise.resolve({});
    }
    const realTarget = channelOptions['grpc.http_connect_target'];
    const parsedTarget = (0, uri_parser_1$2.parseUri)(realTarget);
    if (parsedTarget === null) {
        return Promise.resolve({});
    }
    const splitHostPost = (0, uri_parser_1$2.splitHostPort)(parsedTarget.path);
    if (splitHostPost === null) {
        return Promise.resolve({});
    }
    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;
    const options = {
        method: 'CONNECT',
        path: hostPort,
    };
    const headers = {
        Host: hostPort,
    };
    // Connect to the subchannel address as a proxy
    if ((0, subchannel_address_1$1.isTcpSubchannelAddress)(address)) {
        options.host = address.host;
        options.port = address.port;
    }
    else {
        options.socketPath = address.path;
    }
    if ('grpc.http_connect_creds' in channelOptions) {
        headers['Proxy-Authorization'] =
            'Basic ' +
                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');
    }
    options.headers = headers;
    const proxyAddressString = (0, subchannel_address_1$1.subchannelAddressToString)(address);
    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
    return new Promise((resolve, reject) => {
        const request = http.request(options);
        request.once('connect', (res, socket, head) => {
            var _a;
            request.removeAllListeners();
            socket.removeAllListeners();
            if (res.statusCode === 200) {
                trace('Successfully connected to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString);
                if ('secureContext' in connectionOptions) {
                    /* The proxy is connecting to a TLS server, so upgrade this socket
                     * connection to a TLS connection.
                     * This is a workaround for https://github.com/nodejs/node/issues/32922
                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
                    const targetPath = (0, resolver_1$1.getDefaultAuthority)(parsedTarget);
                    const hostPort = (0, uri_parser_1$2.splitHostPort)(targetPath);
                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {
                        trace('Successfully established a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString);
                        resolve({ socket: cts, realTarget: parsedTarget });
                    });
                    cts.on('error', (error) => {
                        trace('Failed to establish a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString +
                            ' with error ' +
                            error.message);
                        reject();
                    });
                }
                else {
                    trace('Successfully established a plaintext connection to ' +
                        options.path +
                        ' through proxy ' +
                        proxyAddressString);
                    resolve({
                        socket,
                        realTarget: parsedTarget,
                    });
                }
            }
            else {
                (0, logging_1.log)(constants_1$9.LogVerbosity.ERROR, 'Failed to connect to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString +
                    ' with status ' +
                    res.statusCode);
                reject();
            }
        });
        request.once('error', err => {
            request.removeAllListeners();
            (0, logging_1.log)(constants_1$9.LogVerbosity.ERROR, 'Failed to connect to proxy ' +
                proxyAddressString +
                ' with error ' +
                err.message);
            reject();
        });
        request.end();
    });
}
http_proxy.getProxiedConnection = getProxiedConnection;

var subchannelCall = {};

var streamDecoder = {};

var hasRequiredStreamDecoder;

function requireStreamDecoder () {
	if (hasRequiredStreamDecoder) return streamDecoder;
	hasRequiredStreamDecoder = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(streamDecoder, "__esModule", { value: true });
	streamDecoder.StreamDecoder = void 0;
	var ReadState;
	(function (ReadState) {
	    ReadState[ReadState["NO_DATA"] = 0] = "NO_DATA";
	    ReadState[ReadState["READING_SIZE"] = 1] = "READING_SIZE";
	    ReadState[ReadState["READING_MESSAGE"] = 2] = "READING_MESSAGE";
	})(ReadState || (ReadState = {}));
	class StreamDecoder {
	    constructor() {
	        this.readState = ReadState.NO_DATA;
	        this.readCompressFlag = Buffer.alloc(1);
	        this.readPartialSize = Buffer.alloc(4);
	        this.readSizeRemaining = 4;
	        this.readMessageSize = 0;
	        this.readPartialMessage = [];
	        this.readMessageRemaining = 0;
	    }
	    write(data) {
	        let readHead = 0;
	        let toRead;
	        const result = [];
	        while (readHead < data.length) {
	            switch (this.readState) {
	                case ReadState.NO_DATA:
	                    this.readCompressFlag = data.slice(readHead, readHead + 1);
	                    readHead += 1;
	                    this.readState = ReadState.READING_SIZE;
	                    this.readPartialSize.fill(0);
	                    this.readSizeRemaining = 4;
	                    this.readMessageSize = 0;
	                    this.readMessageRemaining = 0;
	                    this.readPartialMessage = [];
	                    break;
	                case ReadState.READING_SIZE:
	                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);
	                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
	                    this.readSizeRemaining -= toRead;
	                    readHead += toRead;
	                    // readSizeRemaining >=0 here
	                    if (this.readSizeRemaining === 0) {
	                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);
	                        this.readMessageRemaining = this.readMessageSize;
	                        if (this.readMessageRemaining > 0) {
	                            this.readState = ReadState.READING_MESSAGE;
	                        }
	                        else {
	                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
	                            this.readState = ReadState.NO_DATA;
	                            result.push(message);
	                        }
	                    }
	                    break;
	                case ReadState.READING_MESSAGE:
	                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);
	                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
	                    this.readMessageRemaining -= toRead;
	                    readHead += toRead;
	                    // readMessageRemaining >=0 here
	                    if (this.readMessageRemaining === 0) {
	                        // At this point, we have read a full message
	                        const framedMessageBuffers = [
	                            this.readCompressFlag,
	                            this.readPartialSize,
	                        ].concat(this.readPartialMessage);
	                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
	                        this.readState = ReadState.NO_DATA;
	                        result.push(framedMessage);
	                    }
	                    break;
	                default:
	                    throw new Error('Unexpected read state');
	            }
	        }
	        return result;
	    }
	}
	streamDecoder.StreamDecoder = StreamDecoder;
	
	return streamDecoder;
}

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(subchannelCall, "__esModule", { value: true });
subchannelCall.Http2SubchannelCall = void 0;
const http2$2 = require$$0$5;
const os$1 = require$$0$2;
const constants_1$8 = constants;
const metadata_1$5 = metadata;
const stream_decoder_1 = requireStreamDecoder();
const logging$5 = logging$8;
const constants_2 = constants;
const TRACER_NAME$4 = 'subchannel_call';
/**
 * Should do approximately the same thing as util.getSystemErrorName but the
 * TypeScript types don't have that function for some reason so I just made my
 * own.
 * @param errno
 */
function getSystemErrorName(errno) {
    for (const [name, num] of Object.entries(os$1.constants.errno)) {
        if (num === errno) {
            return name;
        }
    }
    return 'Unknown system error ' + errno;
}
class Http2SubchannelCall {
    constructor(http2Stream, callEventTracker, listener, transport, callId) {
        this.http2Stream = http2Stream;
        this.callEventTracker = callEventTracker;
        this.listener = listener;
        this.transport = transport;
        this.callId = callId;
        this.decoder = new stream_decoder_1.StreamDecoder();
        this.isReadFilterPending = false;
        this.isPushPending = false;
        this.canPush = false;
        /**
         * Indicates that an 'end' event has come from the http2 stream, so there
         * will be no more data events.
         */
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        // Status code mapped from :status. To be used if grpc-status is not received
        this.mappedStatusCode = constants_1$8.Status.UNKNOWN;
        // This is populated (non-null) if and only if the call has ended
        this.finalStatus = null;
        this.internalError = null;
        this.serverEndedCall = false;
        http2Stream.on('response', (headers, flags) => {
            let headersString = '';
            for (const header of Object.keys(headers)) {
                headersString += '\t\t' + header + ': ' + headers[header] + '\n';
            }
            this.trace('Received server headers:\n' + headersString);
            switch (headers[':status']) {
                // TODO(murgatroid99): handle 100 and 101
                case 400:
                    this.mappedStatusCode = constants_1$8.Status.INTERNAL;
                    break;
                case 401:
                    this.mappedStatusCode = constants_1$8.Status.UNAUTHENTICATED;
                    break;
                case 403:
                    this.mappedStatusCode = constants_1$8.Status.PERMISSION_DENIED;
                    break;
                case 404:
                    this.mappedStatusCode = constants_1$8.Status.UNIMPLEMENTED;
                    break;
                case 429:
                case 502:
                case 503:
                case 504:
                    this.mappedStatusCode = constants_1$8.Status.UNAVAILABLE;
                    break;
                default:
                    this.mappedStatusCode = constants_1$8.Status.UNKNOWN;
            }
            if (flags & http2$2.constants.NGHTTP2_FLAG_END_STREAM) {
                this.handleTrailers(headers);
            }
            else {
                let metadata;
                try {
                    metadata = metadata_1$5.Metadata.fromHttp2Headers(headers);
                }
                catch (error) {
                    this.endCall({
                        code: constants_1$8.Status.UNKNOWN,
                        details: error.message,
                        metadata: new metadata_1$5.Metadata(),
                    });
                    return;
                }
                this.listener.onReceiveMetadata(metadata);
            }
        });
        http2Stream.on('trailers', (headers) => {
            this.handleTrailers(headers);
        });
        http2Stream.on('data', (data) => {
            /* If the status has already been output, allow the http2 stream to
             * drain without processing the data. */
            if (this.statusOutput) {
                return;
            }
            this.trace('receive HTTP/2 data frame of length ' + data.length);
            const messages = this.decoder.write(data);
            for (const message of messages) {
                this.trace('parsed message of length ' + message.length);
                this.callEventTracker.addMessageReceived();
                this.tryPush(message);
            }
        });
        http2Stream.on('end', () => {
            this.readsClosed = true;
            this.maybeOutputStatus();
        });
        http2Stream.on('close', () => {
            this.serverEndedCall = true;
            /* Use process.next tick to ensure that this code happens after any
             * "error" event that may be emitted at about the same time, so that
             * we can bubble up the error message from that event. */
            process.nextTick(() => {
                var _a;
                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);
                /* If we have a final status with an OK status code, that means that
                 * we have received all of the messages and we have processed the
                 * trailers and the call completed successfully, so it doesn't matter
                 * how the stream ends after that */
                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1$8.Status.OK) {
                    return;
                }
                let code;
                let details = '';
                switch (http2Stream.rstCode) {
                    case http2$2.constants.NGHTTP2_NO_ERROR:
                        /* If we get a NO_ERROR code and we already have a status, the
                         * stream completed properly and we just haven't fully processed
                         * it yet */
                        if (this.finalStatus !== null) {
                            return;
                        }
                        code = constants_1$8.Status.INTERNAL;
                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
                        break;
                    case http2$2.constants.NGHTTP2_REFUSED_STREAM:
                        code = constants_1$8.Status.UNAVAILABLE;
                        details = 'Stream refused by server';
                        break;
                    case http2$2.constants.NGHTTP2_CANCEL:
                        code = constants_1$8.Status.CANCELLED;
                        details = 'Call cancelled';
                        break;
                    case http2$2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                        code = constants_1$8.Status.RESOURCE_EXHAUSTED;
                        details = 'Bandwidth exhausted or memory limit exceeded';
                        break;
                    case http2$2.constants.NGHTTP2_INADEQUATE_SECURITY:
                        code = constants_1$8.Status.PERMISSION_DENIED;
                        details = 'Protocol not secure enough';
                        break;
                    case http2$2.constants.NGHTTP2_INTERNAL_ERROR:
                        code = constants_1$8.Status.INTERNAL;
                        if (this.internalError === null) {
                            /* This error code was previously handled in the default case, and
                             * there are several instances of it online, so I wanted to
                             * preserve the original error message so that people find existing
                             * information in searches, but also include the more recognizable
                             * "Internal server error" message. */
                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
                        }
                        else {
                            if (this.internalError.code === 'ECONNRESET' ||
                                this.internalError.code === 'ETIMEDOUT') {
                                code = constants_1$8.Status.UNAVAILABLE;
                                details = this.internalError.message;
                            }
                            else {
                                /* The "Received RST_STREAM with code ..." error is preserved
                                 * here for continuity with errors reported online, but the
                                 * error message at the end will probably be more relevant in
                                 * most cases. */
                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                            }
                        }
                        break;
                    default:
                        code = constants_1$8.Status.INTERNAL;
                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
                }
                // This is a no-op if trailers were received at all.
                // This is OK, because status codes emitted here correspond to more
                // catastrophic issues that prevent us from receiving trailers in the
                // first place.
                this.endCall({
                    code,
                    details,
                    metadata: new metadata_1$5.Metadata(),
                    rstCode: http2Stream.rstCode,
                });
            });
        });
        http2Stream.on('error', (err) => {
            /* We need an error handler here to stop "Uncaught Error" exceptions
             * from bubbling up. However, errors here should all correspond to
             * "close" events, where we will handle the error more granularly */
            /* Specifically looking for stream errors that were *not* constructed
             * from a RST_STREAM response here:
             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
             */
            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {
                this.trace('Node error event: message=' +
                    err.message +
                    ' code=' +
                    err.code +
                    ' errno=' +
                    getSystemErrorName(err.errno) +
                    ' syscall=' +
                    err.syscall);
                this.internalError = err;
            }
            this.callEventTracker.onStreamEnd(false);
        });
    }
    getDeadlineInfo() {
        return [`remote_addr=${this.getPeer()}`];
    }
    onDisconnect() {
        this.endCall({
            code: constants_1$8.Status.UNAVAILABLE,
            details: 'Connection dropped',
            metadata: new metadata_1$5.Metadata(),
        });
    }
    outputStatus() {
        /* Precondition: this.finalStatus !== null */
        if (!this.statusOutput) {
            this.statusOutput = true;
            this.trace('ended with status: code=' +
                this.finalStatus.code +
                ' details="' +
                this.finalStatus.details +
                '"');
            this.callEventTracker.onCallEnd(this.finalStatus);
            /* We delay the actual action of bubbling up the status to insulate the
             * cleanup code in this class from any errors that may be thrown in the
             * upper layers as a result of bubbling up the status. In particular,
             * if the status is not OK, the "error" event may be emitted
             * synchronously at the top level, which will result in a thrown error if
             * the user does not handle that event. */
            process.nextTick(() => {
                this.listener.onReceiveStatus(this.finalStatus);
            });
            /* Leave the http2 stream in flowing state to drain incoming messages, to
             * ensure that the stream closure completes. The call stream already does
             * not push more messages after the status is output, so the messages go
             * nowhere either way. */
            this.http2Stream.resume();
        }
    }
    trace(text) {
        logging$5.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME$4, '[' + this.callId + '] ' + text);
    }
    /**
     * On first call, emits a 'status' event with the given StatusObject.
     * Subsequent calls are no-ops.
     * @param status The status of the call.
     */
    endCall(status) {
        /* If the status is OK and a new status comes in (e.g. from a
         * deserialization failure), that new status takes priority */
        if (this.finalStatus === null || this.finalStatus.code === constants_1$8.Status.OK) {
            this.finalStatus = status;
            this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
    }
    maybeOutputStatus() {
        if (this.finalStatus !== null) {
            /* The combination check of readsClosed and that the two message buffer
             * arrays are empty checks that there all incoming data has been fully
             * processed */
            if (this.finalStatus.code !== constants_1$8.Status.OK ||
                (this.readsClosed &&
                    this.unpushedReadMessages.length === 0 &&
                    !this.isReadFilterPending &&
                    !this.isPushPending)) {
                this.outputStatus();
            }
        }
    }
    push(message) {
        this.trace('pushing to reader message of length ' +
            (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        this.isPushPending = true;
        process.nextTick(() => {
            this.isPushPending = false;
            /* If we have already output the status any later messages should be
             * ignored, and can cause out-of-order operation errors higher up in the
             * stack. Checking as late as possible here to avoid any race conditions.
             */
            if (this.statusOutput) {
                return;
            }
            this.listener.onReceiveMessage(message);
            this.maybeOutputStatus();
        });
    }
    tryPush(messageBytes) {
        if (this.canPush) {
            this.http2Stream.pause();
            this.push(messageBytes);
        }
        else {
            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);
            this.unpushedReadMessages.push(messageBytes);
        }
    }
    handleTrailers(headers) {
        this.serverEndedCall = true;
        this.callEventTracker.onStreamEnd(true);
        let headersString = '';
        for (const header of Object.keys(headers)) {
            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
        }
        this.trace('Received server trailers:\n' + headersString);
        let metadata;
        try {
            metadata = metadata_1$5.Metadata.fromHttp2Headers(headers);
        }
        catch (e) {
            metadata = new metadata_1$5.Metadata();
        }
        const metadataMap = metadata.getMap();
        let code = this.mappedStatusCode;
        if (code === constants_1$8.Status.UNKNOWN &&
            typeof metadataMap['grpc-status'] === 'string') {
            const receivedStatus = Number(metadataMap['grpc-status']);
            if (receivedStatus in constants_1$8.Status) {
                code = receivedStatus;
                this.trace('received status code ' + receivedStatus + ' from server');
            }
            metadata.remove('grpc-status');
        }
        let details = '';
        if (typeof metadataMap['grpc-message'] === 'string') {
            try {
                details = decodeURI(metadataMap['grpc-message']);
            }
            catch (e) {
                details = metadataMap['grpc-message'];
            }
            metadata.remove('grpc-message');
            this.trace('received status details string "' + details + '" from server');
        }
        const status = { code, details, metadata };
        // This is a no-op if the call was already ended when handling headers.
        this.endCall(status);
    }
    destroyHttp2Stream() {
        var _a;
        // The http2 stream could already have been destroyed if cancelWithStatus
        // is called in response to an internal http2 error.
        if (this.http2Stream.destroyed) {
            return;
        }
        /* If the server ended the call, sending an RST_STREAM is redundant, so we
         * just half close on the client side instead to finish closing the stream.
         */
        if (this.serverEndedCall) {
            this.http2Stream.end();
        }
        else {
            /* If the call has ended with an OK status, communicate that when closing
             * the stream, partly to avoid a situation in which we detect an error
             * RST_STREAM as a result after we have the status */
            let code;
            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1$8.Status.OK) {
                code = http2$2.constants.NGHTTP2_NO_ERROR;
            }
            else {
                code = http2$2.constants.NGHTTP2_CANCEL;
            }
            this.trace('close http2 stream with code ' + code);
            this.http2Stream.close(code);
        }
    }
    cancelWithStatus(status, details) {
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1$5.Metadata() });
    }
    getStatus() {
        return this.finalStatus;
    }
    getPeer() {
        return this.transport.getPeerName();
    }
    getCallNumber() {
        return this.callId;
    }
    startRead() {
        /* If the stream has ended with an error, we should not emit any more
         * messages and we should communicate that the stream has ended */
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1$8.Status.OK) {
            this.readsClosed = true;
            this.maybeOutputStatus();
            return;
        }
        this.canPush = true;
        if (this.unpushedReadMessages.length > 0) {
            const nextMessage = this.unpushedReadMessages.shift();
            this.push(nextMessage);
            return;
        }
        /* Only resume reading from the http2Stream if we don't have any pending
         * messages to emit */
        this.http2Stream.resume();
    }
    sendMessageWithContext(context, message) {
        this.trace('write() called with message of length ' + message.length);
        const cb = (error) => {
            /* nextTick here ensures that no stream action can be taken in the call
             * stack of the write callback, in order to hopefully work around
             * https://github.com/nodejs/node/issues/49147 */
            process.nextTick(() => {
                var _a;
                let code = constants_1$8.Status.UNAVAILABLE;
                if ((error === null || error === void 0 ? void 0 : error.code) ===
                    'ERR_STREAM_WRITE_AFTER_END') {
                    code = constants_1$8.Status.INTERNAL;
                }
                if (error) {
                    this.cancelWithStatus(code, `Write error: ${error.message}`);
                }
                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
            });
        };
        this.trace('sending data chunk of length ' + message.length);
        this.callEventTracker.addMessageSent();
        try {
            this.http2Stream.write(message, cb);
        }
        catch (error) {
            this.endCall({
                code: constants_1$8.Status.UNAVAILABLE,
                details: `Write failed with error ${error.message}`,
                metadata: new metadata_1$5.Metadata(),
            });
        }
    }
    halfClose() {
        this.trace('end() called');
        this.trace('calling end() on HTTP/2 stream');
        this.http2Stream.end();
    }
}
subchannelCall.Http2SubchannelCall = Http2SubchannelCall;

var callNumber = {};

/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(callNumber, "__esModule", { value: true });
callNumber.getNextCallNumber = void 0;
let nextCallNumber = 0;
function getNextCallNumber() {
    return nextCallNumber++;
}
callNumber.getNextCallNumber = getNextCallNumber;

var hasRequiredTransport;

function requireTransport () {
	if (hasRequiredTransport) return transport;
	hasRequiredTransport = 1;
	/*
	 * Copyright 2023 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(transport, "__esModule", { value: true });
	transport.Http2SubchannelConnector = void 0;
	const http2 = require$$0$5;
	const tls_1 = require$$0$1;
	const channelz_1 = requireChannelz();
	const constants_1 = constants;
	const http_proxy_1 = http_proxy;
	const logging = logging$8;
	const resolver_1 = resolver;
	const subchannel_address_1 = subchannelAddress;
	const uri_parser_1 = uriParser;
	const net = require$$0$3;
	const subchannel_call_1 = subchannelCall;
	const call_number_1 = callNumber;
	const TRACER_NAME = 'transport';
	const FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';
	const clientVersion = require$$12.version;
	const { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
	const KEEPALIVE_TIMEOUT_MS = 20000;
	const tooManyPingsData = Buffer.from('too_many_pings', 'ascii');
	class Http2Transport {
	    constructor(session, subchannelAddress, options, 
	    /**
	     * Name of the remote server, if it is not the same as the subchannel
	     * address, i.e. if connecting through an HTTP CONNECT proxy.
	     */
	    remoteName) {
	        this.session = session;
	        this.remoteName = remoteName;
	        /**
	         * The amount of time in between sending pings
	         */
	        this.keepaliveTimeMs = -1;
	        /**
	         * The amount of time to wait for an acknowledgement after sending a ping
	         */
	        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
	        /**
	         * Timer reference for timeout that indicates when to send the next ping
	         */
	        this.keepaliveTimerId = null;
	        /**
	         * Indicates that the keepalive timer ran out while there were no active
	         * calls, and a ping should be sent the next time a call starts.
	         */
	        this.pendingSendKeepalivePing = false;
	        /**
	         * Timer reference tracking when the most recent ping will be considered lost
	         */
	        this.keepaliveTimeoutId = null;
	        /**
	         * Indicates whether keepalive pings should be sent without any active calls
	         */
	        this.keepaliveWithoutCalls = false;
	        this.activeCalls = new Set();
	        this.disconnectListeners = [];
	        this.disconnectHandled = false;
	        this.channelzEnabled = true;
	        this.keepalivesSent = 0;
	        this.messagesSent = 0;
	        this.messagesReceived = 0;
	        this.lastMessageSentTimestamp = null;
	        this.lastMessageReceivedTimestamp = null;
	        /* Populate subchannelAddressString and channelzRef before doing anything
	         * else, because they are used in the trace methods. */
	        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
	        if (options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
	        }
	        else {
	            this.streamTracker = new channelz_1.ChannelzCallTracker();
	        }
	        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
	        // Build user-agent string.
	        this.userAgent = [
	            options['grpc.primary_user_agent'],
	            `grpc-node-js/${clientVersion}`,
	            options['grpc.secondary_user_agent'],
	        ]
	            .filter(e => e)
	            .join(' '); // remove falsey values first
	        if ('grpc.keepalive_time_ms' in options) {
	            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];
	        }
	        if ('grpc.keepalive_timeout_ms' in options) {
	            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];
	        }
	        if ('grpc.keepalive_permit_without_calls' in options) {
	            this.keepaliveWithoutCalls =
	                options['grpc.keepalive_permit_without_calls'] === 1;
	        }
	        else {
	            this.keepaliveWithoutCalls = false;
	        }
	        session.once('close', () => {
	            this.trace('session closed');
	            this.stopKeepalivePings();
	            this.handleDisconnect();
	        });
	        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {
	            let tooManyPings = false;
	            /* See the last paragraph of
	             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
	            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
	                opaqueData &&
	                opaqueData.equals(tooManyPingsData)) {
	                tooManyPings = true;
	            }
	            this.trace('connection closed by GOAWAY with code ' +
	                errorCode +
	                ' and data ' +
	                (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));
	            this.reportDisconnectToOwner(tooManyPings);
	        });
	        session.once('error', error => {
	            /* Do nothing here. Any error should also trigger a close event, which is
	             * where we want to handle that.  */
	            this.trace('connection closed with error ' + error.message);
	        });
	        if (logging.isTracerEnabled(TRACER_NAME)) {
	            session.on('remoteSettings', (settings) => {
	                this.trace('new settings received' +
	                    (this.session !== session ? ' on the old connection' : '') +
	                    ': ' +
	                    JSON.stringify(settings));
	            });
	            session.on('localSettings', (settings) => {
	                this.trace('local settings acknowledged by remote' +
	                    (this.session !== session ? ' on the old connection' : '') +
	                    ': ' +
	                    JSON.stringify(settings));
	            });
	        }
	        /* Start the keepalive timer last, because this can trigger trace logs,
	         * which should only happen after everything else is set up. */
	        if (this.keepaliveWithoutCalls) {
	            this.maybeStartKeepalivePingTimer();
	        }
	    }
	    getChannelzInfo() {
	        var _a, _b, _c;
	        const sessionSocket = this.session.socket;
	        const remoteAddress = sessionSocket.remoteAddress
	            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
	            : null;
	        const localAddress = sessionSocket.localAddress
	            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
	            : null;
	        let tlsInfo;
	        if (this.session.encrypted) {
	            const tlsSocket = sessionSocket;
	            const cipherInfo = tlsSocket.getCipher();
	            const certificate = tlsSocket.getCertificate();
	            const peerCertificate = tlsSocket.getPeerCertificate();
	            tlsInfo = {
	                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
	                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
	                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
	                remoteCertificate: peerCertificate && 'raw' in peerCertificate
	                    ? peerCertificate.raw
	                    : null,
	            };
	        }
	        else {
	            tlsInfo = null;
	        }
	        const socketInfo = {
	            remoteAddress: remoteAddress,
	            localAddress: localAddress,
	            security: tlsInfo,
	            remoteName: this.remoteName,
	            streamsStarted: this.streamTracker.callsStarted,
	            streamsSucceeded: this.streamTracker.callsSucceeded,
	            streamsFailed: this.streamTracker.callsFailed,
	            messagesSent: this.messagesSent,
	            messagesReceived: this.messagesReceived,
	            keepAlivesSent: this.keepalivesSent,
	            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
	            lastRemoteStreamCreatedTimestamp: null,
	            lastMessageSentTimestamp: this.lastMessageSentTimestamp,
	            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
	            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
	            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,
	        };
	        return socketInfo;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    keepaliveTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    flowControlTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    internalsTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    /**
	     * Indicate to the owner of this object that this transport should no longer
	     * be used. That happens if the connection drops, or if the server sends a
	     * GOAWAY.
	     * @param tooManyPings If true, this was triggered by a GOAWAY with data
	     * indicating that the session was closed becaues the client sent too many
	     * pings.
	     * @returns
	     */
	    reportDisconnectToOwner(tooManyPings) {
	        if (this.disconnectHandled) {
	            return;
	        }
	        this.disconnectHandled = true;
	        this.disconnectListeners.forEach(listener => listener(tooManyPings));
	    }
	    /**
	     * Handle connection drops, but not GOAWAYs.
	     */
	    handleDisconnect() {
	        this.reportDisconnectToOwner(false);
	        /* Give calls an event loop cycle to finish naturally before reporting the
	         * disconnnection to them. */
	        setImmediate(() => {
	            for (const call of this.activeCalls) {
	                call.onDisconnect();
	            }
	        });
	    }
	    addDisconnectListener(listener) {
	        this.disconnectListeners.push(listener);
	    }
	    clearKeepaliveTimer() {
	        if (!this.keepaliveTimerId) {
	            return;
	        }
	        clearTimeout(this.keepaliveTimerId);
	        this.keepaliveTimerId = null;
	    }
	    clearKeepaliveTimeout() {
	        if (!this.keepaliveTimeoutId) {
	            return;
	        }
	        clearTimeout(this.keepaliveTimeoutId);
	        this.keepaliveTimeoutId = null;
	    }
	    canSendPing() {
	        return (this.keepaliveTimeMs > 0 &&
	            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));
	    }
	    maybeSendPing() {
	        var _a, _b;
	        this.clearKeepaliveTimer();
	        if (!this.canSendPing()) {
	            this.pendingSendKeepalivePing = true;
	            return;
	        }
	        if (this.channelzEnabled) {
	            this.keepalivesSent += 1;
	        }
	        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	        if (!this.keepaliveTimeoutId) {
	            this.keepaliveTimeoutId = setTimeout(() => {
	                this.keepaliveTrace('Ping timeout passed without response');
	                this.handleDisconnect();
	            }, this.keepaliveTimeoutMs);
	            (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	        }
	        try {
	            this.session.ping((err, duration, payload) => {
	                if (err) {
	                    this.keepaliveTrace('Ping failed with error ' + err.message);
	                    this.handleDisconnect();
	                }
	                this.keepaliveTrace('Received ping response');
	                this.clearKeepaliveTimeout();
	                this.maybeStartKeepalivePingTimer();
	            });
	        }
	        catch (e) {
	            /* If we fail to send a ping, the connection is no longer functional, so
	             * we should discard it. */
	            this.handleDisconnect();
	        }
	    }
	    /**
	     * Starts the keepalive ping timer if appropriate. If the timer already ran
	     * out while there were no active requests, instead send a ping immediately.
	     * If the ping timer is already running or a ping is currently in flight,
	     * instead do nothing and wait for them to resolve.
	     */
	    maybeStartKeepalivePingTimer() {
	        var _a, _b;
	        if (!this.canSendPing()) {
	            return;
	        }
	        if (this.pendingSendKeepalivePing) {
	            this.pendingSendKeepalivePing = false;
	            this.maybeSendPing();
	        }
	        else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {
	            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	            this.keepaliveTimerId = setTimeout(() => {
	                this.maybeSendPing();
	            }, this.keepaliveTimeMs);
	            (_b = (_a = this.keepaliveTimerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	        }
	        /* Otherwise, there is already either a keepalive timer or a ping pending,
	         * wait for those to resolve. */
	    }
	    stopKeepalivePings() {
	        if (this.keepaliveTimerId) {
	            clearTimeout(this.keepaliveTimerId);
	            this.keepaliveTimerId = null;
	        }
	        this.clearKeepaliveTimeout();
	    }
	    removeActiveCall(call) {
	        this.activeCalls.delete(call);
	        if (this.activeCalls.size === 0) {
	            this.session.unref();
	        }
	    }
	    addActiveCall(call) {
	        this.activeCalls.add(call);
	        if (this.activeCalls.size === 1) {
	            this.session.ref();
	            if (!this.keepaliveWithoutCalls) {
	                this.maybeStartKeepalivePingTimer();
	            }
	        }
	    }
	    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
	        const headers = metadata.toHttp2Headers();
	        headers[HTTP2_HEADER_AUTHORITY] = host;
	        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
	        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
	        headers[HTTP2_HEADER_METHOD] = 'POST';
	        headers[HTTP2_HEADER_PATH] = method;
	        headers[HTTP2_HEADER_TE] = 'trailers';
	        let http2Stream;
	        /* In theory, if an error is thrown by session.request because session has
	         * become unusable (e.g. because it has received a goaway), this subchannel
	         * should soon see the corresponding close or goaway event anyway and leave
	         * READY. But we have seen reports that this does not happen
	         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
	         * so for defense in depth, we just discard the session when we see an
	         * error here.
	         */
	        try {
	            http2Stream = this.session.request(headers);
	        }
	        catch (e) {
	            this.handleDisconnect();
	            throw e;
	        }
	        this.flowControlTrace('local window size: ' +
	            this.session.state.localWindowSize +
	            ' remote window size: ' +
	            this.session.state.remoteWindowSize);
	        this.internalsTrace('session.closed=' +
	            this.session.closed +
	            ' session.destroyed=' +
	            this.session.destroyed +
	            ' session.socket.destroyed=' +
	            this.session.socket.destroyed);
	        let eventTracker;
	        // eslint-disable-next-line prefer-const
	        let call;
	        if (this.channelzEnabled) {
	            this.streamTracker.addCallStarted();
	            eventTracker = {
	                addMessageSent: () => {
	                    var _a;
	                    this.messagesSent += 1;
	                    this.lastMessageSentTimestamp = new Date();
	                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
	                },
	                addMessageReceived: () => {
	                    var _a;
	                    this.messagesReceived += 1;
	                    this.lastMessageReceivedTimestamp = new Date();
	                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
	                },
	                onCallEnd: status => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);
	                    this.removeActiveCall(call);
	                },
	                onStreamEnd: success => {
	                    var _a;
	                    if (success) {
	                        this.streamTracker.addCallSucceeded();
	                    }
	                    else {
	                        this.streamTracker.addCallFailed();
	                    }
	                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);
	                },
	            };
	        }
	        else {
	            eventTracker = {
	                addMessageSent: () => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
	                },
	                addMessageReceived: () => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
	                },
	                onCallEnd: status => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);
	                    this.removeActiveCall(call);
	                },
	                onStreamEnd: success => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);
	                },
	            };
	        }
	        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
	        this.addActiveCall(call);
	        return call;
	    }
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    getPeerName() {
	        return this.subchannelAddressString;
	    }
	    shutdown() {
	        this.session.close();
	        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	    }
	}
	class Http2SubchannelConnector {
	    constructor(channelTarget) {
	        this.channelTarget = channelTarget;
	        this.session = null;
	        this.isShutdown = false;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);
	    }
	    createSession(address, credentials, options, proxyConnectionResult) {
	        if (this.isShutdown) {
	            return Promise.reject();
	        }
	        return new Promise((resolve, reject) => {
	            var _a, _b, _c, _d;
	            let remoteName;
	            if (proxyConnectionResult.realTarget) {
	                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
	                this.trace('creating HTTP/2 session through proxy to ' +
	                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
	            }
	            else {
	                remoteName = null;
	                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));
	            }
	            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
	            let connectionOptions = credentials._getConnectionOptions() || {};
	            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
	            if ('grpc-node.max_session_memory' in options) {
	                connectionOptions.maxSessionMemory =
	                    options['grpc-node.max_session_memory'];
	            }
	            else {
	                /* By default, set a very large max session memory limit, to effectively
	                 * disable enforcement of the limit. Some testing indicates that Node's
	                 * behavior degrades badly when this limit is reached, so we solve that
	                 * by disabling the check entirely. */
	                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
	            }
	            let addressScheme = 'http://';
	            if ('secureContext' in connectionOptions) {
	                addressScheme = 'https://';
	                // If provided, the value of grpc.ssl_target_name_override should be used
	                // to override the target hostname when checking server identity.
	                // This option is used for testing only.
	                if (options['grpc.ssl_target_name_override']) {
	                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
	                    const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== void 0 ? _b : tls_1.checkServerIdentity;
	                    connectionOptions.checkServerIdentity = (host, cert) => {
	                        return originalCheckServerIdentity(sslTargetNameOverride, cert);
	                    };
	                    connectionOptions.servername = sslTargetNameOverride;
	                }
	                else {
	                    const authorityHostname = (_d = (_c = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c === void 0 ? void 0 : _c.host) !== null && _d !== void 0 ? _d : 'localhost';
	                    // We want to always set servername to support SNI
	                    connectionOptions.servername = authorityHostname;
	                }
	                if (proxyConnectionResult.socket) {
	                    /* This is part of the workaround for
	                     * https://github.com/nodejs/node/issues/32922. Without that bug,
	                     * proxyConnectionResult.socket would always be a plaintext socket and
	                     * this would say
	                     * connectionOptions.socket = proxyConnectionResult.socket; */
	                    connectionOptions.createConnection = (authority, option) => {
	                        return proxyConnectionResult.socket;
	                    };
	                }
	            }
	            else {
	                /* In all but the most recent versions of Node, http2.connect does not use
	                 * the options when establishing plaintext connections, so we need to
	                 * establish that connection explicitly. */
	                connectionOptions.createConnection = (authority, option) => {
	                    if (proxyConnectionResult.socket) {
	                        return proxyConnectionResult.socket;
	                    }
	                    else {
	                        /* net.NetConnectOpts is declared in a way that is more restrictive
	                         * than what net.connect will actually accept, so we use the type
	                         * assertion to work around that. */
	                        return net.connect(address);
	                    }
	                };
	            }
	            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });
	            /* http2.connect uses the options here:
	             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
	             * The spread operator overides earlier values with later ones, so any port
	             * or host values in the options will be used rather than any values extracted
	             * from the first argument. In addition, the path overrides the host and port,
	             * as documented for plaintext connections here:
	             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
	             * and for TLS connections here:
	             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
	             * earlier versions of Node, http2.connect passes these options to
	             * tls.connect but not net.connect, so in the insecure case we still need
	             * to set the createConnection option above to create the connection
	             * explicitly. We cannot do that in the TLS case because http2.connect
	             * passes necessary additional options to tls.connect.
	             * The first argument just needs to be parseable as a URL and the scheme
	             * determines whether the connection will be established over TLS or not.
	             */
	            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
	            this.session = session;
	            let errorMessage = 'Failed to connect';
	            session.unref();
	            session.once('connect', () => {
	                session.removeAllListeners();
	                resolve(new Http2Transport(session, address, options, remoteName));
	                this.session = null;
	            });
	            session.once('close', () => {
	                this.session = null;
	                // Leave time for error event to happen before rejecting
	                setImmediate(() => {
	                    reject(`${errorMessage} (${new Date().toISOString()})`);
	                });
	            });
	            session.once('error', error => {
	                errorMessage = error.message;
	                this.trace('connection failed with error ' + errorMessage);
	            });
	        });
	    }
	    connect(address, credentials, options) {
	        var _a, _b, _c;
	        if (this.isShutdown) {
	            return Promise.reject();
	        }
	        /* Pass connection options through to the proxy so that it's able to
	         * upgrade it's connection to support tls if needed.
	         * This is a workaround for https://github.com/nodejs/node/issues/32922
	         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
	        const connectionOptions = credentials._getConnectionOptions() || {};
	        if ('secureContext' in connectionOptions) {
	            connectionOptions.ALPNProtocols = ['h2'];
	            // If provided, the value of grpc.ssl_target_name_override should be used
	            // to override the target hostname when checking server identity.
	            // This option is used for testing only.
	            if (options['grpc.ssl_target_name_override']) {
	                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
	                const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== void 0 ? _a : tls_1.checkServerIdentity;
	                connectionOptions.checkServerIdentity = (host, cert) => {
	                    return originalCheckServerIdentity(sslTargetNameOverride, cert);
	                };
	                connectionOptions.servername = sslTargetNameOverride;
	            }
	            else {
	                if ('grpc.http_connect_target' in options) {
	                    /* This is more or less how servername will be set in createSession
	                     * if a connection is successfully established through the proxy.
	                     * If the proxy is not used, these connectionOptions are discarded
	                     * anyway */
	                    const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== void 0 ? _b : {
	                        path: 'localhost',
	                    });
	                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
	                    connectionOptions.servername = (_c = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c !== void 0 ? _c : targetPath;
	                }
	            }
	            if (options['grpc-node.tls_enable_trace']) {
	                connectionOptions.enableTrace = true;
	            }
	        }
	        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));
	    }
	    shutdown() {
	        var _a;
	        this.isShutdown = true;
	        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();
	        this.session = null;
	    }
	}
	transport.Http2SubchannelConnector = Http2SubchannelConnector;
	
	return transport;
}

var hasRequiredSubchannelPool;

function requireSubchannelPool () {
	if (hasRequiredSubchannelPool) return subchannelPool;
	hasRequiredSubchannelPool = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelPool, "__esModule", { value: true });
	subchannelPool.getSubchannelPool = subchannelPool.SubchannelPool = void 0;
	const channel_options_1 = channelOptions;
	const subchannel_1 = requireSubchannel();
	const subchannel_address_1 = subchannelAddress;
	const uri_parser_1 = uriParser;
	const transport_1 = requireTransport();
	// 10 seconds in milliseconds. This value is arbitrary.
	/**
	 * The amount of time in between checks for dropping subchannels that have no
	 * other references
	 */
	const REF_CHECK_INTERVAL = 10000;
	class SubchannelPool {
	    /**
	     * A pool of subchannels use for making connections. Subchannels with the
	     * exact same parameters will be reused.
	     */
	    constructor() {
	        this.pool = Object.create(null);
	        /**
	         * A timer of a task performing a periodic subchannel cleanup.
	         */
	        this.cleanupTimer = null;
	    }
	    /**
	     * Unrefs all unused subchannels and cancels the cleanup task if all
	     * subchannels have been unrefed.
	     */
	    unrefUnusedSubchannels() {
	        let allSubchannelsUnrefed = true;
	        /* These objects are created with Object.create(null), so they do not
	         * have a prototype, which means that for (... in ...) loops over them
	         * do not need to be filtered */
	        // eslint-disable-disable-next-line:forin
	        for (const channelTarget in this.pool) {
	            const subchannelObjArray = this.pool[channelTarget];
	            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());
	            if (refedSubchannels.length > 0) {
	                allSubchannelsUnrefed = false;
	            }
	            /* For each subchannel in the pool, try to unref it if it has
	             * exactly one ref (which is the ref from the pool itself). If that
	             * does happen, remove the subchannel from the pool */
	            this.pool[channelTarget] = refedSubchannels;
	        }
	        /* Currently we do not delete keys with empty values. If that results
	         * in significant memory usage we should change it. */
	        // Cancel the cleanup task if all subchannels have been unrefed.
	        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
	            clearInterval(this.cleanupTimer);
	            this.cleanupTimer = null;
	        }
	    }
	    /**
	     * Ensures that the cleanup task is spawned.
	     */
	    ensureCleanupTask() {
	        var _a, _b;
	        if (this.cleanupTimer === null) {
	            this.cleanupTimer = setInterval(() => {
	                this.unrefUnusedSubchannels();
	            }, REF_CHECK_INTERVAL);
	            // Unref because this timer should not keep the event loop running.
	            // Call unref only if it exists to address electron/electron#21162
	            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	        }
	    }
	    /**
	     * Get a subchannel if one already exists with exactly matching parameters.
	     * Otherwise, create and save a subchannel with those parameters.
	     * @param channelTarget
	     * @param subchannelTarget
	     * @param channelArguments
	     * @param channelCredentials
	     */
	    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
	        this.ensureCleanupTask();
	        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
	        if (channelTarget in this.pool) {
	            const subchannelObjArray = this.pool[channelTarget];
	            for (const subchannelObj of subchannelObjArray) {
	                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&
	                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&
	                    channelCredentials._equals(subchannelObj.channelCredentials)) {
	                    return subchannelObj.subchannel;
	                }
	            }
	        }
	        // If we get here, no matching subchannel was found
	        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
	        if (!(channelTarget in this.pool)) {
	            this.pool[channelTarget] = [];
	        }
	        this.pool[channelTarget].push({
	            subchannelAddress: subchannelTarget,
	            channelArguments,
	            channelCredentials,
	            subchannel,
	        });
	        subchannel.ref();
	        return subchannel;
	    }
	}
	subchannelPool.SubchannelPool = SubchannelPool;
	const globalSubchannelPool = new SubchannelPool();
	/**
	 * Get either the global subchannel pool, or a new subchannel pool.
	 * @param global
	 */
	function getSubchannelPool(global) {
	    if (global) {
	        return globalSubchannelPool;
	    }
	    else {
	        return new SubchannelPool();
	    }
	}
	subchannelPool.getSubchannelPool = getSubchannelPool;
	
	return subchannelPool;
}

var filterStack = {};

var hasRequiredFilterStack;

function requireFilterStack () {
	if (hasRequiredFilterStack) return filterStack;
	hasRequiredFilterStack = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(filterStack, "__esModule", { value: true });
	filterStack.FilterStackFactory = filterStack.FilterStack = void 0;
	class FilterStack {
	    constructor(filters) {
	        this.filters = filters;
	    }
	    sendMetadata(metadata) {
	        let result = metadata;
	        for (let i = 0; i < this.filters.length; i++) {
	            result = this.filters[i].sendMetadata(result);
	        }
	        return result;
	    }
	    receiveMetadata(metadata) {
	        let result = metadata;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveMetadata(result);
	        }
	        return result;
	    }
	    sendMessage(message) {
	        let result = message;
	        for (let i = 0; i < this.filters.length; i++) {
	            result = this.filters[i].sendMessage(result);
	        }
	        return result;
	    }
	    receiveMessage(message) {
	        let result = message;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveMessage(result);
	        }
	        return result;
	    }
	    receiveTrailers(status) {
	        let result = status;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveTrailers(result);
	        }
	        return result;
	    }
	    push(filters) {
	        this.filters.unshift(...filters);
	    }
	    getFilters() {
	        return this.filters;
	    }
	}
	filterStack.FilterStack = FilterStack;
	class FilterStackFactory {
	    constructor(factories) {
	        this.factories = factories;
	    }
	    push(filterFactories) {
	        this.factories.unshift(...filterFactories);
	    }
	    clone() {
	        return new FilterStackFactory([...this.factories]);
	    }
	    createFilter() {
	        return new FilterStack(this.factories.map(factory => factory.createFilter()));
	    }
	}
	filterStack.FilterStackFactory = FilterStackFactory;
	
	return filterStack;
}

var compressionFilter = {};

var compressionAlgorithms = {};

/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(compressionAlgorithms, "__esModule", { value: true });
compressionAlgorithms.CompressionAlgorithms = void 0;
var CompressionAlgorithms;
(function (CompressionAlgorithms) {
    CompressionAlgorithms[CompressionAlgorithms["identity"] = 0] = "identity";
    CompressionAlgorithms[CompressionAlgorithms["deflate"] = 1] = "deflate";
    CompressionAlgorithms[CompressionAlgorithms["gzip"] = 2] = "gzip";
})(CompressionAlgorithms || (compressionAlgorithms.CompressionAlgorithms = CompressionAlgorithms = {}));

var filter = {};

var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(filter, "__esModule", { value: true });
	filter.BaseFilter = void 0;
	class BaseFilter {
	    async sendMetadata(metadata) {
	        return metadata;
	    }
	    receiveMetadata(metadata) {
	        return metadata;
	    }
	    async sendMessage(message) {
	        return message;
	    }
	    async receiveMessage(message) {
	        return message;
	    }
	    receiveTrailers(status) {
	        return status;
	    }
	}
	filter.BaseFilter = BaseFilter;
	
	return filter;
}

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(compressionFilter, "__esModule", { value: true });
compressionFilter.CompressionFilterFactory = compressionFilter.CompressionFilter = void 0;
const zlib = require$$0$6;
const compression_algorithms_1 = compressionAlgorithms;
const constants_1$7 = constants;
const filter_1$1 = requireFilter();
const logging$4 = logging$8;
const isCompressionAlgorithmKey = (key) => {
    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');
};
class CompressionHandler {
    /**
     * @param message Raw uncompressed message bytes
     * @param compress Indicates whether the message should be compressed
     * @return Framed message, compressed if applicable
     */
    async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
            messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
    }
    /**
     * @param data Framed message, possibly compressed
     * @return Uncompressed message
     */
    async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
            messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
    }
}
class IdentityHandler extends CompressionHandler {
    async compressMessage(message) {
        return message;
    }
    async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        /* With "identity" compression, messages should always be marked as
         * uncompressed */
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
    }
    decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
    }
}
class DeflateHandler extends CompressionHandler {
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.deflate(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.inflate(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
}
class GzipHandler extends CompressionHandler {
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.gzip(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.unzip(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
}
class UnknownHandler extends CompressionHandler {
    constructor(compressionName) {
        super();
        this.compressionName = compressionName;
    }
    compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
    }
    decompressMessage(message) {
        // This should be unreachable
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
    }
}
function getCompressionHandler(compressionName) {
    switch (compressionName) {
        case 'identity':
            return new IdentityHandler();
        case 'deflate':
            return new DeflateHandler();
        case 'gzip':
            return new GzipHandler();
        default:
            return new UnknownHandler(compressionName);
    }
}
class CompressionFilter extends filter_1$1.BaseFilter {
    constructor(channelOptions, sharedFilterConfig) {
        var _a;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = 'identity';
        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
        if (compressionAlgorithmKey !== undefined) {
            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');
                /**
                 * There are two possible situations here:
                 * 1) We don't have any info yet from the server about what compression it supports
                 *    In that case we should just use what the client tells us to use
                 * 2) We've previously received a response from the server including a grpc-accept-encoding header
                 *    In that case we only want to use the encoding chosen by the client if the server supports it
                 */
                if (!serverSupportedEncodings ||
                    serverSupportedEncodings.includes(clientSelectedEncoding)) {
                    this.currentCompressionAlgorithm = clientSelectedEncoding;
                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);
                }
            }
            else {
                logging$4.log(constants_1$7.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
            }
        }
    }
    async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
        headers.set('accept-encoding', 'identity');
        // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
        if (this.currentCompressionAlgorithm === 'identity') {
            headers.remove('grpc-encoding');
        }
        else {
            headers.set('grpc-encoding', this.currentCompressionAlgorithm);
        }
        return headers;
    }
    receiveMetadata(metadata) {
        const receiveEncoding = metadata.get('grpc-encoding');
        if (receiveEncoding.length > 0) {
            const encoding = receiveEncoding[0];
            if (typeof encoding === 'string') {
                this.receiveCompression = getCompressionHandler(encoding);
            }
        }
        metadata.remove('grpc-encoding');
        /* Check to see if the compression we're using to send messages is supported by the server
         * If not, reset the sendCompression filter and have it use the default IdentityHandler */
        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];
        if (serverSupportedEncodingsHeader) {
            this.sharedFilterConfig.serverSupportedEncodingHeader =
                serverSupportedEncodingsHeader;
            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');
            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
                this.sendCompression = new IdentityHandler();
                this.currentCompressionAlgorithm = 'identity';
            }
        }
        metadata.remove('grpc-accept-encoding');
        return metadata;
    }
    async sendMessage(message) {
        var _a;
        /* This filter is special. The input message is the bare message bytes,
         * and the output is a framed and possibly compressed message. For this
         * reason, this filter should be at the bottom of the filter stack */
        const resolvedMessage = await message;
        let compress;
        if (this.sendCompression instanceof IdentityHandler) {
            compress = false;
        }
        else {
            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;
        }
        return {
            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
            flags: resolvedMessage.flags,
        };
    }
    async receiveMessage(message) {
        /* This filter is also special. The input message is framed and possibly
         * compressed, and the output message is deframed and uncompressed. So
         * this is another reason that this filter should be at the bottom of the
         * filter stack. */
        return this.receiveCompression.readMessage(await message);
    }
}
compressionFilter.CompressionFilter = CompressionFilter;
class CompressionFilterFactory {
    constructor(channel, options) {
        this.options = options;
        this.sharedFilterConfig = {};
    }
    createFilter() {
        return new CompressionFilter(this.options, this.sharedFilterConfig);
    }
}
compressionFilter.CompressionFilterFactory = CompressionFilterFactory;

var maxMessageSizeFilter = {};

/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(maxMessageSizeFilter, "__esModule", { value: true });
maxMessageSizeFilter.MaxMessageSizeFilterFactory = maxMessageSizeFilter.MaxMessageSizeFilter = void 0;
const filter_1 = requireFilter();
const constants_1$6 = constants;
const metadata_1$4 = metadata;
class MaxMessageSizeFilter extends filter_1.BaseFilter {
    constructor(options) {
        super();
        this.maxSendMessageSize = constants_1$6.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1$6.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ('grpc.max_send_message_length' in options) {
            this.maxSendMessageSize = options['grpc.max_send_message_length'];
        }
        if ('grpc.max_receive_message_length' in options) {
            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
        }
    }
    async sendMessage(message) {
        /* A configured size of -1 means that there is no limit, so skip the check
         * entirely */
        if (this.maxSendMessageSize === -1) {
            return message;
        }
        else {
            const concreteMessage = await message;
            if (concreteMessage.message.length > this.maxSendMessageSize) {
                throw {
                    code: constants_1$6.Status.RESOURCE_EXHAUSTED,
                    details: `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`,
                    metadata: new metadata_1$4.Metadata(),
                };
            }
            else {
                return concreteMessage;
            }
        }
    }
    async receiveMessage(message) {
        /* A configured size of -1 means that there is no limit, so skip the check
         * entirely */
        if (this.maxReceiveMessageSize === -1) {
            return message;
        }
        else {
            const concreteMessage = await message;
            if (concreteMessage.length > this.maxReceiveMessageSize) {
                throw {
                    code: constants_1$6.Status.RESOURCE_EXHAUSTED,
                    details: `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`,
                    metadata: new metadata_1$4.Metadata(),
                };
            }
            else {
                return concreteMessage;
            }
        }
    }
}
maxMessageSizeFilter.MaxMessageSizeFilter = MaxMessageSizeFilter;
class MaxMessageSizeFilterFactory {
    constructor(options) {
        this.options = options;
    }
    createFilter() {
        return new MaxMessageSizeFilter(this.options);
    }
}
maxMessageSizeFilter.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;

var loadBalancingCall = {};

var deadline = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(deadline, "__esModule", { value: true });
deadline.formatDateDifference = deadline.deadlineToString = deadline.getRelativeTimeout = deadline.getDeadlineTimeoutString = deadline.minDeadline = void 0;
function minDeadline(...deadlineList) {
    let minValue = Infinity;
    for (const deadline of deadlineList) {
        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
        if (deadlineMsecs < minValue) {
            minValue = deadlineMsecs;
        }
    }
    return minValue;
}
deadline.minDeadline = minDeadline;
const units = [
    ['m', 1],
    ['S', 1000],
    ['M', 60 * 1000],
    ['H', 60 * 60 * 1000],
];
function getDeadlineTimeoutString(deadline) {
    const now = new Date().getTime();
    if (deadline instanceof Date) {
        deadline = deadline.getTime();
    }
    const timeoutMs = Math.max(deadline - now, 0);
    for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
            return String(Math.ceil(amount)) + unit;
        }
    }
    throw new Error('Deadline is too far in the future');
}
deadline.getDeadlineTimeoutString = getDeadlineTimeoutString;
/**
 * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args
 * In particular, "When delay is larger than 2147483647 or less than 1, the
 * delay will be set to 1. Non-integer delays are truncated to an integer."
 * This number of milliseconds is almost 25 days.
 */
const MAX_TIMEOUT_TIME = 2147483647;
/**
 * Get the timeout value that should be passed to setTimeout now for the timer
 * to end at the deadline. For any deadline before now, the timer should end
 * immediately, represented by a value of 0. For any deadline more than
 * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will
 * end at that time, so it is treated as infinitely far in the future.
 * @param deadline
 * @returns
 */
function getRelativeTimeout(deadline) {
    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
    const now = new Date().getTime();
    const timeout = deadlineMs - now;
    if (timeout < 0) {
        return 0;
    }
    else if (timeout > MAX_TIMEOUT_TIME) {
        return Infinity;
    }
    else {
        return timeout;
    }
}
deadline.getRelativeTimeout = getRelativeTimeout;
function deadlineToString(deadline) {
    if (deadline instanceof Date) {
        return deadline.toISOString();
    }
    else {
        const dateDeadline = new Date(deadline);
        if (Number.isNaN(dateDeadline.getTime())) {
            return '' + deadline;
        }
        else {
            return dateDeadline.toISOString();
        }
    }
}
deadline.deadlineToString = deadlineToString;
/**
 * Calculate the difference between two dates as a number of seconds and format
 * it as a string.
 * @param startDate
 * @param endDate
 * @returns
 */
function formatDateDifference(startDate, endDate) {
    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';
}
deadline.formatDateDifference = formatDateDifference;

var controlPlaneStatus = {};

/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(controlPlaneStatus, "__esModule", { value: true });
controlPlaneStatus.restrictControlPlaneStatusCode = void 0;
const constants_1$5 = constants;
const INAPPROPRIATE_CONTROL_PLANE_CODES = [
    constants_1$5.Status.OK,
    constants_1$5.Status.INVALID_ARGUMENT,
    constants_1$5.Status.NOT_FOUND,
    constants_1$5.Status.ALREADY_EXISTS,
    constants_1$5.Status.FAILED_PRECONDITION,
    constants_1$5.Status.ABORTED,
    constants_1$5.Status.OUT_OF_RANGE,
    constants_1$5.Status.DATA_LOSS,
];
function restrictControlPlaneStatusCode(code, details) {
    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
        return {
            code: constants_1$5.Status.INTERNAL,
            details: `Invalid status from control plane: ${code} ${constants_1$5.Status[code]} ${details}`,
        };
    }
    else {
        return { code, details };
    }
}
controlPlaneStatus.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;

/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(loadBalancingCall, "__esModule", { value: true });
loadBalancingCall.LoadBalancingCall = void 0;
const connectivity_state_1 = connectivityState;
const constants_1$4 = constants;
const deadline_1$2 = deadline;
const metadata_1$3 = metadata;
const picker_1 = requirePicker();
const uri_parser_1$1 = uriParser;
const logging$3 = logging$8;
const control_plane_status_1$1 = controlPlaneStatus;
const http2$1 = require$$0$5;
const TRACER_NAME$3 = 'load_balancing_call';
class LoadBalancingCall {
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
        var _a, _b;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.metadata = null;
        this.listener = null;
        this.onCallEnded = null;
        this.childStartTime = null;
        const splitPath = this.methodName.split('/');
        let serviceName = '';
        /* The standard path format is "/{serviceName}/{methodName}", so if we split
         * by '/', the first item should be empty and the second should be the
         * service name */
        if (splitPath.length >= 2) {
            serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = (0, uri_parser_1$1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';
        /* Currently, call credentials are only allowed on HTTPS connections, so we
         * can assume that the scheme is "https" */
        this.serviceUrl = `https://${hostname}/${serviceName}`;
        this.startTime = new Date();
    }
    getDeadlineInfo() {
        var _a, _b;
        const deadlineInfo = [];
        if (this.childStartTime) {
            if (this.childStartTime > this.startTime) {
                if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {
                    deadlineInfo.push('wait_for_ready');
                }
                deadlineInfo.push(`LB pick: ${(0, deadline_1$2.formatDateDifference)(this.startTime, this.childStartTime)}`);
            }
            deadlineInfo.push(...this.child.getDeadlineInfo());
            return deadlineInfo;
        }
        else {
            if ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.getOptions().waitForReady) {
                deadlineInfo.push('wait_for_ready');
            }
            deadlineInfo.push('Waiting for LB pick');
        }
        return deadlineInfo;
    }
    trace(text) {
        logging$3.trace(constants_1$4.LogVerbosity.DEBUG, TRACER_NAME$3, '[' + this.callNumber + '] ' + text);
    }
    outputStatus(status, progress) {
        var _a, _b;
        if (!this.ended) {
            this.ended = true;
            this.trace('ended with status: code=' +
                status.code +
                ' details="' +
                status.details +
                '" start time=' +
                this.startTime.toISOString());
            const finalStatus = Object.assign(Object.assign({}, status), { progress });
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);
            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);
        }
    }
    doPick() {
        var _a, _b;
        if (this.ended) {
            return;
        }
        if (!this.metadata) {
            throw new Error('doPick called before start');
        }
        this.trace('Pick called');
        const finalMetadata = this.metadata.clone();
        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
        const subchannelString = pickResult.subchannel
            ? '(' +
                pickResult.subchannel.getChannelzRef().id +
                ') ' +
                pickResult.subchannel.getAddress()
            : '' + pickResult.subchannel;
        this.trace('Pick result: ' +
            picker_1.PickResultType[pickResult.pickResultType] +
            ' subchannel: ' +
            subchannelString +
            ' status: ' +
            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +
            ' ' +
            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));
        switch (pickResult.pickResultType) {
            case picker_1.PickResultType.COMPLETE:
                this.credentials
                    .generateMetadata({ service_url: this.serviceUrl })
                    .then(credsMetadata => {
                    var _a, _b, _c;
                    /* If this call was cancelled (e.g. by the deadline) before
                     * metadata generation finished, we shouldn't do anything with
                     * it. */
                    if (this.ended) {
                        this.trace('Credentials metadata generation finished after call ended');
                        return;
                    }
                    finalMetadata.merge(credsMetadata);
                    if (finalMetadata.get('authorization').length > 1) {
                        this.outputStatus({
                            code: constants_1$4.Status.INTERNAL,
                            details: '"authorization" metadata cannot have multiple values',
                            metadata: new metadata_1$3.Metadata(),
                        }, 'PROCESSED');
                    }
                    if (pickResult.subchannel.getConnectivityState() !==
                        connectivity_state_1.ConnectivityState.READY) {
                        this.trace('Picked subchannel ' +
                            subchannelString +
                            ' has state ' +
                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +
                            ' after getting credentials metadata. Retrying pick');
                        this.doPick();
                        return;
                    }
                    if (this.deadline !== Infinity) {
                        finalMetadata.set('grpc-timeout', (0, deadline_1$2.getDeadlineTimeoutString)(this.deadline));
                    }
                    try {
                        this.child = pickResult
                            .subchannel.getRealSubchannel()
                            .createCall(finalMetadata, this.host, this.methodName, {
                            onReceiveMetadata: metadata => {
                                this.trace('Received metadata');
                                this.listener.onReceiveMetadata(metadata);
                            },
                            onReceiveMessage: message => {
                                this.trace('Received message');
                                this.listener.onReceiveMessage(message);
                            },
                            onReceiveStatus: status => {
                                this.trace('Received status');
                                if (status.rstCode ===
                                    http2$1.constants.NGHTTP2_REFUSED_STREAM) {
                                    this.outputStatus(status, 'REFUSED');
                                }
                                else {
                                    this.outputStatus(status, 'PROCESSED');
                                }
                            },
                        });
                        this.childStartTime = new Date();
                    }
                    catch (error) {
                        this.trace('Failed to start call on picked subchannel ' +
                            subchannelString +
                            ' with error ' +
                            error.message);
                        this.outputStatus({
                            code: constants_1$4.Status.INTERNAL,
                            details: 'Failed to start HTTP/2 stream with error ' +
                                error.message,
                            metadata: new metadata_1$3.Metadata(),
                        }, 'NOT_STARTED');
                        return;
                    }
                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);
                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);
                    this.onCallEnded = pickResult.onCallEnded;
                    this.trace('Created child call [' + this.child.getCallNumber() + ']');
                    if (this.readPending) {
                        this.child.startRead();
                    }
                    if (this.pendingMessage) {
                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
                    }
                    if (this.pendingHalfClose) {
                        this.child.halfClose();
                    }
                }, (error) => {
                    // We assume the error code isn't 0 (Status.OK)
                    const { code, details } = (0, control_plane_status_1$1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1$4.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
                    this.outputStatus({
                        code: code,
                        details: details,
                        metadata: new metadata_1$3.Metadata(),
                    }, 'PROCESSED');
                });
                break;
            case picker_1.PickResultType.DROP:
                const { code, details } = (0, control_plane_status_1$1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
                setImmediate(() => {
                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');
                });
                break;
            case picker_1.PickResultType.TRANSIENT_FAILURE:
                if (this.metadata.getOptions().waitForReady) {
                    this.channel.queueCallForPick(this);
                }
                else {
                    const { code, details } = (0, control_plane_status_1$1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
                    setImmediate(() => {
                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');
                    });
                }
                break;
            case picker_1.PickResultType.QUEUE:
                this.channel.queueCallForPick(this);
        }
    }
    cancelWithStatus(status, details) {
        var _a;
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus({ code: status, details: details, metadata: new metadata_1$3.Metadata() }, 'PROCESSED');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
    }
    start(metadata, listener) {
        this.trace('start called');
        this.listener = listener;
        this.metadata = metadata;
        this.doPick();
    }
    sendMessageWithContext(context, message) {
        this.trace('write() called with message of length ' + message.length);
        if (this.child) {
            this.child.sendMessageWithContext(context, message);
        }
        else {
            this.pendingMessage = { context, message };
        }
    }
    startRead() {
        this.trace('startRead called');
        if (this.child) {
            this.child.startRead();
        }
        else {
            this.readPending = true;
        }
    }
    halfClose() {
        this.trace('halfClose called');
        if (this.child) {
            this.child.halfClose();
        }
        else {
            this.pendingHalfClose = true;
        }
    }
    setCredentials(credentials) {
        throw new Error('Method not implemented.');
    }
    getCallNumber() {
        return this.callNumber;
    }
}
loadBalancingCall.LoadBalancingCall = LoadBalancingCall;

var resolvingCall = {};

/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(resolvingCall, "__esModule", { value: true });
resolvingCall.ResolvingCall = void 0;
const constants_1$3 = constants;
const deadline_1$1 = deadline;
const metadata_1$2 = metadata;
const logging$2 = logging$8;
const control_plane_status_1 = controlPlaneStatus;
const TRACER_NAME$2 = 'resolving_call';
class ResolvingCall {
    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {
        this.channel = channel;
        this.method = method;
        this.filterStackFactory = filterStackFactory;
        this.credentials = credentials;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.readFilterPending = false;
        this.writeFilterPending = false;
        this.pendingChildStatus = null;
        this.metadata = null;
        this.listener = null;
        this.statusWatchers = [];
        this.deadlineTimer = setTimeout(() => { }, 0);
        this.filterStack = null;
        this.deadlineStartTime = null;
        this.configReceivedTime = null;
        this.childStartTime = null;
        this.deadline = options.deadline;
        this.host = options.host;
        if (options.parentCall) {
            if (options.flags & constants_1$3.Propagate.CANCELLATION) {
                options.parentCall.on('cancelled', () => {
                    this.cancelWithStatus(constants_1$3.Status.CANCELLED, 'Cancelled by parent call');
                });
            }
            if (options.flags & constants_1$3.Propagate.DEADLINE) {
                this.trace('Propagating deadline from parent: ' +
                    options.parentCall.getDeadline());
                this.deadline = (0, deadline_1$1.minDeadline)(this.deadline, options.parentCall.getDeadline());
            }
        }
        this.trace('Created');
        this.runDeadlineTimer();
    }
    trace(text) {
        logging$2.trace(constants_1$3.LogVerbosity.DEBUG, TRACER_NAME$2, '[' + this.callNumber + '] ' + text);
    }
    runDeadlineTimer() {
        clearTimeout(this.deadlineTimer);
        this.deadlineStartTime = new Date();
        this.trace('Deadline: ' + (0, deadline_1$1.deadlineToString)(this.deadline));
        const timeout = (0, deadline_1$1.getRelativeTimeout)(this.deadline);
        if (timeout !== Infinity) {
            this.trace('Deadline will be reached in ' + timeout + 'ms');
            const handleDeadline = () => {
                if (!this.deadlineStartTime) {
                    this.cancelWithStatus(constants_1$3.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
                    return;
                }
                const deadlineInfo = [];
                const deadlineEndTime = new Date();
                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1$1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
                if (this.configReceivedTime) {
                    if (this.configReceivedTime > this.deadlineStartTime) {
                        deadlineInfo.push(`name resolution: ${(0, deadline_1$1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
                    }
                    if (this.childStartTime) {
                        if (this.childStartTime > this.configReceivedTime) {
                            deadlineInfo.push(`metadata filters: ${(0, deadline_1$1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
                        }
                    }
                    else {
                        deadlineInfo.push('waiting for metadata filters');
                    }
                }
                else {
                    deadlineInfo.push('waiting for name resolution');
                }
                if (this.child) {
                    deadlineInfo.push(...this.child.getDeadlineInfo());
                }
                this.cancelWithStatus(constants_1$3.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));
            };
            if (timeout <= 0) {
                process.nextTick(handleDeadline);
            }
            else {
                this.deadlineTimer = setTimeout(handleDeadline, timeout);
            }
        }
    }
    outputStatus(status) {
        if (!this.ended) {
            this.ended = true;
            if (!this.filterStack) {
                this.filterStack = this.filterStackFactory.createFilter();
            }
            clearTimeout(this.deadlineTimer);
            const filteredStatus = this.filterStack.receiveTrailers(status);
            this.trace('ended with status: code=' +
                filteredStatus.code +
                ' details="' +
                filteredStatus.details +
                '"');
            this.statusWatchers.forEach(watcher => watcher(filteredStatus));
            process.nextTick(() => {
                var _a;
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
            });
        }
    }
    sendMessageOnChild(context, message) {
        if (!this.child) {
            throw new Error('sendMessageonChild called with child not populated');
        }
        const child = this.child;
        this.writeFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {
            this.writeFilterPending = false;
            child.sendMessageWithContext(context, filteredMessage.message);
            if (this.pendingHalfClose) {
                child.halfClose();
            }
        }, (status) => {
            this.cancelWithStatus(status.code, status.details);
        });
    }
    getConfig() {
        if (this.ended) {
            return;
        }
        if (!this.metadata || !this.listener) {
            throw new Error('getConfig called before start');
        }
        const configResult = this.channel.getConfig(this.method, this.metadata);
        if (configResult.type === 'NONE') {
            this.channel.queueCallForConfig(this);
            return;
        }
        else if (configResult.type === 'ERROR') {
            if (this.metadata.getOptions().waitForReady) {
                this.channel.queueCallForConfig(this);
            }
            else {
                this.outputStatus(configResult.error);
            }
            return;
        }
        // configResult.type === 'SUCCESS'
        this.configReceivedTime = new Date();
        const config = configResult.config;
        if (config.status !== constants_1$3.Status.OK) {
            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);
            this.outputStatus({
                code: code,
                details: details,
                metadata: new metadata_1$2.Metadata(),
            });
            return;
        }
        if (config.methodConfig.timeout) {
            const configDeadline = new Date();
            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +
                config.methodConfig.timeout.nanos / 1000000);
            this.deadline = (0, deadline_1$1.minDeadline)(this.deadline, configDeadline);
            this.runDeadlineTimer();
        }
        this.filterStackFactory.push(config.dynamicFilterFactories);
        this.filterStack = this.filterStackFactory.createFilter();
        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {
            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
            this.trace('Created child [' + this.child.getCallNumber() + ']');
            this.childStartTime = new Date();
            this.child.start(filteredMetadata, {
                onReceiveMetadata: metadata => {
                    this.trace('Received metadata');
                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
                },
                onReceiveMessage: message => {
                    this.trace('Received message');
                    this.readFilterPending = true;
                    this.filterStack.receiveMessage(message).then(filteredMesssage => {
                        this.trace('Finished filtering received message');
                        this.readFilterPending = false;
                        this.listener.onReceiveMessage(filteredMesssage);
                        if (this.pendingChildStatus) {
                            this.outputStatus(this.pendingChildStatus);
                        }
                    }, (status) => {
                        this.cancelWithStatus(status.code, status.details);
                    });
                },
                onReceiveStatus: status => {
                    this.trace('Received status');
                    if (this.readFilterPending) {
                        this.pendingChildStatus = status;
                    }
                    else {
                        this.outputStatus(status);
                    }
                },
            });
            if (this.readPending) {
                this.child.startRead();
            }
            if (this.pendingMessage) {
                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
            }
            else if (this.pendingHalfClose) {
                this.child.halfClose();
            }
        }, (status) => {
            this.outputStatus(status);
        });
    }
    reportResolverError(status) {
        var _a;
        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {
            this.channel.queueCallForConfig(this);
        }
        else {
            this.outputStatus(status);
        }
    }
    cancelWithStatus(status, details) {
        var _a;
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus({
            code: status,
            details: details,
            metadata: new metadata_1$2.Metadata(),
        });
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
    }
    start(metadata, listener) {
        this.trace('start called');
        this.metadata = metadata.clone();
        this.listener = listener;
        this.getConfig();
    }
    sendMessageWithContext(context, message) {
        this.trace('write() called with message of length ' + message.length);
        if (this.child) {
            this.sendMessageOnChild(context, message);
        }
        else {
            this.pendingMessage = { context, message };
        }
    }
    startRead() {
        this.trace('startRead called');
        if (this.child) {
            this.child.startRead();
        }
        else {
            this.readPending = true;
        }
    }
    halfClose() {
        this.trace('halfClose called');
        if (this.child && !this.writeFilterPending) {
            this.child.halfClose();
        }
        else {
            this.pendingHalfClose = true;
        }
    }
    setCredentials(credentials) {
        this.credentials = this.credentials.compose(credentials);
    }
    addStatusWatcher(watcher) {
        this.statusWatchers.push(watcher);
    }
    getCallNumber() {
        return this.callNumber;
    }
}
resolvingCall.ResolvingCall = ResolvingCall;

var retryingCall = {};

/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(retryingCall, "__esModule", { value: true });
retryingCall.RetryingCall = retryingCall.MessageBufferTracker = retryingCall.RetryThrottler = void 0;
const constants_1$2 = constants;
const deadline_1 = deadline;
const metadata_1$1 = metadata;
const logging$1 = logging$8;
const TRACER_NAME$1 = 'retrying_call';
class RetryThrottler {
    constructor(maxTokens, tokenRatio, previousRetryThrottler) {
        this.maxTokens = maxTokens;
        this.tokenRatio = tokenRatio;
        if (previousRetryThrottler) {
            /* When carrying over tokens from a previous config, rescale them to the
             * new max value */
            this.tokens =
                previousRetryThrottler.tokens *
                    (maxTokens / previousRetryThrottler.maxTokens);
        }
        else {
            this.tokens = maxTokens;
        }
    }
    addCallSucceeded() {
        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
    }
    addCallFailed() {
        this.tokens = Math.min(this.tokens - 1, 0);
    }
    canRetryCall() {
        return this.tokens > this.maxTokens / 2;
    }
}
retryingCall.RetryThrottler = RetryThrottler;
class MessageBufferTracker {
    constructor(totalLimit, limitPerCall) {
        this.totalLimit = totalLimit;
        this.limitPerCall = limitPerCall;
        this.totalAllocated = 0;
        this.allocatedPerCall = new Map();
    }
    allocate(size, callId) {
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.limitPerCall - currentPerCall < size ||
            this.totalLimit - this.totalAllocated < size) {
            return false;
        }
        this.allocatedPerCall.set(callId, currentPerCall + size);
        this.totalAllocated += size;
        return true;
    }
    free(size, callId) {
        var _a;
        if (this.totalAllocated < size) {
            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= size;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (currentPerCall < size) {
            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
        }
        this.allocatedPerCall.set(callId, currentPerCall - size);
    }
    freeAll(callId) {
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.totalAllocated < currentPerCall) {
            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= currentPerCall;
        this.allocatedPerCall.delete(callId);
    }
}
retryingCall.MessageBufferTracker = MessageBufferTracker;
const PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';
class RetryingCall {
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.bufferTracker = bufferTracker;
        this.retryThrottler = retryThrottler;
        this.listener = null;
        this.initialMetadata = null;
        this.underlyingCalls = [];
        this.writeBuffer = [];
        /**
         * The offset of message indices in the writeBuffer. For example, if
         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15
         * is in writeBuffer[5].
         */
        this.writeBufferOffset = 0;
        /**
         * Tracks whether a read has been started, so that we know whether to start
         * reads on new child calls. This only matters for the first read, because
         * once a message comes in the child call becomes committed and there will
         * be no new child calls.
         */
        this.readStarted = false;
        this.transparentRetryUsed = false;
        /**
         * Number of attempts so far
         */
        this.attempts = 0;
        this.hedgingTimer = null;
        this.committedCallIndex = null;
        this.initialRetryBackoffSec = 0;
        this.nextRetryBackoffSec = 0;
        if (callConfig.methodConfig.retryPolicy) {
            this.state = 'RETRY';
            const retryPolicy = callConfig.methodConfig.retryPolicy;
            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
        }
        else if (callConfig.methodConfig.hedgingPolicy) {
            this.state = 'HEDGING';
        }
        else {
            this.state = 'TRANSPARENT_ONLY';
        }
        this.startTime = new Date();
    }
    getDeadlineInfo() {
        if (this.underlyingCalls.length === 0) {
            return [];
        }
        const deadlineInfo = [];
        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
        if (this.underlyingCalls.length > 1) {
            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
        }
        if (latestCall.startTime > this.startTime) {
            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
        }
        deadlineInfo.push(...latestCall.call.getDeadlineInfo());
        return deadlineInfo;
    }
    getCallNumber() {
        return this.callNumber;
    }
    trace(text) {
        logging$1.trace(constants_1$2.LogVerbosity.DEBUG, TRACER_NAME$1, '[' + this.callNumber + '] ' + text);
    }
    reportStatus(statusObject) {
        this.trace('ended with status: code=' +
            statusObject.code +
            ' details="' +
            statusObject.details +
            '" start time=' +
            this.startTime.toISOString());
        this.bufferTracker.freeAll(this.callNumber);
        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
        this.writeBuffer = [];
        process.nextTick(() => {
            var _a;
            // Explicitly construct status object to remove progress field
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({
                code: statusObject.code,
                details: statusObject.details,
                metadata: statusObject.metadata,
            });
        });
    }
    cancelWithStatus(status, details) {
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        this.reportStatus({ code: status, details, metadata: new metadata_1$1.Metadata() });
        for (const { call } of this.underlyingCalls) {
            call.cancelWithStatus(status, details);
        }
    }
    getPeer() {
        if (this.committedCallIndex !== null) {
            return this.underlyingCalls[this.committedCallIndex].call.getPeer();
        }
        else {
            return 'unknown';
        }
    }
    getBufferEntry(messageIndex) {
        var _a;
        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {
            entryType: 'FREED',
            allocated: false,
        });
    }
    getNextBufferIndex() {
        return this.writeBufferOffset + this.writeBuffer.length;
    }
    clearSentMessages() {
        if (this.state !== 'COMMITTED') {
            return;
        }
        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {
            const bufferEntry = this.getBufferEntry(messageIndex);
            if (bufferEntry.allocated) {
                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
            }
        }
        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
        this.writeBufferOffset = earliestNeededMessageIndex;
    }
    commitCall(index) {
        if (this.state === 'COMMITTED') {
            return;
        }
        if (this.underlyingCalls[index].state === 'COMPLETED') {
            return;
        }
        this.trace('Committing call [' +
            this.underlyingCalls[index].call.getCallNumber() +
            '] at index ' +
            index);
        this.state = 'COMMITTED';
        this.committedCallIndex = index;
        for (let i = 0; i < this.underlyingCalls.length; i++) {
            if (i === index) {
                continue;
            }
            if (this.underlyingCalls[i].state === 'COMPLETED') {
                continue;
            }
            this.underlyingCalls[i].state = 'COMPLETED';
            this.underlyingCalls[i].call.cancelWithStatus(constants_1$2.Status.CANCELLED, 'Discarded in favor of other hedged attempt');
        }
        this.clearSentMessages();
    }
    commitCallWithMostMessages() {
        if (this.state === 'COMMITTED') {
            return;
        }
        let mostMessages = -1;
        let callWithMostMessages = -1;
        for (const [index, childCall] of this.underlyingCalls.entries()) {
            if (childCall.state === 'ACTIVE' &&
                childCall.nextMessageToSend > mostMessages) {
                mostMessages = childCall.nextMessageToSend;
                callWithMostMessages = index;
            }
        }
        if (callWithMostMessages === -1) {
            /* There are no active calls, disable retries to force the next call that
             * is started to be committed. */
            this.state = 'TRANSPARENT_ONLY';
        }
        else {
            this.commitCall(callWithMostMessages);
        }
    }
    isStatusCodeInList(list, code) {
        return list.some(value => value === code ||
            value.toString().toLowerCase() === constants_1$2.Status[code].toLowerCase());
    }
    getNextRetryBackoffMs() {
        var _a;
        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;
        if (!retryPolicy) {
            return 0;
        }
        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
        return nextBackoffMs;
    }
    maybeRetryCall(pushback, callback) {
        if (this.state !== 'RETRY') {
            callback(false);
            return;
        }
        const retryPolicy = this.callConfig.methodConfig.retryPolicy;
        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {
            callback(false);
            return;
        }
        let retryDelayMs;
        if (pushback === null) {
            retryDelayMs = this.getNextRetryBackoffMs();
        }
        else if (pushback < 0) {
            this.state = 'TRANSPARENT_ONLY';
            callback(false);
            return;
        }
        else {
            retryDelayMs = pushback;
            this.nextRetryBackoffSec = this.initialRetryBackoffSec;
        }
        setTimeout(() => {
            var _a, _b;
            if (this.state !== 'RETRY') {
                callback(false);
                return;
            }
            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {
                callback(true);
                this.attempts += 1;
                this.startNewAttempt();
            }
        }, retryDelayMs);
    }
    countActiveCalls() {
        let count = 0;
        for (const call of this.underlyingCalls) {
            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {
                count += 1;
            }
        }
        return count;
    }
    handleProcessedStatus(status, callIndex, pushback) {
        var _a, _b, _c;
        switch (this.state) {
            case 'COMMITTED':
            case 'TRANSPARENT_ONLY':
                this.commitCall(callIndex);
                this.reportStatus(status);
                break;
            case 'HEDGING':
                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {
                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();
                    let delayMs;
                    if (pushback === null) {
                        delayMs = 0;
                    }
                    else if (pushback < 0) {
                        this.state = 'TRANSPARENT_ONLY';
                        this.commitCall(callIndex);
                        this.reportStatus(status);
                        return;
                    }
                    else {
                        delayMs = pushback;
                    }
                    setTimeout(() => {
                        this.maybeStartHedgingAttempt();
                        // If after trying to start a call there are no active calls, this was the last one
                        if (this.countActiveCalls() === 0) {
                            this.commitCall(callIndex);
                            this.reportStatus(status);
                        }
                    }, delayMs);
                }
                else {
                    this.commitCall(callIndex);
                    this.reportStatus(status);
                }
                break;
            case 'RETRY':
                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();
                    this.maybeRetryCall(pushback, retried => {
                        if (!retried) {
                            this.commitCall(callIndex);
                            this.reportStatus(status);
                        }
                    });
                }
                else {
                    this.commitCall(callIndex);
                    this.reportStatus(status);
                }
                break;
        }
    }
    getPushback(metadata) {
        const mdValue = metadata.get('grpc-retry-pushback-ms');
        if (mdValue.length === 0) {
            return null;
        }
        try {
            return parseInt(mdValue[0]);
        }
        catch (e) {
            return -1;
        }
    }
    handleChildStatus(status, callIndex) {
        var _a;
        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {
            return;
        }
        this.trace('state=' +
            this.state +
            ' handling status with progress ' +
            status.progress +
            ' from child [' +
            this.underlyingCalls[callIndex].call.getCallNumber() +
            '] in state ' +
            this.underlyingCalls[callIndex].state);
        this.underlyingCalls[callIndex].state = 'COMPLETED';
        if (status.code === constants_1$2.Status.OK) {
            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();
            this.commitCall(callIndex);
            this.reportStatus(status);
            return;
        }
        if (this.state === 'COMMITTED') {
            this.reportStatus(status);
            return;
        }
        const pushback = this.getPushback(status.metadata);
        switch (status.progress) {
            case 'NOT_STARTED':
                // RPC never leaves the client, always safe to retry
                this.startNewAttempt();
                break;
            case 'REFUSED':
                // RPC reaches the server library, but not the server application logic
                if (this.transparentRetryUsed) {
                    this.handleProcessedStatus(status, callIndex, pushback);
                }
                else {
                    this.transparentRetryUsed = true;
                    this.startNewAttempt();
                }
                break;
            case 'DROP':
                this.commitCall(callIndex);
                this.reportStatus(status);
                break;
            case 'PROCESSED':
                this.handleProcessedStatus(status, callIndex, pushback);
                break;
        }
    }
    maybeStartHedgingAttempt() {
        if (this.state !== 'HEDGING') {
            return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
            return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {
            return;
        }
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
    }
    maybeStartHedgingTimer() {
        var _a, _b, _c;
        if (this.hedgingTimer) {
            clearTimeout(this.hedgingTimer);
        }
        if (this.state !== 'HEDGING') {
            return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
            return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {
            return;
        }
        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';
        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
        this.hedgingTimer = setTimeout(() => {
            this.maybeStartHedgingAttempt();
        }, hedgingDelaySec * 1000);
        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
    }
    startNewAttempt() {
        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
        this.trace('Created child call [' +
            child.getCallNumber() +
            '] for attempt ' +
            this.attempts);
        const index = this.underlyingCalls.length;
        this.underlyingCalls.push({
            state: 'ACTIVE',
            call: child,
            nextMessageToSend: 0,
            startTime: new Date()
        });
        const previousAttempts = this.attempts - 1;
        const initialMetadata = this.initialMetadata.clone();
        if (previousAttempts > 0) {
            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
        }
        let receivedMetadata = false;
        child.start(initialMetadata, {
            onReceiveMetadata: metadata => {
                this.trace('Received metadata from child [' + child.getCallNumber() + ']');
                this.commitCall(index);
                receivedMetadata = true;
                if (previousAttempts > 0) {
                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
                }
                if (this.underlyingCalls[index].state === 'ACTIVE') {
                    this.listener.onReceiveMetadata(metadata);
                }
            },
            onReceiveMessage: message => {
                this.trace('Received message from child [' + child.getCallNumber() + ']');
                this.commitCall(index);
                if (this.underlyingCalls[index].state === 'ACTIVE') {
                    this.listener.onReceiveMessage(message);
                }
            },
            onReceiveStatus: status => {
                this.trace('Received status from child [' + child.getCallNumber() + ']');
                if (!receivedMetadata && previousAttempts > 0) {
                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
                }
                this.handleChildStatus(status, index);
            },
        });
        this.sendNextChildMessage(index);
        if (this.readStarted) {
            child.startRead();
        }
    }
    start(metadata, listener) {
        this.trace('start called');
        this.listener = listener;
        this.initialMetadata = metadata;
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
    }
    handleChildWriteCompleted(childIndex) {
        var _a, _b;
        const childCall = this.underlyingCalls[childIndex];
        const messageIndex = childCall.nextMessageToSend;
        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.clearSentMessages();
        childCall.nextMessageToSend += 1;
        this.sendNextChildMessage(childIndex);
    }
    sendNextChildMessage(childIndex) {
        const childCall = this.underlyingCalls[childIndex];
        if (childCall.state === 'COMPLETED') {
            return;
        }
        if (this.getBufferEntry(childCall.nextMessageToSend)) {
            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
            switch (bufferEntry.entryType) {
                case 'MESSAGE':
                    childCall.call.sendMessageWithContext({
                        callback: error => {
                            // Ignore error
                            this.handleChildWriteCompleted(childIndex);
                        },
                    }, bufferEntry.message.message);
                    break;
                case 'HALF_CLOSE':
                    childCall.nextMessageToSend += 1;
                    childCall.call.halfClose();
                    break;
            }
        }
    }
    sendMessageWithContext(context, message) {
        var _a;
        this.trace('write() called with message of length ' + message.length);
        const writeObj = {
            message,
            flags: context.flags,
        };
        const messageIndex = this.getNextBufferIndex();
        const bufferEntry = {
            entryType: 'MESSAGE',
            message: writeObj,
            allocated: this.bufferTracker.allocate(message.length, this.callNumber),
        };
        this.writeBuffer.push(bufferEntry);
        if (bufferEntry.allocated) {
            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
            for (const [callIndex, call] of this.underlyingCalls.entries()) {
                if (call.state === 'ACTIVE' &&
                    call.nextMessageToSend === messageIndex) {
                    call.call.sendMessageWithContext({
                        callback: error => {
                            // Ignore error
                            this.handleChildWriteCompleted(callIndex);
                        },
                    }, message);
                }
            }
        }
        else {
            this.commitCallWithMostMessages();
            // commitCallWithMostMessages can fail if we are between ping attempts
            if (this.committedCallIndex === null) {
                return;
            }
            const call = this.underlyingCalls[this.committedCallIndex];
            bufferEntry.callback = context.callback;
            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {
                call.call.sendMessageWithContext({
                    callback: error => {
                        // Ignore error
                        this.handleChildWriteCompleted(this.committedCallIndex);
                    },
                }, message);
            }
        }
    }
    startRead() {
        this.trace('startRead called');
        this.readStarted = true;
        for (const underlyingCall of this.underlyingCalls) {
            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {
                underlyingCall.call.startRead();
            }
        }
    }
    halfClose() {
        this.trace('halfClose called');
        const halfCloseIndex = this.getNextBufferIndex();
        this.writeBuffer.push({
            entryType: 'HALF_CLOSE',
            allocated: false,
        });
        for (const call of this.underlyingCalls) {
            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&
                call.nextMessageToSend === halfCloseIndex) {
                call.nextMessageToSend += 1;
                call.call.halfClose();
            }
        }
    }
    setCredentials(newCredentials) {
        throw new Error('Method not implemented.');
    }
    getMethod() {
        return this.methodName;
    }
    getHost() {
        return this.host;
    }
}
retryingCall.RetryingCall = RetryingCall;

var subchannelInterface = {};

var hasRequiredSubchannelInterface;

function requireSubchannelInterface () {
	if (hasRequiredSubchannelInterface) return subchannelInterface;
	hasRequiredSubchannelInterface = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelInterface, "__esModule", { value: true });
	subchannelInterface.BaseSubchannelWrapper = void 0;
	class BaseSubchannelWrapper {
	    constructor(child) {
	        this.child = child;
	        this.healthy = true;
	        this.healthListeners = new Set();
	        child.addHealthStateWatcher(childHealthy => {
	            /* A change to the child health state only affects this wrapper's overall
	             * health state if this wrapper is reporting healthy. */
	            if (this.healthy) {
	                this.updateHealthListeners();
	            }
	        });
	    }
	    updateHealthListeners() {
	        for (const listener of this.healthListeners) {
	            listener(this.isHealthy());
	        }
	    }
	    getConnectivityState() {
	        return this.child.getConnectivityState();
	    }
	    addConnectivityStateListener(listener) {
	        this.child.addConnectivityStateListener(listener);
	    }
	    removeConnectivityStateListener(listener) {
	        this.child.removeConnectivityStateListener(listener);
	    }
	    startConnecting() {
	        this.child.startConnecting();
	    }
	    getAddress() {
	        return this.child.getAddress();
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        this.child.throttleKeepalive(newKeepaliveTime);
	    }
	    ref() {
	        this.child.ref();
	    }
	    unref() {
	        this.child.unref();
	    }
	    getChannelzRef() {
	        return this.child.getChannelzRef();
	    }
	    isHealthy() {
	        return this.healthy && this.child.isHealthy();
	    }
	    addHealthStateWatcher(listener) {
	        this.healthListeners.add(listener);
	    }
	    removeHealthStateWatcher(listener) {
	        this.healthListeners.delete(listener);
	    }
	    setHealthy(healthy) {
	        if (healthy !== this.healthy) {
	            this.healthy = healthy;
	            /* A change to this wrapper's health state only affects the overall
	             * reported health state if the child is healthy. */
	            if (this.child.isHealthy()) {
	                this.updateHealthListeners();
	            }
	        }
	    }
	    getRealSubchannel() {
	        return this.child.getRealSubchannel();
	    }
	    realSubchannelEquals(other) {
	        return this.getRealSubchannel() === other.getRealSubchannel();
	    }
	}
	subchannelInterface.BaseSubchannelWrapper = BaseSubchannelWrapper;
	
	return subchannelInterface;
}

var hasRequiredInternalChannel;

function requireInternalChannel () {
	if (hasRequiredInternalChannel) return internalChannel;
	hasRequiredInternalChannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(internalChannel, "__esModule", { value: true });
	internalChannel.InternalChannel = void 0;
	const channel_credentials_1 = channelCredentials;
	const resolving_load_balancer_1 = resolvingLoadBalancer;
	const subchannel_pool_1 = requireSubchannelPool();
	const picker_1 = requirePicker();
	const constants_1 = constants;
	const filter_stack_1 = requireFilterStack();
	const compression_filter_1 = compressionFilter;
	const resolver_1 = resolver;
	const logging_1 = logging$8;
	const max_message_size_filter_1 = maxMessageSizeFilter;
	const http_proxy_1 = http_proxy;
	const uri_parser_1 = uriParser;
	const connectivity_state_1 = connectivityState;
	const channelz_1 = requireChannelz();
	const load_balancing_call_1 = loadBalancingCall;
	const deadline_1 = deadline;
	const resolving_call_1 = resolvingCall;
	const call_number_1 = callNumber;
	const control_plane_status_1 = controlPlaneStatus;
	const retrying_call_1 = retryingCall;
	const subchannel_interface_1 = requireSubchannelInterface();
	/**
	 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
	 */
	const MAX_TIMEOUT_TIME = 2147483647;
	const MIN_IDLE_TIMEOUT_MS = 1000;
	// 30 minutes
	const DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;
	const RETRY_THROTTLER_MAP = new Map();
	const DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB
	const DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB
	class ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
	    constructor(childSubchannel, channel) {
	        super(childSubchannel);
	        this.channel = channel;
	        this.refCount = 0;
	        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
	            channel.throttleKeepalive(keepaliveTime);
	        };
	        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);
	    }
	    ref() {
	        this.child.ref();
	        this.refCount += 1;
	    }
	    unref() {
	        this.child.unref();
	        this.refCount -= 1;
	        if (this.refCount <= 0) {
	            this.child.removeConnectivityStateListener(this.subchannelStateListener);
	            this.channel.removeWrappedSubchannel(this);
	        }
	    }
	}
	class InternalChannel {
	    constructor(target, credentials, options) {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        this.credentials = credentials;
	        this.options = options;
	        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
	        this.currentPicker = new picker_1.UnavailablePicker();
	        /**
	         * Calls queued up to get a call config. Should only be populated before the
	         * first time the resolver returns a result, which includes the ConfigSelector.
	         */
	        this.configSelectionQueue = [];
	        this.pickQueue = [];
	        this.connectivityStateWatchers = [];
	        this.configSelector = null;
	        /**
	         * This is the error from the name resolver if it failed most recently. It
	         * is only used to end calls that start while there is no config selector
	         * and the name resolver is in backoff, so it should be nulled if
	         * configSelector becomes set or the channel state becomes anything other
	         * than TRANSIENT_FAILURE.
	         */
	        this.currentResolutionError = null;
	        this.wrappedSubchannels = new Set();
	        this.callCount = 0;
	        this.idleTimer = null;
	        // Channelz info
	        this.channelzEnabled = true;
	        this.callTracker = new channelz_1.ChannelzCallTracker();
	        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
	        /**
	         * Randomly generated ID to be passed to the config selector, for use by
	         * ring_hash in xDS. An integer distributed approximately uniformly between
	         * 0 and MAX_SAFE_INTEGER.
	         */
	        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
	        if (typeof target !== 'string') {
	            throw new TypeError('Channel target must be a string');
	        }
	        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
	            throw new TypeError('Channel credentials must be a ChannelCredentials object');
	        }
	        if (options) {
	            if (typeof options !== 'object') {
	                throw new TypeError('Channel options must be an object');
	            }
	        }
	        this.originalTarget = target;
	        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
	        if (originalTargetUri === null) {
	            throw new Error(`Could not parse target name "${target}"`);
	        }
	        /* This ensures that the target has a scheme that is registered with the
	         * resolver */
	        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
	        if (defaultSchemeMapResult === null) {
	            throw new Error(`Could not find a default scheme for target name "${target}"`);
	        }
	        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);
	        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	        if (this.options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	        }
	        this.channelzTrace = new channelz_1.ChannelzTrace();
	        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Channel created');
	        }
	        if (this.options['grpc.default_authority']) {
	            this.defaultAuthority = this.options['grpc.default_authority'];
	        }
	        else {
	            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
	        }
	        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
	        this.target = proxyMapResult.target;
	        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
	        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
	         * the grpc.use_local_subchannel_pool channel option means. */
	        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);
	        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
	        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== void 0 ? _f : -1;
	        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
	        const channelControlHelper = {
	            createSubchannel: (subchannelAddress, subchannelArgs) => {
	                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
	                subchannel.throttleKeepalive(this.keepaliveTime);
	                if (this.channelzEnabled) {
	                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());
	                }
	                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
	                this.wrappedSubchannels.add(wrappedSubchannel);
	                return wrappedSubchannel;
	            },
	            updateState: (connectivityState, picker) => {
	                this.currentPicker = picker;
	                const queueCopy = this.pickQueue.slice();
	                this.pickQueue = [];
	                if (queueCopy.length > 0) {
	                    this.callRefTimerUnref();
	                }
	                for (const call of queueCopy) {
	                    call.doPick();
	                }
	                this.updateState(connectivityState);
	            },
	            requestReresolution: () => {
	                // This should never be called.
	                throw new Error('Resolving load balancer should never call requestReresolution');
	            },
	            addChannelzChild: (child) => {
	                if (this.channelzEnabled) {
	                    this.childrenTracker.refChild(child);
	                }
	            },
	            removeChannelzChild: (child) => {
	                if (this.channelzEnabled) {
	                    this.childrenTracker.unrefChild(child);
	                }
	            },
	        };
	        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {
	            if (serviceConfig.retryThrottling) {
	                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
	            }
	            else {
	                RETRY_THROTTLER_MAP.delete(this.getTarget());
	            }
	            if (this.channelzEnabled) {
	                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');
	            }
	            this.configSelector = configSelector;
	            this.currentResolutionError = null;
	            /* We process the queue asynchronously to ensure that the corresponding
	             * load balancer update has completed. */
	            process.nextTick(() => {
	                const localQueue = this.configSelectionQueue;
	                this.configSelectionQueue = [];
	                if (localQueue.length > 0) {
	                    this.callRefTimerUnref();
	                }
	                for (const call of localQueue) {
	                    call.getConfig();
	                }
	            });
	        }, status => {
	            if (this.channelzEnabled) {
	                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +
	                    status.code +
	                    ' and details "' +
	                    status.details +
	                    '"');
	            }
	            if (this.configSelectionQueue.length > 0) {
	                this.trace('Name resolution failed with calls queued for config selection');
	            }
	            if (this.configSelector === null) {
	                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
	            }
	            const localQueue = this.configSelectionQueue;
	            this.configSelectionQueue = [];
	            if (localQueue.length > 0) {
	                this.callRefTimerUnref();
	            }
	            for (const call of localQueue) {
	                call.reportResolverError(status);
	            }
	        });
	        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
	            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
	            new compression_filter_1.CompressionFilterFactory(this, this.options),
	        ]);
	        this.trace('Channel constructed with options ' +
	            JSON.stringify(options, undefined, 2));
	        const error = new Error();
	        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +
	            this.channelzRef.id +
	            ') ' +
	            'Channel constructed \n' +
	            ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf('\n') + 1)));
	        this.lastActivityTimestamp = new Date();
	    }
	    getChannelzInfo() {
	        return {
	            target: this.originalTarget,
	            state: this.connectivityState,
	            trace: this.channelzTrace,
	            callTracker: this.callTracker,
	            children: this.childrenTracker.getChildLists(),
	        };
	    }
	    trace(text, verbosityOverride) {
	        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);
	    }
	    callRefTimerRef() {
	        var _a, _b, _c, _d;
	        // If the hasRef function does not exist, always run the code
	        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
	            this.trace('callRefTimer.ref | configSelectionQueue.length=' +
	                this.configSelectionQueue.length +
	                ' pickQueue.length=' +
	                this.pickQueue.length);
	            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
	        }
	    }
	    callRefTimerUnref() {
	        var _a, _b;
	        // If the hasRef function does not exist, always run the code
	        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
	            this.trace('callRefTimer.unref | configSelectionQueue.length=' +
	                this.configSelectionQueue.length +
	                ' pickQueue.length=' +
	                this.pickQueue.length);
	            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	        }
	    }
	    removeConnectivityStateWatcher(watcherObject) {
	        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);
	        if (watcherIndex >= 0) {
	            this.connectivityStateWatchers.splice(watcherIndex, 1);
	        }
	    }
	    updateState(newState) {
	        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +
	            this.channelzRef.id +
	            ') ' +
	            (0, uri_parser_1.uriToString)(this.target) +
	            ' ' +
	            connectivity_state_1.ConnectivityState[this.connectivityState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
	        }
	        this.connectivityState = newState;
	        const watchersCopy = this.connectivityStateWatchers.slice();
	        for (const watcherObject of watchersCopy) {
	            if (newState !== watcherObject.currentState) {
	                if (watcherObject.timer) {
	                    clearTimeout(watcherObject.timer);
	                }
	                this.removeConnectivityStateWatcher(watcherObject);
	                watcherObject.callback();
	            }
	        }
	        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	            this.currentResolutionError = null;
	        }
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        if (newKeepaliveTime > this.keepaliveTime) {
	            this.keepaliveTime = newKeepaliveTime;
	            for (const wrappedSubchannel of this.wrappedSubchannels) {
	                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
	            }
	        }
	    }
	    removeWrappedSubchannel(wrappedSubchannel) {
	        this.wrappedSubchannels.delete(wrappedSubchannel);
	    }
	    doPick(metadata, extraPickInfo) {
	        return this.currentPicker.pick({
	            metadata: metadata,
	            extraPickInfo: extraPickInfo,
	        });
	    }
	    queueCallForPick(call) {
	        this.pickQueue.push(call);
	        this.callRefTimerRef();
	    }
	    getConfig(method, metadata) {
	        this.resolvingLoadBalancer.exitIdle();
	        if (this.configSelector) {
	            return {
	                type: 'SUCCESS',
	                config: this.configSelector(method, metadata, this.randomChannelId),
	            };
	        }
	        else {
	            if (this.currentResolutionError) {
	                return {
	                    type: 'ERROR',
	                    error: this.currentResolutionError,
	                };
	            }
	            else {
	                return {
	                    type: 'NONE',
	                };
	            }
	        }
	    }
	    queueCallForConfig(call) {
	        this.configSelectionQueue.push(call);
	        this.callRefTimerRef();
	    }
	    enterIdle() {
	        this.resolvingLoadBalancer.destroy();
	        this.updateState(connectivity_state_1.ConnectivityState.IDLE);
	        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
	        if (this.idleTimer) {
	            clearTimeout(this.idleTimer);
	            this.idleTimer = null;
	        }
	    }
	    startIdleTimeout(timeoutMs) {
	        var _a, _b;
	        this.idleTimer = setTimeout(() => {
	            if (this.callCount > 0) {
	                /* If there is currently a call, the channel will not go idle for a
	                 * period of at least idleTimeoutMs, so check again after that time.
	                 */
	                this.startIdleTimeout(this.idleTimeoutMs);
	                return;
	            }
	            const now = new Date();
	            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
	            if (timeSinceLastActivity >= this.idleTimeoutMs) {
	                this.trace('Idle timer triggered after ' +
	                    this.idleTimeoutMs +
	                    'ms of inactivity');
	                this.enterIdle();
	            }
	            else {
	                /* Whenever the timer fires with the latest activity being too recent,
	                 * set the timer again for the time when the time since the last
	                 * activity is equal to the timeout. This should result in the timer
	                 * firing no more than once every idleTimeoutMs/2 on average. */
	                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
	            }
	        }, timeoutMs);
	        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    maybeStartIdleTimer() {
	        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN &&
	            !this.idleTimer) {
	            this.startIdleTimeout(this.idleTimeoutMs);
	        }
	    }
	    onCallStart() {
	        if (this.channelzEnabled) {
	            this.callTracker.addCallStarted();
	        }
	        this.callCount += 1;
	    }
	    onCallEnd(status) {
	        if (this.channelzEnabled) {
	            if (status.code === constants_1.Status.OK) {
	                this.callTracker.addCallSucceeded();
	            }
	            else {
	                this.callTracker.addCallFailed();
	            }
	        }
	        this.callCount -= 1;
	        this.lastActivityTimestamp = new Date();
	        this.maybeStartIdleTimer();
	    }
	    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createLoadBalancingCall [' + callNumber + '] method="' + method + '"');
	        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
	    }
	    createRetryingCall(callConfig, method, host, credentials, deadline) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createRetryingCall [' + callNumber + '] method="' + method + '"');
	        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
	    }
	    createInnerCall(callConfig, method, host, credentials, deadline) {
	        // Create a RetryingCall if retries are enabled
	        if (this.options['grpc.enable_retries'] === 0) {
	            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
	        }
	        else {
	            return this.createRetryingCall(callConfig, method, host, credentials, deadline);
	        }
	    }
	    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createResolvingCall [' +
	            callNumber +
	            '] method="' +
	            method +
	            '", deadline=' +
	            (0, deadline_1.deadlineToString)(deadline));
	        const finalOptions = {
	            deadline: deadline,
	            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
	            host: host !== null && host !== void 0 ? host : this.defaultAuthority,
	            parentCall: parentCall,
	        };
	        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
	        this.onCallStart();
	        call.addStatusWatcher(status => {
	            this.onCallEnd(status);
	        });
	        return call;
	    }
	    close() {
	        this.resolvingLoadBalancer.destroy();
	        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
	        clearInterval(this.callRefTimer);
	        if (this.idleTimer) {
	            clearTimeout(this.idleTimer);
	        }
	        if (this.channelzEnabled) {
	            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	        }
	        this.subchannelPool.unrefUnusedSubchannels();
	    }
	    getTarget() {
	        return (0, uri_parser_1.uriToString)(this.target);
	    }
	    getConnectivityState(tryToConnect) {
	        const connectivityState = this.connectivityState;
	        if (tryToConnect) {
	            this.resolvingLoadBalancer.exitIdle();
	            this.lastActivityTimestamp = new Date();
	            this.maybeStartIdleTimer();
	        }
	        return connectivityState;
	    }
	    watchConnectivityState(currentState, deadline, callback) {
	        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            throw new Error('Channel has been shut down');
	        }
	        let timer = null;
	        if (deadline !== Infinity) {
	            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
	            const now = new Date();
	            if (deadline === -Infinity || deadlineDate <= now) {
	                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
	                return;
	            }
	            timer = setTimeout(() => {
	                this.removeConnectivityStateWatcher(watcherObject);
	                callback(new Error('Deadline passed without connectivity state change'));
	            }, deadlineDate.getTime() - now.getTime());
	        }
	        const watcherObject = {
	            currentState,
	            callback,
	            timer,
	        };
	        this.connectivityStateWatchers.push(watcherObject);
	    }
	    /**
	     * Get the channelz reference object for this channel. The returned value is
	     * garbage if channelz is disabled for this channel.
	     * @returns
	     */
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    createCall(method, deadline, host, parentCall, propagateFlags) {
	        if (typeof method !== 'string') {
	            throw new TypeError('Channel#createCall: method must be a string');
	        }
	        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
	            throw new TypeError('Channel#createCall: deadline must be a number or Date');
	        }
	        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            throw new Error('Channel has been shut down');
	        }
	        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
	    }
	}
	internalChannel.InternalChannel = InternalChannel;
	
	return internalChannel;
}

var hasRequiredChannel;

function requireChannel () {
	if (hasRequiredChannel) return channel;
	hasRequiredChannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channel, "__esModule", { value: true });
	channel.ChannelImplementation = void 0;
	const channel_credentials_1 = channelCredentials;
	const internal_channel_1 = requireInternalChannel();
	class ChannelImplementation {
	    constructor(target, credentials, options) {
	        if (typeof target !== 'string') {
	            throw new TypeError('Channel target must be a string');
	        }
	        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
	            throw new TypeError('Channel credentials must be a ChannelCredentials object');
	        }
	        if (options) {
	            if (typeof options !== 'object') {
	                throw new TypeError('Channel options must be an object');
	            }
	        }
	        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
	    }
	    close() {
	        this.internalChannel.close();
	    }
	    getTarget() {
	        return this.internalChannel.getTarget();
	    }
	    getConnectivityState(tryToConnect) {
	        return this.internalChannel.getConnectivityState(tryToConnect);
	    }
	    watchConnectivityState(currentState, deadline, callback) {
	        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
	    }
	    /**
	     * Get the channelz reference object for this channel. The returned value is
	     * garbage if channelz is disabled for this channel.
	     * @returns
	     */
	    getChannelzRef() {
	        return this.internalChannel.getChannelzRef();
	    }
	    createCall(method, deadline, host, parentCall, propagateFlags) {
	        if (typeof method !== 'string') {
	            throw new TypeError('Channel#createCall: method must be a string');
	        }
	        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
	            throw new TypeError('Channel#createCall: deadline must be a number or Date');
	        }
	        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
	    }
	}
	channel.ChannelImplementation = ChannelImplementation;
	
	return channel;
}

var server = {};

var serverCall = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(serverCall, "__esModule", { value: true });
serverCall.ServerDuplexStreamImpl = serverCall.ServerWritableStreamImpl = serverCall.ServerReadableStreamImpl = serverCall.ServerUnaryCallImpl = serverCall.serverErrorToStatus = void 0;
const events_1 = require$$0$4;
const stream_1 = require$$1$2;
const constants_1$1 = constants;
const metadata_1 = metadata;
function serverErrorToStatus(error, overrideTrailers) {
    var _a;
    const status = {
        code: constants_1$1.Status.UNKNOWN,
        details: 'message' in error ? error.message : 'Unknown Error',
        metadata: (_a = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a !== void 0 ? _a : null,
    };
    if ('code' in error &&
        typeof error.code === 'number' &&
        Number.isInteger(error.code)) {
        status.code = error.code;
        if ('details' in error && typeof error.details === 'string') {
            status.details = error.details;
        }
    }
    return status;
}
serverCall.serverErrorToStatus = serverErrorToStatus;
class ServerUnaryCallImpl extends events_1.EventEmitter {
    constructor(path, call, metadata, request) {
        super();
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
}
serverCall.ServerUnaryCallImpl = ServerUnaryCallImpl;
class ServerReadableStreamImpl extends stream_1.Readable {
    constructor(path, call, metadata) {
        super({ objectMode: true });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.cancelled = false;
    }
    _read(size) {
        this.call.startRead();
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
}
serverCall.ServerReadableStreamImpl = ServerReadableStreamImpl;
class ServerWritableStreamImpl extends stream_1.Writable {
    constructor(path, call, metadata, request) {
        super({ objectMode: true });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.pendingStatus = {
            code: constants_1$1.Status.OK,
            details: 'OK',
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on('error', err => {
            this.pendingStatus = serverErrorToStatus(err);
            this.end();
        });
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
    _write(chunk, encoding, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        this.call.sendMessage(chunk, callback);
    }
    _final(callback) {
        var _a;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) {
        if (metadata) {
            this.trailingMetadata = metadata;
        }
        return super.end();
    }
}
serverCall.ServerWritableStreamImpl = ServerWritableStreamImpl;
class ServerDuplexStreamImpl extends stream_1.Duplex {
    constructor(path, call, metadata) {
        super({ objectMode: true });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.pendingStatus = {
            code: constants_1$1.Status.OK,
            details: 'OK',
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on('error', err => {
            this.pendingStatus = serverErrorToStatus(err);
            this.end();
        });
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
    _read(size) {
        this.call.startRead();
    }
    _write(chunk, encoding, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        this.call.sendMessage(chunk, callback);
    }
    _final(callback) {
        var _a;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) {
        if (metadata) {
            this.trailingMetadata = metadata;
        }
        return super.end();
    }
}
serverCall.ServerDuplexStreamImpl = ServerDuplexStreamImpl;

var serverCredentials = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(serverCredentials, "__esModule", { value: true });
serverCredentials.ServerCredentials = void 0;
const tls_helpers_1 = tlsHelpers;
class ServerCredentials {
    static createInsecure() {
        return new InsecureServerCredentials();
    }
    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        var _a;
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
            throw new TypeError('rootCerts must be null or a Buffer');
        }
        if (!Array.isArray(keyCertPairs)) {
            throw new TypeError('keyCertPairs must be an array');
        }
        if (typeof checkClientCertificate !== 'boolean') {
            throw new TypeError('checkClientCertificate must be a boolean');
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
            const pair = keyCertPairs[i];
            if (pair === null || typeof pair !== 'object') {
                throw new TypeError(`keyCertPair[${i}] must be an object`);
            }
            if (!Buffer.isBuffer(pair.private_key)) {
                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
            }
            if (!Buffer.isBuffer(pair.cert_chain)) {
                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
            }
            cert.push(pair.cert_chain);
            key.push(pair.private_key);
        }
        return new SecureServerCredentials({
            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,
            cert,
            key,
            requestCert: checkClientCertificate,
            ciphers: tls_helpers_1.CIPHER_SUITES,
        });
    }
}
serverCredentials.ServerCredentials = ServerCredentials;
class InsecureServerCredentials extends ServerCredentials {
    _isSecure() {
        return false;
    }
    _getSettings() {
        return null;
    }
    _equals(other) {
        return other instanceof InsecureServerCredentials;
    }
}
class SecureServerCredentials extends ServerCredentials {
    constructor(options) {
        super();
        this.options = options;
    }
    _isSecure() {
        return true;
    }
    _getSettings() {
        return this.options;
    }
    /**
     * Checks equality by checking the options that are actually set by
     * createSsl.
     * @param other
     * @returns
     */
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof SecureServerCredentials)) {
            return false;
        }
        // options.ca equality check
        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
            if (!this.options.ca.equals(other.options.ca)) {
                return false;
            }
        }
        else {
            if (this.options.ca !== other.options.ca) {
                return false;
            }
        }
        // options.cert equality check
        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
            if (this.options.cert.length !== other.options.cert.length) {
                return false;
            }
            for (let i = 0; i < this.options.cert.length; i++) {
                const thisCert = this.options.cert[i];
                const otherCert = other.options.cert[i];
                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
                    if (!thisCert.equals(otherCert)) {
                        return false;
                    }
                }
                else {
                    if (thisCert !== otherCert) {
                        return false;
                    }
                }
            }
        }
        else {
            if (this.options.cert !== other.options.cert) {
                return false;
            }
        }
        // options.key equality check
        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
            if (this.options.key.length !== other.options.key.length) {
                return false;
            }
            for (let i = 0; i < this.options.key.length; i++) {
                const thisKey = this.options.key[i];
                const otherKey = other.options.key[i];
                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
                    if (!thisKey.equals(otherKey)) {
                        return false;
                    }
                }
                else {
                    if (thisKey !== otherKey) {
                        return false;
                    }
                }
            }
        }
        else {
            if (this.options.key !== other.options.key) {
                return false;
            }
        }
        // options.requestCert equality check
        if (this.options.requestCert !== other.options.requestCert) {
            return false;
        }
        /* ciphers is derived from a value that is constant for the process, so no
         * equality check is needed. */
        return true;
    }
}

var serverInterceptors = {};

var hasRequiredServerInterceptors;

function requireServerInterceptors () {
	if (hasRequiredServerInterceptors) return serverInterceptors;
	hasRequiredServerInterceptors = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverInterceptors, "__esModule", { value: true });
	serverInterceptors.getServerInterceptingCall = serverInterceptors.BaseServerInterceptingCall = serverInterceptors.ServerInterceptingCall = serverInterceptors.ResponderBuilder = serverInterceptors.isInterceptingServerListener = serverInterceptors.ServerListenerBuilder = void 0;
	const metadata_1 = metadata;
	const constants_1 = constants;
	const http2 = require$$0$5;
	const error_1 = error;
	const zlib = require$$0$6;
	const util_1 = require$$2;
	const stream_decoder_1 = requireStreamDecoder();
	const logging = logging$8;
	const unzip = (0, util_1.promisify)(zlib.unzip);
	const inflate = (0, util_1.promisify)(zlib.inflate);
	const TRACER_NAME = 'server_call';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	class ServerListenerBuilder {
	    constructor() {
	        this.metadata = undefined;
	        this.message = undefined;
	        this.halfClose = undefined;
	        this.cancel = undefined;
	    }
	    withOnReceiveMetadata(onReceiveMetadata) {
	        this.metadata = onReceiveMetadata;
	        return this;
	    }
	    withOnReceiveMessage(onReceiveMessage) {
	        this.message = onReceiveMessage;
	        return this;
	    }
	    withOnReceiveHalfClose(onReceiveHalfClose) {
	        this.halfClose = onReceiveHalfClose;
	        return this;
	    }
	    withOnCancel(onCancel) {
	        this.cancel = onCancel;
	        return this;
	    }
	    build() {
	        return {
	            onReceiveMetadata: this.metadata,
	            onReceiveMessage: this.message,
	            onReceiveHalfClose: this.halfClose,
	            onCancel: this.cancel,
	        };
	    }
	}
	serverInterceptors.ServerListenerBuilder = ServerListenerBuilder;
	function isInterceptingServerListener(listener) {
	    return (listener.onReceiveMetadata !== undefined &&
	        listener.onReceiveMetadata.length === 1);
	}
	serverInterceptors.isInterceptingServerListener = isInterceptingServerListener;
	class InterceptingServerListenerImpl {
	    constructor(listener, nextListener) {
	        this.listener = listener;
	        this.nextListener = nextListener;
	        /**
	         * Once the call is cancelled, ignore all other events.
	         */
	        this.cancelled = false;
	        this.processingMetadata = false;
	        this.hasPendingMessage = false;
	        this.pendingMessage = null;
	        this.processingMessage = false;
	        this.hasPendingHalfClose = false;
	    }
	    processPendingMessage() {
	        if (this.hasPendingMessage) {
	            this.nextListener.onReceiveMessage(this.pendingMessage);
	            this.pendingMessage = null;
	            this.hasPendingMessage = false;
	        }
	    }
	    processPendingHalfClose() {
	        if (this.hasPendingHalfClose) {
	            this.nextListener.onReceiveHalfClose();
	            this.hasPendingHalfClose = false;
	        }
	    }
	    onReceiveMetadata(metadata) {
	        if (this.cancelled) {
	            return;
	        }
	        this.processingMetadata = true;
	        this.listener.onReceiveMetadata(metadata, interceptedMetadata => {
	            this.processingMetadata = false;
	            if (this.cancelled) {
	                return;
	            }
	            this.nextListener.onReceiveMetadata(interceptedMetadata);
	            this.processPendingMessage();
	            this.processPendingHalfClose();
	        });
	    }
	    onReceiveMessage(message) {
	        if (this.cancelled) {
	            return;
	        }
	        this.processingMessage = true;
	        this.listener.onReceiveMessage(message, msg => {
	            this.processingMessage = false;
	            if (this.cancelled) {
	                return;
	            }
	            if (this.processingMetadata) {
	                this.pendingMessage = msg;
	                this.hasPendingMessage = true;
	            }
	            else {
	                this.nextListener.onReceiveMessage(msg);
	                this.processPendingHalfClose();
	            }
	        });
	    }
	    onReceiveHalfClose() {
	        if (this.cancelled) {
	            return;
	        }
	        this.listener.onReceiveHalfClose(() => {
	            if (this.cancelled) {
	                return;
	            }
	            if (this.processingMetadata || this.processingMessage) {
	                this.hasPendingHalfClose = true;
	            }
	            else {
	                this.nextListener.onReceiveHalfClose();
	            }
	        });
	    }
	    onCancel() {
	        this.cancelled = true;
	        this.listener.onCancel();
	        this.nextListener.onCancel();
	    }
	}
	class ResponderBuilder {
	    constructor() {
	        this.start = undefined;
	        this.metadata = undefined;
	        this.message = undefined;
	        this.status = undefined;
	    }
	    withStart(start) {
	        this.start = start;
	        return this;
	    }
	    withSendMetadata(sendMetadata) {
	        this.metadata = sendMetadata;
	        return this;
	    }
	    withSendMessage(sendMessage) {
	        this.message = sendMessage;
	        return this;
	    }
	    withSendStatus(sendStatus) {
	        this.status = sendStatus;
	        return this;
	    }
	    build() {
	        return {
	            start: this.start,
	            sendMetadata: this.metadata,
	            sendMessage: this.message,
	            sendStatus: this.status,
	        };
	    }
	}
	serverInterceptors.ResponderBuilder = ResponderBuilder;
	const defaultServerListener = {
	    onReceiveMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    onReceiveMessage: (message, next) => {
	        next(message);
	    },
	    onReceiveHalfClose: next => {
	        next();
	    },
	    onCancel: () => { },
	};
	const defaultResponder = {
	    start: next => {
	        next();
	    },
	    sendMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    sendMessage: (message, next) => {
	        next(message);
	    },
	    sendStatus: (status, next) => {
	        next(status);
	    },
	};
	class ServerInterceptingCall {
	    constructor(nextCall, responder) {
	        var _a, _b, _c, _d;
	        this.nextCall = nextCall;
	        this.processingMetadata = false;
	        this.processingMessage = false;
	        this.pendingMessage = null;
	        this.pendingMessageCallback = null;
	        this.pendingStatus = null;
	        this.responder = {
	            start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a !== void 0 ? _a : defaultResponder.start,
	            sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b !== void 0 ? _b : defaultResponder.sendMetadata,
	            sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c !== void 0 ? _c : defaultResponder.sendMessage,
	            sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus,
	        };
	    }
	    processPendingMessage() {
	        if (this.pendingMessageCallback) {
	            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
	            this.pendingMessage = null;
	            this.pendingMessageCallback = null;
	        }
	    }
	    processPendingStatus() {
	        if (this.pendingStatus) {
	            this.nextCall.sendStatus(this.pendingStatus);
	            this.pendingStatus = null;
	        }
	    }
	    start(listener) {
	        this.responder.start(interceptedListener => {
	            var _a, _b, _c, _d;
	            const fullInterceptedListener = {
	                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,
	                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,
	                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,
	                onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel,
	            };
	            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
	            this.nextCall.start(finalInterceptingListener);
	        });
	    }
	    sendMetadata(metadata) {
	        this.processingMetadata = true;
	        this.responder.sendMetadata(metadata, interceptedMetadata => {
	            this.processingMetadata = false;
	            this.nextCall.sendMetadata(interceptedMetadata);
	            this.processPendingMessage();
	            this.processPendingStatus();
	        });
	    }
	    sendMessage(message, callback) {
	        this.processingMessage = true;
	        this.responder.sendMessage(message, interceptedMessage => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessage = interceptedMessage;
	                this.pendingMessageCallback = callback;
	            }
	            else {
	                this.nextCall.sendMessage(interceptedMessage, callback);
	            }
	        });
	    }
	    sendStatus(status) {
	        this.responder.sendStatus(status, interceptedStatus => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingStatus = interceptedStatus;
	            }
	            else {
	                this.nextCall.sendStatus(interceptedStatus);
	            }
	        });
	    }
	    startRead() {
	        this.nextCall.startRead();
	    }
	    getPeer() {
	        return this.nextCall.getPeer();
	    }
	    getDeadline() {
	        return this.nextCall.getDeadline();
	    }
	}
	serverInterceptors.ServerInterceptingCall = ServerInterceptingCall;
	const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
	const GRPC_ENCODING_HEADER = 'grpc-encoding';
	const GRPC_MESSAGE_HEADER = 'grpc-message';
	const GRPC_STATUS_HEADER = 'grpc-status';
	const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
	const DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
	const deadlineUnitsToMs = {
	    H: 3600000,
	    M: 60000,
	    S: 1000,
	    m: 1,
	    u: 0.001,
	    n: 0.000001,
	};
	const defaultCompressionHeaders = {
	    // TODO(cjihrig): Remove these encoding headers from the default response
	    // once compression is integrated.
	    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
	    [GRPC_ENCODING_HEADER]: 'identity',
	};
	const defaultResponseHeaders = {
	    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
	    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
	};
	const defaultResponseOptions = {
	    waitForTrailers: true,
	};
	class BaseServerInterceptingCall {
	    constructor(stream, headers, callEventTracker, handler, options) {
	        this.stream = stream;
	        this.callEventTracker = callEventTracker;
	        this.handler = handler;
	        this.listener = null;
	        this.deadlineTimer = null;
	        this.deadline = Infinity;
	        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
	        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.cancelled = false;
	        this.metadataSent = false;
	        this.wantTrailers = false;
	        this.cancelNotified = false;
	        this.incomingEncoding = 'identity';
	        this.decoder = new stream_decoder_1.StreamDecoder();
	        this.readQueue = [];
	        this.isReadPending = false;
	        this.receivedHalfClose = false;
	        this.streamEnded = false;
	        this.stream.once('error', (err) => {
	            /* We need an error handler to avoid uncaught error event exceptions, but
	             * there is nothing we can reasonably do here. Any error event should
	             * have a corresponding close event, which handles emitting the cancelled
	             * event. And the stream is now in a bad state, so we can't reasonably
	             * expect to be able to send an error over it. */
	        });
	        this.stream.once('close', () => {
	            var _a;
	            trace('Request to method ' +
	                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
	                ' stream closed with rstCode ' +
	                this.stream.rstCode);
	            if (this.callEventTracker && !this.streamEnded) {
	                this.streamEnded = true;
	                this.callEventTracker.onStreamEnd(false);
	                this.callEventTracker.onCallEnd({
	                    code: constants_1.Status.CANCELLED,
	                    details: 'Stream closed before sending status',
	                    metadata: null,
	                });
	            }
	            this.notifyOnCancel();
	        });
	        this.stream.on('data', (data) => {
	            this.handleDataFrame(data);
	        });
	        this.stream.pause();
	        this.stream.on('end', () => {
	            this.handleEndEvent();
	        });
	        if ('grpc.max_send_message_length' in options) {
	            this.maxSendMessageSize = options['grpc.max_send_message_length'];
	        }
	        if ('grpc.max_receive_message_length' in options) {
	            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
	        }
	        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	        if (logging.isTracerEnabled(TRACER_NAME)) {
	            trace('Request to ' +
	                this.handler.path +
	                ' received headers ' +
	                JSON.stringify(metadata.toJSON()));
	        }
	        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
	        if (timeoutHeader.length > 0) {
	            this.handleTimeoutHeader(timeoutHeader[0]);
	        }
	        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
	        if (encodingHeader.length > 0) {
	            this.incomingEncoding = encodingHeader[0];
	        }
	        // Remove several headers that should not be propagated to the application
	        metadata.remove(GRPC_TIMEOUT_HEADER);
	        metadata.remove(GRPC_ENCODING_HEADER);
	        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
	        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
	        metadata.remove(http2.constants.HTTP2_HEADER_TE);
	        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
	        this.metadata = metadata;
	    }
	    handleTimeoutHeader(timeoutHeader) {
	        const match = timeoutHeader.toString().match(DEADLINE_REGEX);
	        if (match === null) {
	            const status = {
	                code: constants_1.Status.INTERNAL,
	                details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
	                metadata: null,
	            };
	            // Wait for the constructor to complete before sending the error.
	            process.nextTick(() => {
	                this.sendStatus(status);
	            });
	            return;
	        }
	        const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;
	        const now = new Date();
	        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
	        this.deadlineTimer = setTimeout(() => {
	            const status = {
	                code: constants_1.Status.DEADLINE_EXCEEDED,
	                details: 'Deadline exceeded',
	                metadata: null,
	            };
	            this.sendStatus(status);
	        }, timeout);
	    }
	    checkCancelled() {
	        /* In some cases the stream can become destroyed before the close event
	         * fires. That creates a race condition that this check works around */
	        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
	            this.notifyOnCancel();
	            this.cancelled = true;
	        }
	        return this.cancelled;
	    }
	    notifyOnCancel() {
	        if (this.cancelNotified) {
	            return;
	        }
	        this.cancelNotified = true;
	        this.cancelled = true;
	        process.nextTick(() => {
	            var _a;
	            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onCancel();
	        });
	        if (this.deadlineTimer) {
	            clearTimeout(this.deadlineTimer);
	        }
	        // Flush incoming data frames
	        this.stream.resume();
	    }
	    /**
	     * A server handler can start sending messages without explicitly sending
	     * metadata. In that case, we need to send headers before sending any
	     * messages. This function does that if necessary.
	     */
	    maybeSendMetadata() {
	        if (!this.metadataSent) {
	            this.sendMetadata(new metadata_1.Metadata());
	        }
	    }
	    /**
	     * Serialize a message to a length-delimited byte string.
	     * @param value
	     * @returns
	     */
	    serializeMessage(value) {
	        const messageBuffer = this.handler.serialize(value);
	        const byteLength = messageBuffer.byteLength;
	        const output = Buffer.allocUnsafe(byteLength + 5);
	        /* Note: response compression is currently not supported, so this
	         * compressed bit is always 0. */
	        output.writeUInt8(0, 0);
	        output.writeUInt32BE(byteLength, 1);
	        messageBuffer.copy(output, 5);
	        return output;
	    }
	    decompressMessage(message, encoding) {
	        switch (encoding) {
	            case 'deflate':
	                return inflate(message.subarray(5));
	            case 'gzip':
	                return unzip(message.subarray(5));
	            case 'identity':
	                return message.subarray(5);
	            default:
	                return Promise.reject({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received message compressed with unsupported encoding "${encoding}"`,
	                });
	        }
	    }
	    async decompressAndMaybePush(queueEntry) {
	        if (queueEntry.type !== 'COMPRESSED') {
	            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
	        }
	        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
	        const compressedMessageEncoding = compressed
	            ? this.incomingEncoding
	            : 'identity';
	        const decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
	        try {
	            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
	        }
	        catch (err) {
	            this.sendStatus({
	                code: constants_1.Status.INTERNAL,
	                details: `Error deserializing request: ${err.message}`,
	            });
	            return;
	        }
	        queueEntry.type = 'READABLE';
	        this.maybePushNextMessage();
	    }
	    maybePushNextMessage() {
	        if (this.listener &&
	            this.isReadPending &&
	            this.readQueue.length > 0 &&
	            this.readQueue[0].type !== 'COMPRESSED') {
	            this.isReadPending = false;
	            const nextQueueEntry = this.readQueue.shift();
	            if (nextQueueEntry.type === 'READABLE') {
	                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
	            }
	            else {
	                // nextQueueEntry.type === 'HALF_CLOSE'
	                this.listener.onReceiveHalfClose();
	            }
	        }
	    }
	    handleDataFrame(data) {
	        var _a;
	        if (this.checkCancelled()) {
	            return;
	        }
	        trace('Request to ' +
	            this.handler.path +
	            ' received data frame of size ' +
	            data.length);
	        const rawMessages = this.decoder.write(data);
	        for (const messageBytes of rawMessages) {
	            this.stream.pause();
	            if (this.maxReceiveMessageSize !== -1 &&
	                messageBytes.length - 5 > this.maxReceiveMessageSize) {
	                this.sendStatus({
	                    code: constants_1.Status.RESOURCE_EXHAUSTED,
	                    details: `Received message larger than max (${messageBytes.length - 5} vs. ${this.maxReceiveMessageSize})`,
	                    metadata: null,
	                });
	                return;
	            }
	            const queueEntry = {
	                type: 'COMPRESSED',
	                compressedMessage: messageBytes,
	                parsedMessage: null,
	            };
	            this.readQueue.push(queueEntry);
	            this.decompressAndMaybePush(queueEntry);
	            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageReceived();
	        }
	    }
	    handleEndEvent() {
	        this.readQueue.push({
	            type: 'HALF_CLOSE',
	            compressedMessage: null,
	            parsedMessage: null,
	        });
	        this.receivedHalfClose = true;
	        this.maybePushNextMessage();
	    }
	    start(listener) {
	        trace('Request to ' + this.handler.path + ' start called');
	        if (this.checkCancelled()) {
	            return;
	        }
	        this.listener = listener;
	        listener.onReceiveMetadata(this.metadata);
	    }
	    sendMetadata(metadata) {
	        if (this.checkCancelled()) {
	            return;
	        }
	        if (this.metadataSent) {
	            return;
	        }
	        this.metadataSent = true;
	        const custom = metadata ? metadata.toHttp2Headers() : null;
	        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
	        this.stream.respond(headers, defaultResponseOptions);
	    }
	    sendMessage(message, callback) {
	        if (this.checkCancelled()) {
	            return;
	        }
	        let response;
	        try {
	            response = this.serializeMessage(message);
	        }
	        catch (e) {
	            this.sendStatus({
	                code: constants_1.Status.INTERNAL,
	                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,
	                metadata: null,
	            });
	            return;
	        }
	        if (this.maxSendMessageSize !== -1 &&
	            response.length - 5 > this.maxSendMessageSize) {
	            this.sendStatus({
	                code: constants_1.Status.RESOURCE_EXHAUSTED,
	                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
	                metadata: null,
	            });
	            return;
	        }
	        this.maybeSendMetadata();
	        trace('Request to ' +
	            this.handler.path +
	            ' sent data frame of size ' +
	            response.length);
	        this.stream.write(response, error => {
	            var _a;
	            if (error) {
	                this.sendStatus({
	                    code: constants_1.Status.INTERNAL,
	                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
	                    metadata: null,
	                });
	                return;
	            }
	            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();
	            callback();
	        });
	    }
	    sendStatus(status) {
	        var _a, _b;
	        if (this.checkCancelled()) {
	            return;
	        }
	        trace('Request to method ' +
	            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
	            ' ended with status code: ' +
	            constants_1.Status[status.code] +
	            ' details: ' +
	            status.details);
	        if (this.metadataSent) {
	            if (!this.wantTrailers) {
	                this.wantTrailers = true;
	                this.stream.once('wantTrailers', () => {
	                    var _a;
	                    if (this.callEventTracker && !this.streamEnded) {
	                        this.streamEnded = true;
	                        this.callEventTracker.onStreamEnd(true);
	                        this.callEventTracker.onCallEnd(status);
	                    }
	                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a = status.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());
	                    this.stream.sendTrailers(trailersToSend);
	                    this.notifyOnCancel();
	                });
	                this.stream.end();
	            }
	            else {
	                this.notifyOnCancel();
	            }
	        }
	        else {
	            if (this.callEventTracker && !this.streamEnded) {
	                this.streamEnded = true;
	                this.callEventTracker.onStreamEnd(true);
	                this.callEventTracker.onCallEnd(status);
	            }
	            // Trailers-only response
	            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b = status.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());
	            this.stream.respond(trailersToSend, { endStream: true });
	            this.notifyOnCancel();
	        }
	    }
	    startRead() {
	        trace('Request to ' + this.handler.path + ' startRead called');
	        if (this.checkCancelled()) {
	            return;
	        }
	        this.isReadPending = true;
	        if (this.readQueue.length === 0) {
	            if (!this.receivedHalfClose) {
	                this.stream.resume();
	            }
	        }
	        else {
	            this.maybePushNextMessage();
	        }
	    }
	    getPeer() {
	        var _a;
	        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;
	        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {
	            if (socket.remotePort) {
	                return `${socket.remoteAddress}:${socket.remotePort}`;
	            }
	            else {
	                return socket.remoteAddress;
	            }
	        }
	        else {
	            return 'unknown';
	        }
	    }
	    getDeadline() {
	        return this.deadline;
	    }
	}
	serverInterceptors.BaseServerInterceptingCall = BaseServerInterceptingCall;
	function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
	    const methodDefinition = {
	        path: handler.path,
	        requestStream: handler.type === 'clientStream' || handler.type === 'bidi',
	        responseStream: handler.type === 'serverStream' || handler.type === 'bidi',
	        requestDeserialize: handler.deserialize,
	        responseSerialize: handler.serialize,
	    };
	    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
	    return interceptors.reduce((call, interceptor) => {
	        return interceptor(methodDefinition, call);
	    }, baseCall);
	}
	serverInterceptors.getServerInterceptingCall = getServerInterceptingCall;
	
	return serverInterceptors;
}

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(server, "__esModule", { value: true });
server.Server = void 0;
const http2 = require$$0$5;
const util = require$$2;
const constants_1 = constants;
const server_call_1 = serverCall;
const server_credentials_1 = serverCredentials;
const resolver_1 = resolver;
const logging = logging$8;
const subchannel_address_1 = subchannelAddress;
const uri_parser_1 = uriParser;
const channelz_1 = requireChannelz();
const server_interceptors_1 = requireServerInterceptors();
const UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
const KEEPALIVE_TIMEOUT_MS = 20000;
const MAX_CONNECTION_IDLE_MS = ~(1 << 31);
const { HTTP2_HEADER_PATH } = http2.constants;
const TRACER_NAME = 'server';
const kMaxAge = Buffer.from('max_age');
function noop() { }
/**
 * Decorator to wrap a class method with util.deprecate
 * @param message The message to output if the deprecated method is called
 * @returns
 */
function deprecate(message) {
    return function (target, context) {
        return util.deprecate(target, message);
    };
}
function getUnimplementedStatusResponse(methodName) {
    return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`,
    };
}
function getDefaultHandler(handlerType, methodName) {
    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
    switch (handlerType) {
        case 'unary':
            return (call, callback) => {
                callback(unimplementedStatusResponse, null);
            };
        case 'clientStream':
            return (call, callback) => {
                callback(unimplementedStatusResponse, null);
            };
        case 'serverStream':
            return (call) => {
                call.emit('error', unimplementedStatusResponse);
            };
        case 'bidi':
            return (call) => {
                call.emit('error', unimplementedStatusResponse);
            };
        default:
            throw new Error(`Invalid handlerType ${handlerType}`);
    }
}
let Server = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _start_decorators;
    return _a = class Server {
            constructor(options) {
                var _b, _c, _d, _e, _f, _g;
                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());
                this.http2Servers = new Map();
                this.sessionIdleTimeouts = new Map();
                this.handlers = new Map();
                this.sessions = new Map();
                /**
                 * This field only exists to ensure that the start method throws an error if
                 * it is called twice, as it did previously.
                 */
                this.started = false;
                this.shutdown = false;
                this.serverAddressString = 'null';
                // Channelz Info
                this.channelzEnabled = true;
                this.options = options !== null && options !== void 0 ? options : {};
                if (this.options['grpc.enable_channelz'] === 0) {
                    this.channelzEnabled = false;
                    this.channelzTrace = new channelz_1.ChannelzTraceStub();
                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();
                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
                }
                else {
                    this.channelzTrace = new channelz_1.ChannelzTrace();
                    this.callTracker = new channelz_1.ChannelzCallTracker();
                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
                }
                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);
                this.channelzTrace.addTrace('CT_INFO', 'Server created');
                this.maxConnectionAgeMs =
                    (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;
                this.maxConnectionAgeGraceMs =
                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;
                this.keepaliveTimeMs =
                    (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;
                this.keepaliveTimeoutMs =
                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;
                this.sessionIdleTimeout =
                    (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;
                this.commonServerOptions = {
                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
                };
                if ('grpc-node.max_session_memory' in this.options) {
                    this.commonServerOptions.maxSessionMemory =
                        this.options['grpc-node.max_session_memory'];
                }
                else {
                    /* By default, set a very large max session memory limit, to effectively
                     * disable enforcement of the limit. Some testing indicates that Node's
                     * behavior degrades badly when this limit is reached, so we solve that
                     * by disabling the check entirely. */
                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
                }
                if ('grpc.max_concurrent_streams' in this.options) {
                    this.commonServerOptions.settings = {
                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
                    };
                }
                this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];
                this.trace('Server constructed');
            }
            getChannelzInfo() {
                return {
                    trace: this.channelzTrace,
                    callTracker: this.callTracker,
                    listenerChildren: this.listenerChildrenTracker.getChildLists(),
                    sessionChildren: this.sessionChildrenTracker.getChildLists(),
                };
            }
            getChannelzSessionInfo(session) {
                var _b, _c, _d;
                const sessionInfo = this.sessions.get(session);
                const sessionSocket = session.socket;
                const remoteAddress = sessionSocket.remoteAddress
                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
                    : null;
                const localAddress = sessionSocket.localAddress
                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
                    : null;
                let tlsInfo;
                if (session.encrypted) {
                    const tlsSocket = sessionSocket;
                    const cipherInfo = tlsSocket.getCipher();
                    const certificate = tlsSocket.getCertificate();
                    const peerCertificate = tlsSocket.getPeerCertificate();
                    tlsInfo = {
                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,
                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
                        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
                        remoteCertificate: peerCertificate && 'raw' in peerCertificate
                            ? peerCertificate.raw
                            : null,
                    };
                }
                else {
                    tlsInfo = null;
                }
                const socketInfo = {
                    remoteAddress: remoteAddress,
                    localAddress: localAddress,
                    security: tlsInfo,
                    remoteName: null,
                    streamsStarted: sessionInfo.streamTracker.callsStarted,
                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
                    streamsFailed: sessionInfo.streamTracker.callsFailed,
                    messagesSent: sessionInfo.messagesSent,
                    messagesReceived: sessionInfo.messagesReceived,
                    keepAlivesSent: sessionInfo.keepAlivesSent,
                    lastLocalStreamCreatedTimestamp: null,
                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,
                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null,
                };
                return socketInfo;
            }
            trace(text) {
                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);
            }
            addProtoService() {
                throw new Error('Not implemented. Use addService() instead');
            }
            addService(service, implementation) {
                if (service === null ||
                    typeof service !== 'object' ||
                    implementation === null ||
                    typeof implementation !== 'object') {
                    throw new Error('addService() requires two objects as arguments');
                }
                const serviceKeys = Object.keys(service);
                if (serviceKeys.length === 0) {
                    throw new Error('Cannot add an empty service to a server');
                }
                serviceKeys.forEach(name => {
                    const attrs = service[name];
                    let methodType;
                    if (attrs.requestStream) {
                        if (attrs.responseStream) {
                            methodType = 'bidi';
                        }
                        else {
                            methodType = 'clientStream';
                        }
                    }
                    else {
                        if (attrs.responseStream) {
                            methodType = 'serverStream';
                        }
                        else {
                            methodType = 'unary';
                        }
                    }
                    let implFn = implementation[name];
                    let impl;
                    if (implFn === undefined && typeof attrs.originalName === 'string') {
                        implFn = implementation[attrs.originalName];
                    }
                    if (implFn !== undefined) {
                        impl = implFn.bind(implementation);
                    }
                    else {
                        impl = getDefaultHandler(methodType, name);
                    }
                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
                    if (success === false) {
                        throw new Error(`Method handler for ${attrs.path} already provided.`);
                    }
                });
            }
            removeService(service) {
                if (service === null || typeof service !== 'object') {
                    throw new Error('removeService() requires object as argument');
                }
                const serviceKeys = Object.keys(service);
                serviceKeys.forEach(name => {
                    const attrs = service[name];
                    this.unregister(attrs.path);
                });
            }
            bind(port, creds) {
                throw new Error('Not implemented. Use bindAsync() instead');
            }
            registerListenerToChannelz(boundAddress) {
                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
                    return {
                        localAddress: boundAddress,
                        remoteAddress: null,
                        security: null,
                        remoteName: null,
                        streamsStarted: 0,
                        streamsSucceeded: 0,
                        streamsFailed: 0,
                        messagesSent: 0,
                        messagesReceived: 0,
                        keepAlivesSent: 0,
                        lastLocalStreamCreatedTimestamp: null,
                        lastRemoteStreamCreatedTimestamp: null,
                        lastMessageSentTimestamp: null,
                        lastMessageReceivedTimestamp: null,
                        localFlowControlWindow: null,
                        remoteFlowControlWindow: null,
                    };
                }, this.channelzEnabled);
            }
            createHttp2Server(credentials) {
                let http2Server;
                if (credentials._isSecure()) {
                    const secureServerOptions = Object.assign(this.commonServerOptions, credentials._getSettings());
                    secureServerOptions.enableTrace =
                        this.options['grpc-node.tls_enable_trace'] === 1;
                    http2Server = http2.createSecureServer(secureServerOptions);
                    http2Server.on('secureConnection', (socket) => {
                        /* These errors need to be handled by the user of Http2SecureServer,
                         * according to https://github.com/nodejs/node/issues/35824 */
                        socket.on('error', (e) => {
                            this.trace('An incoming TLS connection closed with error: ' + e.message);
                        });
                    });
                }
                else {
                    http2Server = http2.createServer(this.commonServerOptions);
                }
                http2Server.setTimeout(0, noop);
                this._setupHandlers(http2Server);
                return http2Server;
            }
            bindOneAddress(address, boundPortObject) {
                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));
                const http2Server = this.createHttp2Server(boundPortObject.credentials);
                return new Promise((resolve, reject) => {
                    const onError = (err) => {
                        this.trace('Failed to bind ' +
                            (0, subchannel_address_1.subchannelAddressToString)(address) +
                            ' with error ' +
                            err.message);
                        resolve({
                            port: 'port' in address ? address.port : 1,
                            error: err.message,
                        });
                    };
                    http2Server.once('error', onError);
                    http2Server.listen(address, () => {
                        const boundAddress = http2Server.address();
                        let boundSubchannelAddress;
                        if (typeof boundAddress === 'string') {
                            boundSubchannelAddress = {
                                path: boundAddress,
                            };
                        }
                        else {
                            boundSubchannelAddress = {
                                host: boundAddress.address,
                                port: boundAddress.port,
                            };
                        }
                        const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);
                        this.listenerChildrenTracker.refChild(channelzRef);
                        this.http2Servers.set(http2Server, {
                            channelzRef: channelzRef,
                            sessions: new Set(),
                        });
                        boundPortObject.listeningServers.add(http2Server);
                        this.trace('Successfully bound ' +
                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
                        resolve({
                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,
                        });
                        http2Server.removeListener('error', onError);
                    });
                });
            }
            async bindManyPorts(addressList, boundPortObject) {
                if (addressList.length === 0) {
                    return {
                        count: 0,
                        port: 0,
                        errors: [],
                    };
                }
                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
                    /* If binding to port 0, first try to bind the first address, then bind
                     * the rest of the address list to the specific port that it binds. */
                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
                    if (firstAddressResult.error) {
                        /* If the first address fails to bind, try the same operation starting
                         * from the second item in the list. */
                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });
                    }
                    else {
                        const restAddresses = addressList
                            .slice(1)
                            .map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address)
                            ? { host: address.host, port: firstAddressResult.port }
                            : address);
                        const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));
                        const allResults = [firstAddressResult, ...restAddressResult];
                        return {
                            count: allResults.filter(result => result.error === undefined).length,
                            port: firstAddressResult.port,
                            errors: allResults
                                .filter(result => result.error)
                                .map(result => result.error),
                        };
                    }
                }
                else {
                    const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));
                    return {
                        count: allResults.filter(result => result.error === undefined).length,
                        port: allResults[0].port,
                        errors: allResults
                            .filter(result => result.error)
                            .map(result => result.error),
                    };
                }
            }
            async bindAddressList(addressList, boundPortObject) {
                const bindResult = await this.bindManyPorts(addressList, boundPortObject);
                if (bindResult.count > 0) {
                    if (bindResult.count < addressList.length) {
                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                    }
                    return bindResult.port;
                }
                else {
                    const errorString = `No address added out of total ${addressList.length} resolved`;
                    logging.log(constants_1.LogVerbosity.ERROR, errorString);
                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);
                }
            }
            resolvePort(port) {
                return new Promise((resolve, reject) => {
                    const resolverListener = {
                        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {
                            // We only want one resolution result. Discard all future results
                            resolverListener.onSuccessfulResolution = () => { };
                            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
                            if (addressList.length === 0) {
                                reject(new Error(`No addresses resolved for port ${port}`));
                                return;
                            }
                            resolve(addressList);
                        },
                        onError: error => {
                            reject(new Error(error.details));
                        },
                    };
                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
                    resolver.updateResolution();
                });
            }
            async bindPort(port, boundPortObject) {
                const addressList = await this.resolvePort(port);
                if (boundPortObject.cancelled) {
                    this.completeUnbind(boundPortObject);
                    throw new Error('bindAsync operation cancelled by unbind call');
                }
                const portNumber = await this.bindAddressList(addressList, boundPortObject);
                if (boundPortObject.cancelled) {
                    this.completeUnbind(boundPortObject);
                    throw new Error('bindAsync operation cancelled by unbind call');
                }
                return portNumber;
            }
            normalizePort(port) {
                const initialPortUri = (0, uri_parser_1.parseUri)(port);
                if (initialPortUri === null) {
                    throw new Error(`Could not parse port "${port}"`);
                }
                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
                if (portUri === null) {
                    throw new Error(`Could not get a default scheme for port "${port}"`);
                }
                return portUri;
            }
            bindAsync(port, creds, callback) {
                if (this.shutdown) {
                    throw new Error('bindAsync called after shutdown');
                }
                if (typeof port !== 'string') {
                    throw new TypeError('port must be a string');
                }
                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
                    throw new TypeError('creds must be a ServerCredentials object');
                }
                if (typeof callback !== 'function') {
                    throw new TypeError('callback must be a function');
                }
                this.trace('bindAsync port=' + port);
                const portUri = this.normalizePort(port);
                const deferredCallback = (error, port) => {
                    process.nextTick(() => callback(error, port));
                };
                /* First, if this port is already bound or that bind operation is in
                 * progress, use that result. */
                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
                if (boundPortObject) {
                    if (!creds._equals(boundPortObject.credentials)) {
                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
                        return;
                    }
                    /* If that operation has previously been cancelled by an unbind call,
                     * uncancel it. */
                    boundPortObject.cancelled = false;
                    if (boundPortObject.completionPromise) {
                        boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));
                    }
                    else {
                        deferredCallback(null, boundPortObject.portNumber);
                    }
                    return;
                }
                boundPortObject = {
                    mapKey: (0, uri_parser_1.uriToString)(portUri),
                    originalUri: portUri,
                    completionPromise: null,
                    cancelled: false,
                    portNumber: 0,
                    credentials: creds,
                    listeningServers: new Set(),
                };
                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
                const completionPromise = this.bindPort(portUri, boundPortObject);
                boundPortObject.completionPromise = completionPromise;
                /* If the port number is 0, defer populating the map entry until after the
                 * bind operation completes and we have a specific port number. Otherwise,
                 * populate it immediately. */
                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
                    completionPromise.then(portNum => {
                        const finalUri = {
                            scheme: portUri.scheme,
                            authority: portUri.authority,
                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),
                        };
                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
                        boundPortObject.completionPromise = null;
                        boundPortObject.portNumber = portNum;
                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
                        callback(null, portNum);
                    }, error => {
                        callback(error, 0);
                    });
                }
                else {
                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
                    completionPromise.then(portNum => {
                        boundPortObject.completionPromise = null;
                        boundPortObject.portNumber = portNum;
                        callback(null, portNum);
                    }, error => {
                        callback(error, 0);
                    });
                }
            }
            closeServer(server, callback) {
                this.trace('Closing server with address ' + JSON.stringify(server.address()));
                const serverInfo = this.http2Servers.get(server);
                server.close(() => {
                    if (serverInfo) {
                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
                    }
                    this.http2Servers.delete(server);
                    callback === null || callback === void 0 ? void 0 : callback();
                });
            }
            closeSession(session, callback) {
                var _b;
                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));
                const sessionInfo = this.sessions.get(session);
                const closeCallback = () => {
                    if (sessionInfo) {
                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
                    }
                    callback === null || callback === void 0 ? void 0 : callback();
                };
                if (session.closed) {
                    queueMicrotask(closeCallback);
                }
                else {
                    session.close(closeCallback);
                }
            }
            completeUnbind(boundPortObject) {
                for (const server of boundPortObject.listeningServers) {
                    const serverInfo = this.http2Servers.get(server);
                    this.closeServer(server, () => {
                        boundPortObject.listeningServers.delete(server);
                    });
                    if (serverInfo) {
                        for (const session of serverInfo.sessions) {
                            this.closeSession(session);
                        }
                    }
                }
                this.boundPorts.delete(boundPortObject.mapKey);
            }
            /**
             * Unbind a previously bound port, or cancel an in-progress bindAsync
             * operation. If port 0 was bound, only the actual bound port can be
             * unbound. For example, if bindAsync was called with "localhost:0" and the
             * bound port result was 54321, it can be unbound as "localhost:54321".
             * @param port
             */
            unbind(port) {
                this.trace('unbind port=' + port);
                const portUri = this.normalizePort(port);
                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
                    throw new Error('Cannot unbind port 0');
                }
                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
                if (boundPortObject) {
                    this.trace('unbinding ' +
                        boundPortObject.mapKey +
                        ' originally bound as ' +
                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
                    /* If the bind operation is pending, the cancelled flag will trigger
                     * the unbind operation later. */
                    if (boundPortObject.completionPromise) {
                        boundPortObject.cancelled = true;
                    }
                    else {
                        this.completeUnbind(boundPortObject);
                    }
                }
            }
            /**
             * Gracefully close all connections associated with a previously bound port.
             * After the grace time, forcefully close all remaining open connections.
             *
             * If port 0 was bound, only the actual bound port can be
             * drained. For example, if bindAsync was called with "localhost:0" and the
             * bound port result was 54321, it can be drained as "localhost:54321".
             * @param port
             * @param graceTimeMs
             * @returns
             */
            drain(port, graceTimeMs) {
                var _b, _c;
                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);
                const portUri = this.normalizePort(port);
                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
                    throw new Error('Cannot drain port 0');
                }
                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
                if (!boundPortObject) {
                    return;
                }
                const allSessions = new Set();
                for (const http2Server of boundPortObject.listeningServers) {
                    const serverEntry = this.http2Servers.get(http2Server);
                    if (serverEntry) {
                        for (const session of serverEntry.sessions) {
                            allSessions.add(session);
                            this.closeSession(session, () => {
                                allSessions.delete(session);
                            });
                        }
                    }
                }
                /* After the grace time ends, send another goaway to all remaining sessions
                 * with the CANCEL code. */
                (_c = (_b = setTimeout(() => {
                    for (const session of allSessions) {
                        session.destroy(http2.constants.NGHTTP2_CANCEL);
                    }
                }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
            }
            forceShutdown() {
                for (const boundPortObject of this.boundPorts.values()) {
                    boundPortObject.cancelled = true;
                }
                this.boundPorts.clear();
                // Close the server if it is still running.
                for (const server of this.http2Servers.keys()) {
                    this.closeServer(server);
                }
                // Always destroy any available sessions. It's possible that one or more
                // tryShutdown() calls are in progress. Don't wait on them to finish.
                this.sessions.forEach((channelzInfo, session) => {
                    this.closeSession(session);
                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
                    // recognize destroy(code) as a valid signature.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    session.destroy(http2.constants.NGHTTP2_CANCEL);
                });
                this.sessions.clear();
                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
                this.shutdown = true;
            }
            register(name, handler, serialize, deserialize, type) {
                if (this.handlers.has(name)) {
                    return false;
                }
                this.handlers.set(name, {
                    func: handler,
                    serialize,
                    deserialize,
                    type,
                    path: name,
                });
                return true;
            }
            unregister(name) {
                return this.handlers.delete(name);
            }
            /**
             * @deprecated No longer needed as of version 1.10.x
             */
            start() {
                if (this.http2Servers.size === 0 ||
                    [...this.http2Servers.keys()].every(server => !server.listening)) {
                    throw new Error('server must be bound in order to start');
                }
                if (this.started === true) {
                    throw new Error('server is already started');
                }
                this.started = true;
            }
            tryShutdown(callback) {
                var _b;
                const wrappedCallback = (error) => {
                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
                    callback(error);
                };
                let pendingChecks = 0;
                function maybeCallback() {
                    pendingChecks--;
                    if (pendingChecks === 0) {
                        wrappedCallback();
                    }
                }
                this.shutdown = true;
                for (const [serverKey, server] of this.http2Servers.entries()) {
                    pendingChecks++;
                    const serverString = server.channelzRef.name;
                    this.trace('Waiting for server ' + serverString + ' to close');
                    this.closeServer(serverKey, () => {
                        this.trace('Server ' + serverString + ' finished closing');
                        maybeCallback();
                    });
                    for (const session of server.sessions.keys()) {
                        pendingChecks++;
                        const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;
                        this.trace('Waiting for session ' + sessionString + ' to close');
                        this.closeSession(session, () => {
                            this.trace('Session ' + sessionString + ' finished closing');
                            maybeCallback();
                        });
                    }
                }
                if (pendingChecks === 0) {
                    wrappedCallback();
                }
            }
            addHttp2Port() {
                throw new Error('Not yet implemented');
            }
            /**
             * Get the channelz reference object for this server. The returned value is
             * garbage if channelz is disabled for this server.
             * @returns
             */
            getChannelzRef() {
                return this.channelzRef;
            }
            _verifyContentType(stream, headers) {
                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
                if (typeof contentType !== 'string' ||
                    !contentType.startsWith('application/grpc')) {
                    stream.respond({
                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
                    }, { endStream: true });
                    return false;
                }
                return true;
            }
            _retrieveHandler(path) {
                this.trace('Received call to method ' +
                    path +
                    ' at address ' +
                    this.serverAddressString);
                const handler = this.handlers.get(path);
                if (handler === undefined) {
                    this.trace('No handler registered for method ' +
                        path +
                        '. Sending UNIMPLEMENTED status.');
                    return null;
                }
                return handler;
            }
            _respondWithError(err, stream, channelzSessionInfo = null) {
                var _b, _c;
                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());
                stream.respond(trailersToSend, { endStream: true });
                this.callTracker.addCallFailed();
                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            }
            _channelzHandler(stream, headers) {
                // for handling idle timeout
                this.onStreamOpened(stream);
                const channelzSessionInfo = this.sessions.get(stream.session);
                this.callTracker.addCallStarted();
                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
                if (!this._verifyContentType(stream, headers)) {
                    this.callTracker.addCallFailed();
                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
                    return;
                }
                const path = headers[HTTP2_HEADER_PATH];
                const handler = this._retrieveHandler(path);
                if (!handler) {
                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);
                    return;
                }
                const callEventTracker = {
                    addMessageSent: () => {
                        if (channelzSessionInfo) {
                            channelzSessionInfo.messagesSent += 1;
                            channelzSessionInfo.lastMessageSentTimestamp = new Date();
                        }
                    },
                    addMessageReceived: () => {
                        if (channelzSessionInfo) {
                            channelzSessionInfo.messagesReceived += 1;
                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
                        }
                    },
                    onCallEnd: status => {
                        if (status.code === constants_1.Status.OK) {
                            this.callTracker.addCallSucceeded();
                        }
                        else {
                            this.callTracker.addCallFailed();
                        }
                    },
                    onStreamEnd: success => {
                        if (channelzSessionInfo) {
                            if (success) {
                                channelzSessionInfo.streamTracker.addCallSucceeded();
                            }
                            else {
                                channelzSessionInfo.streamTracker.addCallFailed();
                            }
                        }
                    },
                };
                const call = (0, server_interceptors_1.getServerInterceptingCall)(this.interceptors, stream, headers, callEventTracker, handler, this.options);
                if (!this._runHandlerForCall(call, handler)) {
                    this.callTracker.addCallFailed();
                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
                    call.sendStatus({
                        code: constants_1.Status.INTERNAL,
                        details: `Unknown handler type: ${handler.type}`,
                    });
                }
            }
            _streamHandler(stream, headers) {
                // for handling idle timeout
                this.onStreamOpened(stream);
                if (this._verifyContentType(stream, headers) !== true) {
                    return;
                }
                const path = headers[HTTP2_HEADER_PATH];
                const handler = this._retrieveHandler(path);
                if (!handler) {
                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);
                    return;
                }
                const call = (0, server_interceptors_1.getServerInterceptingCall)(this.interceptors, stream, headers, null, handler, this.options);
                if (!this._runHandlerForCall(call, handler)) {
                    call.sendStatus({
                        code: constants_1.Status.INTERNAL,
                        details: `Unknown handler type: ${handler.type}`,
                    });
                }
            }
            _runHandlerForCall(call, handler) {
                const { type } = handler;
                if (type === 'unary') {
                    handleUnary(call, handler);
                }
                else if (type === 'clientStream') {
                    handleClientStreaming(call, handler);
                }
                else if (type === 'serverStream') {
                    handleServerStreaming(call, handler);
                }
                else if (type === 'bidi') {
                    handleBidiStreaming(call, handler);
                }
                else {
                    return false;
                }
                return true;
            }
            _setupHandlers(http2Server) {
                if (http2Server === null) {
                    return;
                }
                const serverAddress = http2Server.address();
                let serverAddressString = 'null';
                if (serverAddress) {
                    if (typeof serverAddress === 'string') {
                        serverAddressString = serverAddress;
                    }
                    else {
                        serverAddressString = serverAddress.address + ':' + serverAddress.port;
                    }
                }
                this.serverAddressString = serverAddressString;
                const handler = this.channelzEnabled
                    ? this._channelzHandler
                    : this._streamHandler;
                const sessionHandler = this.channelzEnabled
                    ? this._channelzSessionHandler(http2Server)
                    : this._sessionHandler(http2Server);
                http2Server.on('stream', handler.bind(this));
                http2Server.on('session', sessionHandler);
            }
            _sessionHandler(http2Server) {
                return (session) => {
                    var _b, _c, _d;
                    (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);
                    let connectionAgeTimer = null;
                    let connectionAgeGraceTimer = null;
                    let keeapliveTimeTimer = null;
                    let keepaliveTimeoutTimer = null;
                    let sessionClosedByServer = false;
                    const idleTimeoutObj = this.enableIdleTimeout(session);
                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
                        // Apply a random jitter within a +/-10% range
                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
                        connectionAgeTimer = setTimeout(() => {
                            var _b, _c;
                            sessionClosedByServer = true;
                            this.trace('Connection dropped by max connection age: ' +
                                ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));
                            try {
                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                            }
                            catch (e) {
                                // The goaway can't be sent because the session is already closed
                                session.destroy();
                                return;
                            }
                            session.close();
                            /* Allow a grace period after sending the GOAWAY before forcibly
                             * closing the connection. */
                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                                connectionAgeGraceTimer = setTimeout(() => {
                                    session.destroy();
                                }, this.maxConnectionAgeGraceMs);
                                (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);
                            }
                        }, this.maxConnectionAgeMs + jitter);
                        (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);
                    }
                    if (this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS) {
                        keeapliveTimeTimer = setInterval(() => {
                            var _b;
                            keepaliveTimeoutTimer = setTimeout(() => {
                                sessionClosedByServer = true;
                                session.close();
                            }, this.keepaliveTimeoutMs);
                            (_b = keepaliveTimeoutTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeoutTimer);
                            try {
                                session.ping((err, duration, payload) => {
                                    if (keepaliveTimeoutTimer) {
                                        clearTimeout(keepaliveTimeoutTimer);
                                    }
                                    if (err) {
                                        sessionClosedByServer = true;
                                        this.trace('Connection dropped due to error of a ping frame ' +
                                            err.message +
                                            ' return in ' +
                                            duration);
                                        session.close();
                                    }
                                });
                            }
                            catch (e) {
                                clearTimeout(keepaliveTimeoutTimer);
                                // The ping can't be sent because the session is already closed
                                session.destroy();
                            }
                        }, this.keepaliveTimeMs);
                        (_d = keeapliveTimeTimer.unref) === null || _d === void 0 ? void 0 : _d.call(keeapliveTimeTimer);
                    }
                    session.on('close', () => {
                        var _b, _c;
                        if (!sessionClosedByServer) {
                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);
                        }
                        if (connectionAgeTimer) {
                            clearTimeout(connectionAgeTimer);
                        }
                        if (connectionAgeGraceTimer) {
                            clearTimeout(connectionAgeGraceTimer);
                        }
                        if (keeapliveTimeTimer) {
                            clearInterval(keeapliveTimeTimer);
                            if (keepaliveTimeoutTimer) {
                                clearTimeout(keepaliveTimeoutTimer);
                            }
                        }
                        if (idleTimeoutObj !== null) {
                            clearTimeout(idleTimeoutObj.timeout);
                            this.sessionIdleTimeouts.delete(session);
                        }
                        (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);
                    });
                };
            }
            _channelzSessionHandler(http2Server) {
                return (session) => {
                    var _b, _c, _d, _e, _f;
                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
                    const channelzSessionInfo = {
                        ref: channelzRef,
                        streamTracker: new channelz_1.ChannelzCallTracker(),
                        messagesSent: 0,
                        messagesReceived: 0,
                        keepAlivesSent: 0,
                        lastMessageSentTimestamp: null,
                        lastMessageReceivedTimestamp: null,
                    };
                    (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);
                    this.sessions.set(session, channelzSessionInfo);
                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);
                    this.trace('Connection established by client ' + clientAddress);
                    this.sessionChildrenTracker.refChild(channelzRef);
                    let connectionAgeTimer = null;
                    let connectionAgeGraceTimer = null;
                    let keeapliveTimeTimer = null;
                    let keepaliveTimeoutTimer = null;
                    let sessionClosedByServer = false;
                    const idleTimeoutObj = this.enableIdleTimeout(session);
                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
                        // Apply a random jitter within a +/-10% range
                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
                        connectionAgeTimer = setTimeout(() => {
                            var _b;
                            sessionClosedByServer = true;
                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);
                            try {
                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                            }
                            catch (e) {
                                // The goaway can't be sent because the session is already closed
                                session.destroy();
                                return;
                            }
                            session.close();
                            /* Allow a grace period after sending the GOAWAY before forcibly
                             * closing the connection. */
                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                                connectionAgeGraceTimer = setTimeout(() => {
                                    session.destroy();
                                }, this.maxConnectionAgeGraceMs);
                                (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);
                            }
                        }, this.maxConnectionAgeMs + jitter);
                        (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);
                    }
                    if (this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS) {
                        keeapliveTimeTimer = setInterval(() => {
                            var _b;
                            keepaliveTimeoutTimer = setTimeout(() => {
                                sessionClosedByServer = true;
                                this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);
                                session.close();
                            }, this.keepaliveTimeoutMs);
                            (_b = keepaliveTimeoutTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeoutTimer);
                            try {
                                session.ping((err, duration, payload) => {
                                    if (keepaliveTimeoutTimer) {
                                        clearTimeout(keepaliveTimeoutTimer);
                                    }
                                    if (err) {
                                        sessionClosedByServer = true;
                                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +
                                            err.message +
                                            ' return in ' +
                                            duration);
                                        session.close();
                                    }
                                });
                                channelzSessionInfo.keepAlivesSent += 1;
                            }
                            catch (e) {
                                clearTimeout(keepaliveTimeoutTimer);
                                // The ping can't be sent because the session is already closed
                                session.destroy();
                            }
                        }, this.keepaliveTimeMs);
                        (_f = keeapliveTimeTimer.unref) === null || _f === void 0 ? void 0 : _f.call(keeapliveTimeTimer);
                    }
                    session.on('close', () => {
                        var _b;
                        if (!sessionClosedByServer) {
                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);
                        }
                        this.sessionChildrenTracker.unrefChild(channelzRef);
                        (0, channelz_1.unregisterChannelzRef)(channelzRef);
                        if (connectionAgeTimer) {
                            clearTimeout(connectionAgeTimer);
                        }
                        if (connectionAgeGraceTimer) {
                            clearTimeout(connectionAgeGraceTimer);
                        }
                        if (keeapliveTimeTimer) {
                            clearInterval(keeapliveTimeTimer);
                            if (keepaliveTimeoutTimer) {
                                clearTimeout(keepaliveTimeoutTimer);
                            }
                        }
                        if (idleTimeoutObj !== null) {
                            clearTimeout(idleTimeoutObj.timeout);
                            this.sessionIdleTimeouts.delete(session);
                        }
                        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);
                        this.sessions.delete(session);
                    });
                };
            }
            enableIdleTimeout(session) {
                var _b, _c;
                if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
                    return null;
                }
                const idleTimeoutObj = {
                    activeStreams: 0,
                    lastIdle: Date.now(),
                    onClose: this.onStreamClose.bind(this, session),
                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),
                };
                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
                this.sessionIdleTimeouts.set(session, idleTimeoutObj);
                const { socket } = session;
                this.trace('Enable idle timeout for ' +
                    socket.remoteAddress +
                    ':' +
                    socket.remotePort);
                return idleTimeoutObj;
            }
            onIdleTimeout(ctx, session) {
                const { socket } = session;
                const sessionInfo = ctx.sessionIdleTimeouts.get(session);
                // if it is called while we have activeStreams - timer will not be rescheduled
                // until last active stream is closed, then it will call .refresh() on the timer
                // important part is to not clearTimeout(timer) or it becomes unusable
                // for future refreshes
                if (sessionInfo !== undefined &&
                    sessionInfo.activeStreams === 0 &&
                    Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
                    ctx.trace('Session idle timeout triggered for ' +
                        (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) +
                        ':' +
                        (socket === null || socket === void 0 ? void 0 : socket.remotePort) +
                        ' last idle at ' +
                        sessionInfo.lastIdle);
                    ctx.closeSession(session);
                }
            }
            onStreamOpened(stream) {
                const session = stream.session;
                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
                if (idleTimeoutObj) {
                    idleTimeoutObj.activeStreams += 1;
                    stream.once('close', idleTimeoutObj.onClose);
                }
            }
            onStreamClose(session) {
                var _b, _c;
                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
                if (idleTimeoutObj) {
                    idleTimeoutObj.activeStreams -= 1;
                    if (idleTimeoutObj.activeStreams === 0) {
                        idleTimeoutObj.lastIdle = Date.now();
                        idleTimeoutObj.timeout.refresh();
                        this.trace('Session onStreamClose' +
                            ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) +
                            ':' +
                            ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) +
                            ' at ' +
                            idleTimeoutObj.lastIdle);
                    }
                }
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];
            __esDecorate(_a, null, _start_decorators, { kind: "method", name: "start", static: false, private: false, access: { has: obj => "start" in obj, get: obj => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
server.Server = Server;
async function handleUnary(call, handler) {
    let stream;
    function respond(err, value, trailer, flags) {
        if (err) {
            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
            return;
        }
        call.sendMessage(value, () => {
            call.sendStatus({
                code: constants_1.Status.OK,
                details: 'OK',
                metadata: trailer !== null && trailer !== void 0 ? trailer : null,
            });
        });
    }
    let requestMetadata;
    let requestMessage = null;
    call.start({
        onReceiveMetadata(metadata) {
            requestMetadata = metadata;
            call.startRead();
        },
        onReceiveMessage(message) {
            if (requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received a second request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            requestMessage = message;
            call.startRead();
        },
        onReceiveHalfClose() {
            if (!requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received no request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
            try {
                handler.func(stream, respond);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
            }
        },
    });
}
function handleClientStreaming(call, handler) {
    let stream;
    function respond(err, value, trailer, flags) {
        if (err) {
            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
            return;
        }
        call.sendMessage(value, () => {
            call.sendStatus({
                code: constants_1.Status.OK,
                details: 'OK',
                metadata: trailer !== null && trailer !== void 0 ? trailer : null,
            });
        });
    }
    call.start({
        onReceiveMetadata(metadata) {
            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
            try {
                handler.func(stream, respond);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onReceiveMessage(message) {
            stream.push(message);
        },
        onReceiveHalfClose() {
            stream.push(null);
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
                stream.destroy();
            }
        },
    });
}
function handleServerStreaming(call, handler) {
    let stream;
    let requestMetadata;
    let requestMessage = null;
    call.start({
        onReceiveMetadata(metadata) {
            requestMetadata = metadata;
            call.startRead();
        },
        onReceiveMessage(message) {
            if (requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received a second request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            requestMessage = message;
            call.startRead();
        },
        onReceiveHalfClose() {
            if (!requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received no request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
            try {
                handler.func(stream);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
                stream.destroy();
            }
        },
    });
}
function handleBidiStreaming(call, handler) {
    let stream;
    call.start({
        onReceiveMetadata(metadata) {
            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
            try {
                handler.func(stream);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onReceiveMessage(message) {
            stream.push(message);
        },
        onReceiveHalfClose() {
            stream.push(null);
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
                stream.destroy();
            }
        },
    });
}

var statusBuilder = {};

/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(statusBuilder, "__esModule", { value: true });
statusBuilder.StatusBuilder = void 0;
/**
 * A builder for gRPC status objects.
 */
class StatusBuilder {
    constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
    }
    /**
     * Adds a status code to the builder.
     */
    withCode(code) {
        this.code = code;
        return this;
    }
    /**
     * Adds details to the builder.
     */
    withDetails(details) {
        this.details = details;
        return this;
    }
    /**
     * Adds metadata to the builder.
     */
    withMetadata(metadata) {
        this.metadata = metadata;
        return this;
    }
    /**
     * Builds the status object.
     */
    build() {
        const status = {};
        if (this.code !== null) {
            status.code = this.code;
        }
        if (this.details !== null) {
            status.details = this.details;
        }
        if (this.metadata !== null) {
            status.metadata = this.metadata;
        }
        return status;
    }
}
statusBuilder.StatusBuilder = StatusBuilder;

var experimental = {};

var duration = {};

var hasRequiredDuration;

function requireDuration () {
	if (hasRequiredDuration) return duration;
	hasRequiredDuration = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(duration, "__esModule", { value: true });
	duration.isDuration = duration.durationToMs = duration.msToDuration = void 0;
	function msToDuration(millis) {
	    return {
	        seconds: (millis / 1000) | 0,
	        nanos: ((millis % 1000) * 1000000) | 0,
	    };
	}
	duration.msToDuration = msToDuration;
	function durationToMs(duration) {
	    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;
	}
	duration.durationToMs = durationToMs;
	function isDuration(value) {
	    return typeof value.seconds === 'number' && typeof value.nanos === 'number';
	}
	duration.isDuration = isDuration;
	
	return duration;
}

var loadBalancerPickFirst = {};

var hasRequiredLoadBalancerPickFirst;

function requireLoadBalancerPickFirst () {
	if (hasRequiredLoadBalancerPickFirst) return loadBalancerPickFirst;
	hasRequiredLoadBalancerPickFirst = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerPickFirst, "__esModule", { value: true });
	loadBalancerPickFirst.setup = loadBalancerPickFirst.LeafLoadBalancer = loadBalancerPickFirst.PickFirstLoadBalancer = loadBalancerPickFirst.shuffled = loadBalancerPickFirst.PickFirstLoadBalancingConfig = void 0;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = connectivityState;
	const picker_1 = requirePicker();
	const logging = logging$8;
	const constants_1 = constants;
	const subchannel_address_1 = subchannelAddress;
	const net_1 = require$$0$3;
	const TRACER_NAME = 'pick_first';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'pick_first';
	/**
	 * Delay after starting a connection on a subchannel before starting a
	 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
	 */
	const CONNECTION_DELAY_INTERVAL_MS = 250;
	class PickFirstLoadBalancingConfig {
	    constructor(shuffleAddressList) {
	        this.shuffleAddressList = shuffleAddressList;
	    }
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    toJsonObject() {
	        return {
	            [TYPE_NAME]: {
	                shuffleAddressList: this.shuffleAddressList,
	            },
	        };
	    }
	    getShuffleAddressList() {
	        return this.shuffleAddressList;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    static createFromJson(obj) {
	        if ('shuffleAddressList' in obj &&
	            !(typeof obj.shuffleAddressList === 'boolean')) {
	            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');
	        }
	        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
	    }
	}
	loadBalancerPickFirst.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
	/**
	 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
	 * picked subchannel.
	 */
	class PickFirstPicker {
	    constructor(subchannel) {
	        this.subchannel = subchannel;
	    }
	    pick(pickArgs) {
	        return {
	            pickResultType: picker_1.PickResultType.COMPLETE,
	            subchannel: this.subchannel,
	            status: null,
	            onCallStarted: null,
	            onCallEnded: null,
	        };
	    }
	}
	/**
	 * Return a new array with the elements of the input array in a random order
	 * @param list The input array
	 * @returns A shuffled array of the elements of list
	 */
	function shuffled(list) {
	    const result = list.slice();
	    for (let i = result.length - 1; i > 1; i--) {
	        const j = Math.floor(Math.random() * (i + 1));
	        const temp = result[i];
	        result[i] = result[j];
	        result[j] = temp;
	    }
	    return result;
	}
	loadBalancerPickFirst.shuffled = shuffled;
	/**
	 * Interleave addresses in addressList by family in accordance with RFC-8304 section 4
	 * @param addressList
	 * @returns
	 */
	function interleaveAddressFamilies(addressList) {
	    const result = [];
	    const ipv6Addresses = [];
	    const ipv4Addresses = [];
	    const ipv6First = (0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
	    for (const address of addressList) {
	        if ((0, subchannel_address_1.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
	            ipv6Addresses.push(address);
	        }
	        else {
	            ipv4Addresses.push(address);
	        }
	    }
	    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
	    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
	    for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {
	        if (i < firstList.length) {
	            result.push(firstList[i]);
	        }
	        if (i < secondList.length) {
	            result.push(secondList[i]);
	        }
	    }
	    return result;
	}
	const REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';
	class PickFirstLoadBalancer {
	    /**
	     * Load balancer that attempts to connect to each backend in the address list
	     * in order, and picks the first one that connects, using it for every
	     * request.
	     * @param channelControlHelper `ChannelControlHelper` instance provided by
	     *     this load balancer's owner.
	     */
	    constructor(channelControlHelper, options) {
	        this.channelControlHelper = channelControlHelper;
	        /**
	         * The list of subchannels this load balancer is currently attempting to
	         * connect to.
	         */
	        this.children = [];
	        /**
	         * The current connectivity state of the load balancer.
	         */
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The index within the `subchannels` array of the subchannel with the most
	         * recently started connection attempt.
	         */
	        this.currentSubchannelIndex = 0;
	        /**
	         * The currently picked subchannel used for making calls. Populated if
	         * and only if the load balancer's current state is READY. In that case,
	         * the subchannel's current state is also READY.
	         */
	        this.currentPick = null;
	        /**
	         * Listener callback attached to each subchannel in the `subchannels` list
	         * while establishing a connection.
	         */
	        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
	            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
	        };
	        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
	        this.triedAllSubchannels = false;
	        /**
	         * The LB policy enters sticky TRANSIENT_FAILURE mode when all
	         * subchannels have failed to connect at least once, and it stays in that
	         * mode until a connection attempt is successful. While in sticky TF mode,
	         * the LB policy continuously attempts to connect to all of its subchannels.
	         */
	        this.stickyTransientFailureMode = false;
	        /**
	         * Indicates whether we called channelControlHelper.requestReresolution since
	         * the last call to updateAddressList
	         */
	        this.requestedResolutionSinceLastUpdate = false;
	        /**
	         * The most recent error reported by any subchannel as it transitioned to
	         * TRANSIENT_FAILURE.
	         */
	        this.lastError = null;
	        this.latestAddressList = null;
	        this.connectionDelayTimeout = setTimeout(() => { }, 0);
	        clearTimeout(this.connectionDelayTimeout);
	        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
	    }
	    allChildrenHaveReportedTF() {
	        return this.children.every(child => child.hasReportedTransientFailure);
	    }
	    calculateAndReportNewState() {
	        if (this.currentPick) {
	            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
	                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                    details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`,
	                }));
	            }
	            else {
	                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));
	            }
	        }
	        else if (this.children.length === 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        }
	        else {
	            if (this.stickyTransientFailureMode) {
	                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                    details: `No connection established. Last error: ${this.lastError}`,
	                }));
	            }
	            else {
	                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
	            }
	        }
	    }
	    requestReresolution() {
	        this.requestedResolutionSinceLastUpdate = true;
	        this.channelControlHelper.requestReresolution();
	    }
	    maybeEnterStickyTransientFailureMode() {
	        if (!this.allChildrenHaveReportedTF()) {
	            return;
	        }
	        if (!this.requestedResolutionSinceLastUpdate) {
	            /* Each time we get an update we reset each subchannel's
	             * hasReportedTransientFailure flag, so the next time we get to this
	             * point after that, each subchannel has reported TRANSIENT_FAILURE
	             * at least once since then. That is the trigger for requesting
	             * reresolution, whether or not the LB policy is already in sticky TF
	             * mode. */
	            this.requestReresolution();
	        }
	        if (this.stickyTransientFailureMode) {
	            return;
	        }
	        this.stickyTransientFailureMode = true;
	        for (const { subchannel } of this.children) {
	            subchannel.startConnecting();
	        }
	        this.calculateAndReportNewState();
	    }
	    removeCurrentPick() {
	        if (this.currentPick !== null) {
	            /* Unref can cause a state change, which can cause a change in the value
	             * of this.currentPick, so we hold a local reference to make sure that
	             * does not impact this function. */
	            const currentPick = this.currentPick;
	            this.currentPick = null;
	            currentPick.unref();
	            currentPick.removeConnectivityStateListener(this.subchannelStateListener);
	            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());
	            if (this.reportHealthStatus) {
	                currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
	            }
	        }
	    }
	    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
	        var _a;
	        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {
	            if (newState !== connectivity_state_1.ConnectivityState.READY) {
	                this.removeCurrentPick();
	                this.calculateAndReportNewState();
	                this.requestReresolution();
	            }
	            return;
	        }
	        for (const [index, child] of this.children.entries()) {
	            if (subchannel.realSubchannelEquals(child.subchannel)) {
	                if (newState === connectivity_state_1.ConnectivityState.READY) {
	                    this.pickSubchannel(child.subchannel);
	                }
	                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                    child.hasReportedTransientFailure = true;
	                    if (errorMessage) {
	                        this.lastError = errorMessage;
	                    }
	                    this.maybeEnterStickyTransientFailureMode();
	                    if (index === this.currentSubchannelIndex) {
	                        this.startNextSubchannelConnecting(index + 1);
	                    }
	                }
	                child.subchannel.startConnecting();
	                return;
	            }
	        }
	    }
	    startNextSubchannelConnecting(startIndex) {
	        clearTimeout(this.connectionDelayTimeout);
	        if (this.triedAllSubchannels) {
	            return;
	        }
	        for (const [index, child] of this.children.entries()) {
	            if (index >= startIndex) {
	                const subchannelState = child.subchannel.getConnectivityState();
	                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
	                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
	                    this.startConnecting(index);
	                    return;
	                }
	            }
	        }
	        this.triedAllSubchannels = true;
	        this.maybeEnterStickyTransientFailureMode();
	    }
	    /**
	     * Have a single subchannel in the `subchannels` list start connecting.
	     * @param subchannelIndex The index into the `subchannels` list.
	     */
	    startConnecting(subchannelIndex) {
	        var _a, _b;
	        clearTimeout(this.connectionDelayTimeout);
	        this.currentSubchannelIndex = subchannelIndex;
	        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===
	            connectivity_state_1.ConnectivityState.IDLE) {
	            trace('Start connecting to subchannel with address ' +
	                this.children[subchannelIndex].subchannel.getAddress());
	            process.nextTick(() => {
	                var _a;
	                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();
	            });
	        }
	        this.connectionDelayTimeout = setTimeout(() => {
	            this.startNextSubchannelConnecting(subchannelIndex + 1);
	        }, CONNECTION_DELAY_INTERVAL_MS);
	        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    pickSubchannel(subchannel) {
	        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {
	            return;
	        }
	        trace('Pick subchannel with address ' + subchannel.getAddress());
	        this.stickyTransientFailureMode = false;
	        this.removeCurrentPick();
	        this.currentPick = subchannel;
	        subchannel.ref();
	        if (this.reportHealthStatus) {
	            subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
	        }
	        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
	        this.resetSubchannelList();
	        clearTimeout(this.connectionDelayTimeout);
	        this.calculateAndReportNewState();
	    }
	    updateState(newState, picker) {
	        trace(connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        this.currentState = newState;
	        this.channelControlHelper.updateState(newState, picker);
	    }
	    resetSubchannelList() {
	        for (const child of this.children) {
	            if (!(this.currentPick &&
	                child.subchannel.realSubchannelEquals(this.currentPick))) {
	                /* The connectivity state listener is the same whether the subchannel
	                 * is in the list of children or it is the currentPick, so if it is in
	                 * both, removing it here would cause problems. In particular, that
	                 * always happens immediately after the subchannel is picked. */
	                child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
	            }
	            /* Refs are counted independently for the children list and the
	             * currentPick, so we call unref whether or not the child is the
	             * currentPick. Channelz child references are also refcounted, so
	             * removeChannelzChild can be handled the same way. */
	            child.subchannel.unref();
	            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
	        }
	        this.currentSubchannelIndex = 0;
	        this.children = [];
	        this.triedAllSubchannels = false;
	        this.requestedResolutionSinceLastUpdate = false;
	    }
	    connectToAddressList(addressList) {
	        const newChildrenList = addressList.map(address => ({
	            subchannel: this.channelControlHelper.createSubchannel(address, {}),
	            hasReportedTransientFailure: false,
	        }));
	        /* Ref each subchannel before resetting the list, to ensure that
	         * subchannels shared between the list don't drop to 0 refs during the
	         * transition. */
	        for (const { subchannel } of newChildrenList) {
	            subchannel.ref();
	            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
	        }
	        this.resetSubchannelList();
	        this.children = newChildrenList;
	        for (const { subchannel } of this.children) {
	            subchannel.addConnectivityStateListener(this.subchannelStateListener);
	            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
	                this.pickSubchannel(subchannel);
	                return;
	            }
	        }
	        for (const child of this.children) {
	            if (child.subchannel.getConnectivityState() ===
	                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                child.hasReportedTransientFailure = true;
	            }
	        }
	        this.startNextSubchannelConnecting(0);
	        this.calculateAndReportNewState();
	    }
	    updateAddressList(endpointList, lbConfig) {
	        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
	            return;
	        }
	        /* Previously, an update would be discarded if it was identical to the
	         * previous update, to minimize churn. Now the DNS resolver is
	         * rate-limited, so that is less of a concern. */
	        if (lbConfig.getShuffleAddressList()) {
	            endpointList = shuffled(endpointList);
	        }
	        const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
	        if (rawAddressList.length === 0) {
	            throw new Error('No addresses in endpoint list passed to pick_first');
	        }
	        const addressList = interleaveAddressFamilies(rawAddressList);
	        this.latestAddressList = addressList;
	        this.connectToAddressList(addressList);
	    }
	    exitIdle() {
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE &&
	            this.latestAddressList) {
	            this.connectToAddressList(this.latestAddressList);
	        }
	    }
	    resetBackoff() {
	        /* The pick first load balancer does not have a connection backoff, so this
	         * does nothing */
	    }
	    destroy() {
	        this.resetSubchannelList();
	        this.removeCurrentPick();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerPickFirst.PickFirstLoadBalancer = PickFirstLoadBalancer;
	const LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);
	/**
	 * This class handles the leaf load balancing operations for a single endpoint.
	 * It is a thin wrapper around a PickFirstLoadBalancer with a different API
	 * that more closely reflects how it will be used as a leaf balancer.
	 */
	class LeafLoadBalancer {
	    constructor(endpoint, channelControlHelper, options) {
	        this.endpoint = endpoint;
	        this.latestState = connectivity_state_1.ConnectivityState.IDLE;
	        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
	            updateState: (connectivityState, picker) => {
	                this.latestState = connectivityState;
	                this.latestPicker = picker;
	                channelControlHelper.updateState(connectivityState, picker);
	            },
	        });
	        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, Object.assign(Object.assign({}, options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));
	        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
	    }
	    startConnecting() {
	        this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);
	    }
	    /**
	     * Update the endpoint associated with this LeafLoadBalancer to a new
	     * endpoint. Does not trigger connection establishment if a connection
	     * attempt is not already in progress.
	     * @param newEndpoint
	     */
	    updateEndpoint(newEndpoint) {
	        this.endpoint = newEndpoint;
	        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
	            this.startConnecting();
	        }
	    }
	    getConnectivityState() {
	        return this.latestState;
	    }
	    getPicker() {
	        return this.latestPicker;
	    }
	    getEndpoint() {
	        return this.endpoint;
	    }
	    exitIdle() {
	        this.pickFirstBalancer.exitIdle();
	    }
	    destroy() {
	        this.pickFirstBalancer.destroy();
	    }
	}
	loadBalancerPickFirst.LeafLoadBalancer = LeafLoadBalancer;
	function setup() {
	    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
	    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
	}
	loadBalancerPickFirst.setup = setup;
	
	return loadBalancerPickFirst;
}

var hasRequiredExperimental;

function requireExperimental () {
	if (hasRequiredExperimental) return experimental;
	hasRequiredExperimental = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;
		var logging_1 = logging$8;
		Object.defineProperty(exports, "trace", { enumerable: true, get: function () { return logging_1.trace; } });
		Object.defineProperty(exports, "log", { enumerable: true, get: function () { return logging_1.log; } });
		var resolver_1 = resolver;
		Object.defineProperty(exports, "registerResolver", { enumerable: true, get: function () { return resolver_1.registerResolver; } });
		Object.defineProperty(exports, "createResolver", { enumerable: true, get: function () { return resolver_1.createResolver; } });
		var uri_parser_1 = uriParser;
		Object.defineProperty(exports, "uriToString", { enumerable: true, get: function () { return uri_parser_1.uriToString; } });
		var duration_1 = requireDuration();
		Object.defineProperty(exports, "durationToMs", { enumerable: true, get: function () { return duration_1.durationToMs; } });
		var backoff_timeout_1 = requireBackoffTimeout();
		Object.defineProperty(exports, "BackoffTimeout", { enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } });
		var load_balancer_1 = requireLoadBalancer();
		Object.defineProperty(exports, "createChildChannelControlHelper", { enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } });
		Object.defineProperty(exports, "registerLoadBalancerType", { enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } });
		Object.defineProperty(exports, "selectLbConfigFromList", { enumerable: true, get: function () { return load_balancer_1.selectLbConfigFromList; } });
		Object.defineProperty(exports, "parseLoadBalancingConfig", { enumerable: true, get: function () { return load_balancer_1.parseLoadBalancingConfig; } });
		Object.defineProperty(exports, "isLoadBalancerNameRegistered", { enumerable: true, get: function () { return load_balancer_1.isLoadBalancerNameRegistered; } });
		var load_balancer_pick_first_1 = requireLoadBalancerPickFirst();
		Object.defineProperty(exports, "LeafLoadBalancer", { enumerable: true, get: function () { return load_balancer_pick_first_1.LeafLoadBalancer; } });
		var subchannel_address_1 = subchannelAddress;
		Object.defineProperty(exports, "subchannelAddressToString", { enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } });
		Object.defineProperty(exports, "endpointToString", { enumerable: true, get: function () { return subchannel_address_1.endpointToString; } });
		Object.defineProperty(exports, "endpointHasAddress", { enumerable: true, get: function () { return subchannel_address_1.endpointHasAddress; } });
		Object.defineProperty(exports, "EndpointMap", { enumerable: true, get: function () { return subchannel_address_1.EndpointMap; } });
		var load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
		Object.defineProperty(exports, "ChildLoadBalancerHandler", { enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } });
		var picker_1 = requirePicker();
		Object.defineProperty(exports, "UnavailablePicker", { enumerable: true, get: function () { return picker_1.UnavailablePicker; } });
		Object.defineProperty(exports, "QueuePicker", { enumerable: true, get: function () { return picker_1.QueuePicker; } });
		Object.defineProperty(exports, "PickResultType", { enumerable: true, get: function () { return picker_1.PickResultType; } });
		var filter_1 = requireFilter();
		Object.defineProperty(exports, "BaseFilter", { enumerable: true, get: function () { return filter_1.BaseFilter; } });
		var filter_stack_1 = requireFilterStack();
		Object.defineProperty(exports, "FilterStackFactory", { enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } });
		var admin_1 = requireAdmin();
		Object.defineProperty(exports, "registerAdminService", { enumerable: true, get: function () { return admin_1.registerAdminService; } });
		var subchannel_interface_1 = requireSubchannelInterface();
		Object.defineProperty(exports, "BaseSubchannelWrapper", { enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } });
		
	} (experimental));
	return experimental;
}

var resolverUds = {};

var hasRequiredResolverUds;

function requireResolverUds () {
	if (hasRequiredResolverUds) return resolverUds;
	hasRequiredResolverUds = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(resolverUds, "__esModule", { value: true });
	resolverUds.setup = void 0;
	const resolver_1 = resolver;
	class UdsResolver {
	    constructor(target, listener, channelOptions) {
	        this.listener = listener;
	        this.hasReturnedResult = false;
	        this.endpoints = [];
	        let path;
	        if (target.authority === '') {
	            path = '/' + target.path;
	        }
	        else {
	            path = target.path;
	        }
	        this.endpoints = [{ addresses: [{ path }] }];
	    }
	    updateResolution() {
	        if (!this.hasReturnedResult) {
	            this.hasReturnedResult = true;
	            process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
	        }
	    }
	    destroy() {
	        // This resolver owns no resources, so we do nothing here.
	    }
	    static getDefaultAuthority(target) {
	        return 'localhost';
	    }
	}
	function setup() {
	    (0, resolver_1.registerResolver)('unix', UdsResolver);
	}
	resolverUds.setup = setup;
	
	return resolverUds;
}

var resolverIp = {};

var hasRequiredResolverIp;

function requireResolverIp () {
	if (hasRequiredResolverIp) return resolverIp;
	hasRequiredResolverIp = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(resolverIp, "__esModule", { value: true });
	resolverIp.setup = void 0;
	const net_1 = require$$0$3;
	const constants_1 = constants;
	const metadata_1 = metadata;
	const resolver_1 = resolver;
	const uri_parser_1 = uriParser;
	const logging = logging$8;
	const TRACER_NAME = 'ip_resolver';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const IPV4_SCHEME = 'ipv4';
	const IPV6_SCHEME = 'ipv6';
	/**
	 * The default TCP port to connect to if not explicitly specified in the target.
	 */
	const DEFAULT_PORT = 443;
	class IpResolver {
	    constructor(target, listener, channelOptions) {
	        var _a;
	        this.listener = listener;
	        this.endpoints = [];
	        this.error = null;
	        this.hasReturnedResult = false;
	        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
	        const addresses = [];
	        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
	            this.error = {
	                code: constants_1.Status.UNAVAILABLE,
	                details: `Unrecognized scheme ${target.scheme} in IP resolver`,
	                metadata: new metadata_1.Metadata(),
	            };
	            return;
	        }
	        const pathList = target.path.split(',');
	        for (const path of pathList) {
	            const hostPort = (0, uri_parser_1.splitHostPort)(path);
	            if (hostPort === null) {
	                this.error = {
	                    code: constants_1.Status.UNAVAILABLE,
	                    details: `Failed to parse ${target.scheme} address ${path}`,
	                    metadata: new metadata_1.Metadata(),
	                };
	                return;
	            }
	            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||
	                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {
	                this.error = {
	                    code: constants_1.Status.UNAVAILABLE,
	                    details: `Failed to parse ${target.scheme} address ${path}`,
	                    metadata: new metadata_1.Metadata(),
	                };
	                return;
	            }
	            addresses.push({
	                host: hostPort.host,
	                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,
	            });
	        }
	        this.endpoints = addresses.map(address => ({ addresses: [address] }));
	        trace('Parsed ' + target.scheme + ' address list ' + addresses);
	    }
	    updateResolution() {
	        if (!this.hasReturnedResult) {
	            this.hasReturnedResult = true;
	            process.nextTick(() => {
	                if (this.error) {
	                    this.listener.onError(this.error);
	                }
	                else {
	                    this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
	                }
	            });
	        }
	    }
	    destroy() {
	        this.hasReturnedResult = false;
	    }
	    static getDefaultAuthority(target) {
	        return target.path.split(',')[0];
	    }
	}
	function setup() {
	    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
	    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
	}
	resolverIp.setup = setup;
	
	return resolverIp;
}

var loadBalancerRoundRobin = {};

var hasRequiredLoadBalancerRoundRobin;

function requireLoadBalancerRoundRobin () {
	if (hasRequiredLoadBalancerRoundRobin) return loadBalancerRoundRobin;
	hasRequiredLoadBalancerRoundRobin = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerRoundRobin, "__esModule", { value: true });
	loadBalancerRoundRobin.setup = loadBalancerRoundRobin.RoundRobinLoadBalancer = void 0;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = connectivityState;
	const picker_1 = requirePicker();
	const logging = logging$8;
	const constants_1 = constants;
	const subchannel_address_1 = subchannelAddress;
	const load_balancer_pick_first_1 = requireLoadBalancerPickFirst();
	const TRACER_NAME = 'round_robin';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'round_robin';
	class RoundRobinLoadBalancingConfig {
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    constructor() { }
	    toJsonObject() {
	        return {
	            [TYPE_NAME]: {},
	        };
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    static createFromJson(obj) {
	        return new RoundRobinLoadBalancingConfig();
	    }
	}
	class RoundRobinPicker {
	    constructor(children, nextIndex = 0) {
	        this.children = children;
	        this.nextIndex = nextIndex;
	    }
	    pick(pickArgs) {
	        const childPicker = this.children[this.nextIndex].picker;
	        this.nextIndex = (this.nextIndex + 1) % this.children.length;
	        return childPicker.pick(pickArgs);
	    }
	    /**
	     * Check what the next subchannel returned would be. Used by the load
	     * balancer implementation to preserve this part of the picker state if
	     * possible when a subchannel connects or disconnects.
	     */
	    peekNextEndpoint() {
	        return this.children[this.nextIndex].endpoint;
	    }
	}
	class RoundRobinLoadBalancer {
	    constructor(channelControlHelper, options) {
	        this.channelControlHelper = channelControlHelper;
	        this.options = options;
	        this.children = [];
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        this.currentReadyPicker = null;
	        this.updatesPaused = false;
	        this.lastError = null;
	        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
	            updateState: (connectivityState, picker) => {
	                this.calculateAndUpdateState();
	            },
	        });
	    }
	    countChildrenWithState(state) {
	        return this.children.filter(child => child.getConnectivityState() === state)
	            .length;
	    }
	    calculateAndUpdateState() {
	        if (this.updatesPaused) {
	            return;
	        }
	        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
	            const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
	            let index = 0;
	            if (this.currentReadyPicker !== null) {
	                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
	                index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
	                if (index < 0) {
	                    index = 0;
	                }
	            }
	            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({
	                endpoint: child.getEndpoint(),
	                picker: child.getPicker(),
	            })), index));
	        }
	        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
	        }
	        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                details: `No connection established. Last error: ${this.lastError}`,
	            }));
	        }
	        else {
	            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        }
	        /* round_robin should keep all children connected, this is how we do that.
	         * We can't do this more efficiently in the individual child's updateState
	         * callback because that doesn't have a reference to which child the state
	         * change is associated with. */
	        for (const child of this.children) {
	            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
	                child.exitIdle();
	            }
	        }
	    }
	    updateState(newState, picker) {
	        trace(connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (newState === connectivity_state_1.ConnectivityState.READY) {
	            this.currentReadyPicker = picker;
	        }
	        else {
	            this.currentReadyPicker = null;
	        }
	        this.currentState = newState;
	        this.channelControlHelper.updateState(newState, picker);
	    }
	    resetSubchannelList() {
	        for (const child of this.children) {
	            child.destroy();
	        }
	    }
	    updateAddressList(endpointList, lbConfig) {
	        this.resetSubchannelList();
	        trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));
	        this.updatesPaused = true;
	        this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.options));
	        for (const child of this.children) {
	            child.startConnecting();
	        }
	        this.updatesPaused = false;
	        this.calculateAndUpdateState();
	    }
	    exitIdle() {
	        /* The round_robin LB policy is only in the IDLE state if it has no
	         * addresses to try to connect to and it has no picked subchannel.
	         * In that case, there is no meaningful action that can be taken here. */
	    }
	    resetBackoff() {
	        // This LB policy has no backoff to reset
	    }
	    destroy() {
	        this.resetSubchannelList();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerRoundRobin.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
	function setup() {
	    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
	}
	loadBalancerRoundRobin.setup = setup;
	
	return loadBalancerRoundRobin;
}

var loadBalancerOutlierDetection = {};

var hasRequiredLoadBalancerOutlierDetection;

function requireLoadBalancerOutlierDetection () {
	if (hasRequiredLoadBalancerOutlierDetection) return loadBalancerOutlierDetection;
	hasRequiredLoadBalancerOutlierDetection = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var _a;
	Object.defineProperty(loadBalancerOutlierDetection, "__esModule", { value: true });
	loadBalancerOutlierDetection.setup = loadBalancerOutlierDetection.OutlierDetectionLoadBalancer = loadBalancerOutlierDetection.OutlierDetectionLoadBalancingConfig = void 0;
	const connectivity_state_1 = connectivityState;
	const constants_1 = constants;
	const duration_1 = requireDuration();
	const experimental_1 = requireExperimental();
	const load_balancer_1 = requireLoadBalancer();
	const load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
	const picker_1 = requirePicker();
	const subchannel_address_1 = subchannelAddress;
	const subchannel_interface_1 = requireSubchannelInterface();
	const logging = logging$8;
	const TRACER_NAME = 'outlier_detection';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'outlier_detection';
	const OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';
	const defaultSuccessRateEjectionConfig = {
	    stdev_factor: 1900,
	    enforcement_percentage: 100,
	    minimum_hosts: 5,
	    request_volume: 100,
	};
	const defaultFailurePercentageEjectionConfig = {
	    threshold: 85,
	    enforcement_percentage: 100,
	    minimum_hosts: 5,
	    request_volume: 50,
	};
	function validateFieldType(obj, fieldName, expectedType, objectName) {
	    if (fieldName in obj &&
	        obj[fieldName] !== undefined &&
	        typeof obj[fieldName] !== expectedType) {
	        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
	        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
	    }
	}
	function validatePositiveDuration(obj, fieldName, objectName) {
	    const fullFieldName = fieldName;
	    if (fieldName in obj && obj[fieldName] !== undefined) {
	        if (!(0, duration_1.isDuration)(obj[fieldName])) {
	            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
	        }
	        if (!(obj[fieldName].seconds >= 0 &&
	            obj[fieldName].seconds <= 315576000000 &&
	            obj[fieldName].nanos >= 0 &&
	            obj[fieldName].nanos <= 999999999)) {
	            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
	        }
	    }
	}
	function validatePercentage(obj, fieldName, objectName) {
	    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
	    validateFieldType(obj, fieldName, 'number', objectName);
	    if (fieldName in obj &&
	        obj[fieldName] !== undefined &&
	        !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
	        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
	    }
	}
	class OutlierDetectionLoadBalancingConfig {
	    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
	        this.childPolicy = childPolicy;
	        if (childPolicy.getLoadBalancerName() === 'pick_first') {
	            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');
	        }
	        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;
	        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;
	        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;
	        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
	        this.successRateEjection = successRateEjection
	            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
	        this.failurePercentageEjection = failurePercentageEjection
	            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
	    }
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    toJsonObject() {
	        var _a, _b;
	        return {
	            outlier_detection: {
	                interval: (0, duration_1.msToDuration)(this.intervalMs),
	                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
	                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
	                max_ejection_percent: this.maxEjectionPercent,
	                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== void 0 ? _a : undefined,
	                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== void 0 ? _b : undefined,
	                child_policy: [this.childPolicy.toJsonObject()],
	            },
	        };
	    }
	    getIntervalMs() {
	        return this.intervalMs;
	    }
	    getBaseEjectionTimeMs() {
	        return this.baseEjectionTimeMs;
	    }
	    getMaxEjectionTimeMs() {
	        return this.maxEjectionTimeMs;
	    }
	    getMaxEjectionPercent() {
	        return this.maxEjectionPercent;
	    }
	    getSuccessRateEjectionConfig() {
	        return this.successRateEjection;
	    }
	    getFailurePercentageEjectionConfig() {
	        return this.failurePercentageEjection;
	    }
	    getChildPolicy() {
	        return this.childPolicy;
	    }
	    static createFromJson(obj) {
	        var _a;
	        validatePositiveDuration(obj, 'interval');
	        validatePositiveDuration(obj, 'base_ejection_time');
	        validatePositiveDuration(obj, 'max_ejection_time');
	        validatePercentage(obj, 'max_ejection_percent');
	        if ('success_rate_ejection' in obj &&
	            obj.success_rate_ejection !== undefined) {
	            if (typeof obj.success_rate_ejection !== 'object') {
	                throw new Error('outlier detection config success_rate_ejection must be an object');
	            }
	            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');
	            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');
	            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');
	            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');
	        }
	        if ('failure_percentage_ejection' in obj &&
	            obj.failure_percentage_ejection !== undefined) {
	            if (typeof obj.failure_percentage_ejection !== 'object') {
	                throw new Error('outlier detection config failure_percentage_ejection must be an object');
	            }
	            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');
	            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');
	            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');
	            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');
	        }
	        if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {
	            throw new Error('outlier detection config child_policy must be an array');
	        }
	        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
	        if (!childPolicy) {
	            throw new Error('outlier detection config child_policy: no valid recognized policy found');
	        }
	        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
	    }
	}
	loadBalancerOutlierDetection.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
	class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
	    constructor(childSubchannel, mapEntry) {
	        super(childSubchannel);
	        this.mapEntry = mapEntry;
	        this.refCount = 0;
	    }
	    ref() {
	        this.child.ref();
	        this.refCount += 1;
	    }
	    unref() {
	        this.child.unref();
	        this.refCount -= 1;
	        if (this.refCount <= 0) {
	            if (this.mapEntry) {
	                const index = this.mapEntry.subchannelWrappers.indexOf(this);
	                if (index >= 0) {
	                    this.mapEntry.subchannelWrappers.splice(index, 1);
	                }
	            }
	        }
	    }
	    eject() {
	        this.setHealthy(false);
	    }
	    uneject() {
	        this.setHealthy(true);
	    }
	    getMapEntry() {
	        return this.mapEntry;
	    }
	    getWrappedSubchannel() {
	        return this.child;
	    }
	}
	function createEmptyBucket() {
	    return {
	        success: 0,
	        failure: 0,
	    };
	}
	class CallCounter {
	    constructor() {
	        this.activeBucket = createEmptyBucket();
	        this.inactiveBucket = createEmptyBucket();
	    }
	    addSuccess() {
	        this.activeBucket.success += 1;
	    }
	    addFailure() {
	        this.activeBucket.failure += 1;
	    }
	    switchBuckets() {
	        this.inactiveBucket = this.activeBucket;
	        this.activeBucket = createEmptyBucket();
	    }
	    getLastSuccesses() {
	        return this.inactiveBucket.success;
	    }
	    getLastFailures() {
	        return this.inactiveBucket.failure;
	    }
	}
	class OutlierDetectionPicker {
	    constructor(wrappedPicker, countCalls) {
	        this.wrappedPicker = wrappedPicker;
	        this.countCalls = countCalls;
	    }
	    pick(pickArgs) {
	        const wrappedPick = this.wrappedPicker.pick(pickArgs);
	        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
	            const subchannelWrapper = wrappedPick.subchannel;
	            const mapEntry = subchannelWrapper.getMapEntry();
	            if (mapEntry) {
	                let onCallEnded = wrappedPick.onCallEnded;
	                if (this.countCalls) {
	                    onCallEnded = statusCode => {
	                        var _a;
	                        if (statusCode === constants_1.Status.OK) {
	                            mapEntry.counter.addSuccess();
	                        }
	                        else {
	                            mapEntry.counter.addFailure();
	                        }
	                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);
	                    };
	                }
	                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });
	            }
	            else {
	                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
	            }
	        }
	        else {
	            return wrappedPick;
	        }
	    }
	}
	class OutlierDetectionLoadBalancer {
	    constructor(channelControlHelper, options) {
	        this.entryMap = new subchannel_address_1.EndpointMap();
	        this.latestConfig = null;
	        this.timerStartTime = null;
	        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
	            createSubchannel: (subchannelAddress, subchannelArgs) => {
	                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
	                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
	                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
	                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {
	                    // If the address is ejected, propagate that to the new subchannel wrapper
	                    subchannelWrapper.eject();
	                }
	                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
	                return subchannelWrapper;
	            },
	            updateState: (connectivityState, picker) => {
	                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
	                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
	                }
	                else {
	                    channelControlHelper.updateState(connectivityState, picker);
	                }
	            },
	        }), options);
	        this.ejectionTimer = setInterval(() => { }, 0);
	        clearInterval(this.ejectionTimer);
	    }
	    isCountingEnabled() {
	        return (this.latestConfig !== null &&
	            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
	                this.latestConfig.getFailurePercentageEjectionConfig() !== null));
	    }
	    getCurrentEjectionPercent() {
	        let ejectionCount = 0;
	        for (const mapEntry of this.entryMap.values()) {
	            if (mapEntry.currentEjectionTimestamp !== null) {
	                ejectionCount += 1;
	            }
	        }
	        return (ejectionCount * 100) / this.entryMap.size;
	    }
	    runSuccessRateCheck(ejectionTimestamp) {
	        if (!this.latestConfig) {
	            return;
	        }
	        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
	        if (!successRateConfig) {
	            return;
	        }
	        trace('Running success rate check');
	        // Step 1
	        const targetRequestVolume = successRateConfig.request_volume;
	        let addresesWithTargetVolume = 0;
	        const successRates = [];
	        for (const [endpoint, mapEntry] of this.entryMap.entries()) {
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            trace('Stats for ' +
	                (0, subchannel_address_1.endpointToString)(endpoint) +
	                ': successes=' +
	                successes +
	                ' failures=' +
	                failures +
	                ' targetRequestVolume=' +
	                targetRequestVolume);
	            if (successes + failures >= targetRequestVolume) {
	                addresesWithTargetVolume += 1;
	                successRates.push(successes / (successes + failures));
	            }
	        }
	        trace('Found ' +
	            addresesWithTargetVolume +
	            ' success rate candidates; currentEjectionPercent=' +
	            this.getCurrentEjectionPercent() +
	            ' successRates=[' +
	            successRates +
	            ']');
	        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
	            return;
	        }
	        // Step 2
	        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
	        let successRateDeviationSum = 0;
	        for (const rate of successRates) {
	            const deviation = rate - successRateMean;
	            successRateDeviationSum += deviation * deviation;
	        }
	        const successRateVariance = successRateDeviationSum / successRates.length;
	        const successRateStdev = Math.sqrt(successRateVariance);
	        const ejectionThreshold = successRateMean -
	            successRateStdev * (successRateConfig.stdev_factor / 1000);
	        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);
	        // Step 3
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            // Step 3.i
	            if (this.getCurrentEjectionPercent() >=
	                this.latestConfig.getMaxEjectionPercent()) {
	                break;
	            }
	            // Step 3.ii
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            if (successes + failures < targetRequestVolume) {
	                continue;
	            }
	            // Step 3.iii
	            const successRate = successes / (successes + failures);
	            trace('Checking candidate ' + address + ' successRate=' + successRate);
	            if (successRate < ejectionThreshold) {
	                const randomNumber = Math.random() * 100;
	                trace('Candidate ' +
	                    address +
	                    ' randomNumber=' +
	                    randomNumber +
	                    ' enforcement_percentage=' +
	                    successRateConfig.enforcement_percentage);
	                if (randomNumber < successRateConfig.enforcement_percentage) {
	                    trace('Ejecting candidate ' + address);
	                    this.eject(mapEntry, ejectionTimestamp);
	                }
	            }
	        }
	    }
	    runFailurePercentageCheck(ejectionTimestamp) {
	        if (!this.latestConfig) {
	            return;
	        }
	        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
	        if (!failurePercentageConfig) {
	            return;
	        }
	        trace('Running failure percentage check. threshold=' +
	            failurePercentageConfig.threshold +
	            ' request volume threshold=' +
	            failurePercentageConfig.request_volume);
	        // Step 1
	        let addressesWithTargetVolume = 0;
	        for (const mapEntry of this.entryMap.values()) {
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            if (successes + failures >= failurePercentageConfig.request_volume) {
	                addressesWithTargetVolume += 1;
	            }
	        }
	        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
	            return;
	        }
	        // Step 2
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            // Step 2.i
	            if (this.getCurrentEjectionPercent() >=
	                this.latestConfig.getMaxEjectionPercent()) {
	                break;
	            }
	            // Step 2.ii
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            trace('Candidate successes=' + successes + ' failures=' + failures);
	            if (successes + failures < failurePercentageConfig.request_volume) {
	                continue;
	            }
	            // Step 2.iii
	            const failurePercentage = (failures * 100) / (failures + successes);
	            if (failurePercentage > failurePercentageConfig.threshold) {
	                const randomNumber = Math.random() * 100;
	                trace('Candidate ' +
	                    address +
	                    ' randomNumber=' +
	                    randomNumber +
	                    ' enforcement_percentage=' +
	                    failurePercentageConfig.enforcement_percentage);
	                if (randomNumber < failurePercentageConfig.enforcement_percentage) {
	                    trace('Ejecting candidate ' + address);
	                    this.eject(mapEntry, ejectionTimestamp);
	                }
	            }
	        }
	    }
	    eject(mapEntry, ejectionTimestamp) {
	        mapEntry.currentEjectionTimestamp = new Date();
	        mapEntry.ejectionTimeMultiplier += 1;
	        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
	            subchannelWrapper.eject();
	        }
	    }
	    uneject(mapEntry) {
	        mapEntry.currentEjectionTimestamp = null;
	        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
	            subchannelWrapper.uneject();
	        }
	    }
	    switchAllBuckets() {
	        for (const mapEntry of this.entryMap.values()) {
	            mapEntry.counter.switchBuckets();
	        }
	    }
	    startTimer(delayMs) {
	        var _a, _b;
	        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
	        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
	    }
	    runChecks() {
	        const ejectionTimestamp = new Date();
	        trace('Ejection timer running');
	        this.switchAllBuckets();
	        if (!this.latestConfig) {
	            return;
	        }
	        this.timerStartTime = ejectionTimestamp;
	        this.startTimer(this.latestConfig.getIntervalMs());
	        this.runSuccessRateCheck(ejectionTimestamp);
	        this.runFailurePercentageCheck(ejectionTimestamp);
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            if (mapEntry.currentEjectionTimestamp === null) {
	                if (mapEntry.ejectionTimeMultiplier > 0) {
	                    mapEntry.ejectionTimeMultiplier -= 1;
	                }
	            }
	            else {
	                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
	                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
	                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
	                returnTime.setMilliseconds(returnTime.getMilliseconds() +
	                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
	                if (returnTime < new Date()) {
	                    trace('Unejecting ' + address);
	                    this.uneject(mapEntry);
	                }
	            }
	        }
	    }
	    updateAddressList(endpointList, lbConfig, attributes) {
	        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
	            return;
	        }
	        for (const endpoint of endpointList) {
	            if (!this.entryMap.has(endpoint)) {
	                trace('Adding map entry for ' + (0, subchannel_address_1.endpointToString)(endpoint));
	                this.entryMap.set(endpoint, {
	                    counter: new CallCounter(),
	                    currentEjectionTimestamp: null,
	                    ejectionTimeMultiplier: 0,
	                    subchannelWrappers: [],
	                });
	            }
	        }
	        this.entryMap.deleteMissing(endpointList);
	        const childPolicy = lbConfig.getChildPolicy();
	        this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);
	        if (lbConfig.getSuccessRateEjectionConfig() ||
	            lbConfig.getFailurePercentageEjectionConfig()) {
	            if (this.timerStartTime) {
	                trace('Previous timer existed. Replacing timer');
	                clearTimeout(this.ejectionTimer);
	                const remainingDelay = lbConfig.getIntervalMs() -
	                    (new Date().getTime() - this.timerStartTime.getTime());
	                this.startTimer(remainingDelay);
	            }
	            else {
	                trace('Starting new timer');
	                this.timerStartTime = new Date();
	                this.startTimer(lbConfig.getIntervalMs());
	                this.switchAllBuckets();
	            }
	        }
	        else {
	            trace('Counting disabled. Cancelling timer.');
	            this.timerStartTime = null;
	            clearTimeout(this.ejectionTimer);
	            for (const mapEntry of this.entryMap.values()) {
	                this.uneject(mapEntry);
	                mapEntry.ejectionTimeMultiplier = 0;
	            }
	        }
	        this.latestConfig = lbConfig;
	    }
	    exitIdle() {
	        this.childBalancer.exitIdle();
	    }
	    resetBackoff() {
	        this.childBalancer.resetBackoff();
	    }
	    destroy() {
	        clearTimeout(this.ejectionTimer);
	        this.childBalancer.destroy();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerOutlierDetection.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
	function setup() {
	    if (OUTLIER_DETECTION_ENABLED) {
	        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
	    }
	}
	loadBalancerOutlierDetection.setup = setup;
	
	return loadBalancerOutlierDetection;
}

(function (exports) {
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;
	const call_credentials_1 = callCredentials;
	Object.defineProperty(exports, "CallCredentials", { enumerable: true, get: function () { return call_credentials_1.CallCredentials; } });
	const channel_1 = requireChannel();
	Object.defineProperty(exports, "Channel", { enumerable: true, get: function () { return channel_1.ChannelImplementation; } });
	const compression_algorithms_1 = compressionAlgorithms;
	Object.defineProperty(exports, "compressionAlgorithms", { enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } });
	const connectivity_state_1 = connectivityState;
	Object.defineProperty(exports, "connectivityState", { enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } });
	const channel_credentials_1 = channelCredentials;
	Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } });
	const client_1 = requireClient();
	Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
	const constants_1 = constants;
	Object.defineProperty(exports, "logVerbosity", { enumerable: true, get: function () { return constants_1.LogVerbosity; } });
	Object.defineProperty(exports, "status", { enumerable: true, get: function () { return constants_1.Status; } });
	Object.defineProperty(exports, "propagate", { enumerable: true, get: function () { return constants_1.Propagate; } });
	const logging = logging$8;
	const make_client_1 = requireMakeClient();
	Object.defineProperty(exports, "loadPackageDefinition", { enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } });
	Object.defineProperty(exports, "makeClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
	Object.defineProperty(exports, "makeGenericClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
	const metadata_1 = metadata;
	Object.defineProperty(exports, "Metadata", { enumerable: true, get: function () { return metadata_1.Metadata; } });
	const server_1 = server;
	Object.defineProperty(exports, "Server", { enumerable: true, get: function () { return server_1.Server; } });
	const server_credentials_1 = serverCredentials;
	Object.defineProperty(exports, "ServerCredentials", { enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } });
	const status_builder_1 = statusBuilder;
	Object.defineProperty(exports, "StatusBuilder", { enumerable: true, get: function () { return status_builder_1.StatusBuilder; } });
	/**** Client Credentials ****/
	// Using assign only copies enumerable properties, which is what we want
	exports.credentials = {
	    /**
	     * Combine a ChannelCredentials with any number of CallCredentials into a
	     * single ChannelCredentials object.
	     * @param channelCredentials The ChannelCredentials object.
	     * @param callCredentials Any number of CallCredentials objects.
	     * @return The resulting ChannelCredentials object.
	     */
	    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
	        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
	    },
	    /**
	     * Combine any number of CallCredentials into a single CallCredentials
	     * object.
	     * @param first The first CallCredentials object.
	     * @param additional Any number of additional CallCredentials objects.
	     * @return The resulting CallCredentials object.
	     */
	    combineCallCredentials: (first, ...additional) => {
	        return additional.reduce((acc, other) => acc.compose(other), first);
	    },
	    // from channel-credentials.ts
	    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
	    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
	    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
	    // from call-credentials.ts
	    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
	    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
	    createEmpty: call_credentials_1.CallCredentials.createEmpty,
	};
	/**
	 * Close a Client object.
	 * @param client The client to close.
	 */
	const closeClient = (client) => client.close();
	exports.closeClient = closeClient;
	const waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
	exports.waitForClientReady = waitForClientReady;
	/* eslint-enable @typescript-eslint/no-explicit-any */
	/**** Unimplemented function stubs ****/
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const loadObject = (value, options) => {
	    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
	};
	exports.loadObject = loadObject;
	const load = (filename, format, options) => {
	    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
	};
	exports.load = load;
	const setLogger = (logger) => {
	    logging.setLogger(logger);
	};
	exports.setLogger = setLogger;
	const setLogVerbosity = (verbosity) => {
	    logging.setLoggerVerbosity(verbosity);
	};
	exports.setLogVerbosity = setLogVerbosity;
	const getClientChannel = (client) => {
	    return client_1.Client.prototype.getChannel.call(client);
	};
	exports.getClientChannel = getClientChannel;
	var client_interceptors_1 = requireClientInterceptors();
	Object.defineProperty(exports, "ListenerBuilder", { enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } });
	Object.defineProperty(exports, "RequesterBuilder", { enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } });
	Object.defineProperty(exports, "InterceptingCall", { enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } });
	Object.defineProperty(exports, "InterceptorConfigurationError", { enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } });
	var channelz_1 = requireChannelz();
	Object.defineProperty(exports, "getChannelzServiceDefinition", { enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } });
	Object.defineProperty(exports, "getChannelzHandlers", { enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } });
	var admin_1 = requireAdmin();
	Object.defineProperty(exports, "addAdminServicesToServer", { enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } });
	var server_interceptors_1 = requireServerInterceptors();
	Object.defineProperty(exports, "ServerListenerBuilder", { enumerable: true, get: function () { return server_interceptors_1.ServerListenerBuilder; } });
	Object.defineProperty(exports, "ResponderBuilder", { enumerable: true, get: function () { return server_interceptors_1.ResponderBuilder; } });
	Object.defineProperty(exports, "ServerInterceptingCall", { enumerable: true, get: function () { return server_interceptors_1.ServerInterceptingCall; } });
	const experimental = requireExperimental();
	exports.experimental = experimental;
	const resolver_dns = requireResolverDns();
	const resolver_uds = requireResolverUds();
	const resolver_ip = requireResolverIp();
	const load_balancer_pick_first = requireLoadBalancerPickFirst();
	const load_balancer_round_robin = requireLoadBalancerRoundRobin();
	const load_balancer_outlier_detection = requireLoadBalancerOutlierDetection();
	const channelz = requireChannelz();
	(() => {
	    resolver_dns.setup();
	    resolver_uds.setup();
	    resolver_ip.setup();
	    load_balancer_pick_first.setup();
	    load_balancer_round_robin.setup();
	    load_balancer_outlier_detection.setup();
	    channelz.setup();
	})();
	
} (src$2));

var main$1 = {exports: {}};

var name = "dotenv";
var version$1 = "16.4.5";
var description = "Loads environment variables from .env file";
var main = "lib/main.js";
var types = "lib/main.d.ts";
var exports$1 = {
	".": {
		types: "./lib/main.d.ts",
		require: "./lib/main.js",
		"default": "./lib/main.js"
	},
	"./config": "./config.js",
	"./config.js": "./config.js",
	"./lib/env-options": "./lib/env-options.js",
	"./lib/env-options.js": "./lib/env-options.js",
	"./lib/cli-options": "./lib/cli-options.js",
	"./lib/cli-options.js": "./lib/cli-options.js",
	"./package.json": "./package.json"
};
var scripts = {
	"dts-check": "tsc --project tests/types/tsconfig.json",
	lint: "standard",
	"lint-readme": "standard-markdown",
	pretest: "npm run lint && npm run dts-check",
	test: "tap tests/*.js --100 -Rspec",
	"test:coverage": "tap --coverage-report=lcov",
	prerelease: "npm test",
	release: "standard-version"
};
var repository = {
	type: "git",
	url: "git://github.com/motdotla/dotenv.git"
};
var funding = "https://dotenvx.com";
var keywords = [
	"dotenv",
	"env",
	".env",
	"environment",
	"variables",
	"config",
	"settings"
];
var readmeFilename = "README.md";
var license = "BSD-2-Clause";
var devDependencies = {
	"@definitelytyped/dtslint": "^0.0.133",
	"@types/node": "^18.11.3",
	decache: "^4.6.1",
	sinon: "^14.0.1",
	standard: "^17.0.0",
	"standard-markdown": "^7.1.0",
	"standard-version": "^9.5.0",
	tap: "^16.3.0",
	tar: "^6.1.11",
	typescript: "^4.8.4"
};
var engines = {
	node: ">=12"
};
var browser = {
	fs: false
};
var require$$4 = {
	name: name,
	version: version$1,
	description: description,
	main: main,
	types: types,
	exports: exports$1,
	scripts: scripts,
	repository: repository,
	funding: funding,
	keywords: keywords,
	readmeFilename: readmeFilename,
	license: license,
	devDependencies: devDependencies,
	engines: engines,
	browser: browser
};

const fs = require$$0;
const path = require$$1$3;
const os = require$$0$2;
const crypto = require$$3$2;
const packageJson = require$$4;

const version = packageJson.version;

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;

// Parse src into an Object
function parse (src) {
  const obj = {};

  // Convert buffer to string
  let lines = src.toString();

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n');

  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];

    // Default undefined or null to empty string
    let value = (match[2] || '');

    // Remove whitespace
    value = value.trim();

    // Check if double quoted
    const maybeQuote = value[0];

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n');
      value = value.replace(/\\r/g, '\r');
    }

    // Add to object
    obj[key] = value;
  }

  return obj
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options);

  // Parse .env.vault
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = 'MISSING_DATA';
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',');
  const length = keys.length;

  let decrypted;
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim();

      // Get instructions for decrypt
      const attrs = _instructions(result, key);

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _log (message) {
  console.log(`[dotenv@${version}][INFO] ${message}`);
}

function _warn (message) {
  console.log(`[dotenv@${version}][WARN] ${message}`);
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`);
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
      err.code = 'INVALID_DOTENV_KEY';
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password;
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part');
    err.code = 'INVALID_DOTENV_KEY';
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment');
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
    err.code = 'INVALID_DOTENV_KEY';
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
    throw err
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let possibleVaultPath = null;

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  _log('Loading env from encrypted .env.vault');

  const parsed = DotenvModule._parseVault(options);

  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }

  DotenvModule.populate(processEnv, parsed, options);

  return { parsed }
}

function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env');
  let encoding = 'utf8';
  const debug = Boolean(options && options.debug);

  if (options && options.encoding) {
    encoding = options.encoding;
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default');
    }
  }

  let optionPaths = [dotenvPath]; // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)];
    } else {
      optionPaths = []; // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError;
  const parsedAll = {};
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }));

      DotenvModule.populate(parsedAll, parsed, options);
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`);
      }
      lastError = e;
    }
  }

  let processEnv = process.env;
  if (options && options.processEnv != null) {
    processEnv = options.processEnv;
  }

  DotenvModule.populate(processEnv, parsedAll, options);

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options);

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex');
  let ciphertext = Buffer.from(encrypted, 'base64');

  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError;
    const invalidKeyLength = error.message === 'Invalid key length';
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
      err.code = 'INVALID_DOTENV_KEY';
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
      err.code = 'DECRYPTION_FAILED';
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug);
  const override = Boolean(options && options.override);

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
    err.code = 'OBJECT_REQUIRED';
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
};

main$1.exports.configDotenv = DotenvModule.configDotenv;
main$1.exports._configVault = DotenvModule._configVault;
main$1.exports._parseVault = DotenvModule._parseVault;
main$1.exports.config = DotenvModule.config;
main$1.exports.decrypt = DotenvModule.decrypt;
main$1.exports.parse = DotenvModule.parse;
main$1.exports.populate = DotenvModule.populate;

main$1.exports = DotenvModule;

var mainExports = main$1.exports;
var dotenv = /*@__PURE__*/getDefaultExportFromCjs(mainExports);

var route_guide_pb$1 = {};

var googleProtobuf = {};

var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return {i:e,v:f}}return {i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);};$jscomp.getGlobal=function(a){return "undefined"!=typeof window&&window===a?a:"undefined"!=typeof commonjsGlobal&&null!=commonjsGlobal?commonjsGlobal:a};$jscomp.global=$jscomp.getGlobal(commonjsGlobal);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e];}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b});}};$jscomp.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).i}},"es6","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var e=a.length;0<e&&0<c;)if(b[--c]!=a[--e])return !1;return 0>=e}},"es6","es3");$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6","es3");
$jscomp.polyfill("String.prototype.startsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"startsWith");a+="";var e=b.length,f=a.length;c=Math.max(0,Math.min(c|0,b.length));for(var g=0;g<f&&c<e;)if(b[c++]!=a[g++])return !1;return g>=f}},"es6","es3");
$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");var COMPILED$1=!0,goog=goog||{};goog.global=commonjsGlobal||self;goog.isDef=function(a){return void 0!==a};goog.isString=function(a){return "string"==typeof a};goog.isBoolean=function(a){return "boolean"==typeof a};
goog.isNumber=function(a){return "number"==typeof a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={};};
goog.define=function(a,b){return b};goog.FEATURESET_YEAR=2012;goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=!goog.DEBUG;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;
goog.provide=function(a){if(goog.isInModuleLoader_())throw Error("goog.provide cannot be used within a module.");goog.constructNamespace_(a);};goog.constructNamespace_=function(a,b){goog.exportPath_(a,b);};
goog.getScriptNonce=function(a){if(a&&a!=goog.global)return goog.getScriptNonce_(a.document);null===goog.cspNonce_&&(goog.cspNonce_=goog.getScriptNonce_(goog.global.document));return goog.cspNonce_};goog.NONCE_PATTERN_=/^[\w+/_-]+[=]{0,2}$/;goog.cspNonce_=null;goog.getScriptNonce_=function(a){return (a=a.querySelector&&a.querySelector("script[nonce]"))&&(a=a.nonce||a.getAttribute("nonce"))&&goog.NONCE_PATTERN_.test(a)?a:""};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInGoogModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;};goog.module.get=function(a){return goog.module.getInternal_(a)};
goog.module.getInternal_=function(a){return null};goog.ModuleType={ES6:"es6",GOOG:"goog"};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return goog.isInGoogModuleLoader_()||goog.isInEs6ModuleLoader_()};goog.isInGoogModuleLoader_=function(){return !!goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.GOOG};
goog.isInEs6ModuleLoader_=function(){if(goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.ES6)return !0;var a=goog.global.$jscomp;return a?"function"!=typeof a.getCurrentModulePath?!1:!!a.getCurrentModulePath():!1};
goog.module.declareLegacyNamespace=function(){goog.moduleLoaderState_.declareLegacyNamespace=!0;};
goog.declareModuleId=function(a){if(goog.moduleLoaderState_)goog.moduleLoaderState_.moduleName=a;else {var b=goog.global.$jscomp;if(!b||"function"!=typeof b.getCurrentModulePath)throw Error('Module with namespace "'+
a+'" has been loaded incorrectly.');b=b.require(b.getCurrentModulePath());goog.loadedModules_[a]={exports:b,type:goog.ModuleType.ES6,moduleId:a};}};goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};
goog.getObjectByName=function(a,b){a=a.split(".");b=b||goog.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog.isDefAndNotNull(b))return null;return b};goog.globalize=function(a,b){b=b||goog.global;for(var c in a)b[c]=a[c];};
goog.addDependency=function(a,b,c,d){};goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a);};
goog.require=function(a){};goog.requireType=function(a){return {}};goog.basePath="";goog.nullFunction=function(){};
goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a};};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED$1;goog.TRANSPILE="detect";
goog.ASSUME_ES_MODULES_TRANSPILED=!1;goog.TRANSPILE_TO_LANGUAGE="";goog.TRANSPILER="transpile.js";goog.hasBadLetScoping=null;goog.useSafari10Workaround=function(){if(null==goog.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');}catch(b){a=!1;}goog.hasBadLetScoping=a;}return goog.hasBadLetScoping};goog.workaroundSafari10EvalBug=function(a){return "(function(){"+a+"\n;})();\n"};
goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:"",declareLegacyNamespace:!1,type:goog.ModuleType.GOOG};if(goog.isFunction(a))var c=a.call(void 0,{});else if(goog.isString(a))goog.useSafari10Workaround()&&(a=goog.workaroundSafari10EvalBug(a)),c=goog.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;if(goog.isString(d)&&d)goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,
c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c),goog.loadedModules_[d]={exports:c,type:goog.ModuleType.GOOG,moduleId:goog.moduleLoaderState_.moduleName};else throw Error('Invalid module name "'+d+'"');}finally{goog.moduleLoaderState_=b;}};goog.loadModuleFromSource_=function(a){eval(a);return {}};goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
goog.transpile_=function(a,b,c){var d=goog.global.$jscomp;d||(goog.global.$jscomp=d={});var e=d.transpile;if(!e){var f=goog.basePath+goog.TRANSPILER,g=goog.loadFileSync_(f);if(g){(function(){(0, eval)(g+"\n//# sourceURL="+f);}).call(goog.global);if(goog.global.$gwtExport&&goog.global.$gwtExport.$jscomp&&!goog.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog.global.$gwtExport));goog.global.$jscomp.transpile=
goog.global.$gwtExport.$jscomp.transpile;d=goog.global.$jscomp;e=d.transpile;}}e||(e=d.transpile=function(a,b){goog.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return e(a,b,c)};
goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return "array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return "object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return "array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return "function"}else return "null";
else if("function"==b&&"undefined"==typeof a.call)return "object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return "array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return "array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isFunction=function(a){return "function"==goog.typeOf(a)};
goog.isObject=function(a){var b=typeof a;return "object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return !!a[goog.UID_PROPERTY_]};goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_];}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;
goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if("function"===typeof a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c];};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return +new Date};
goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_){try{goog.global.eval("var _evalTest_ = 1;");}catch(d){}if("undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_;}catch(d){}goog.evalWorksForGlobals_=!0;}else goog.evalWorksForGlobals_=!1;}if(goog.evalWorksForGlobals_)goog.global.eval(a);else {var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=
!1;c.appendChild(b.createTextNode(a));b.head.appendChild(c);b.head.removeChild(c);}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;
goog.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog.global.CLOSURE_CSS_NAME_MAP_FN?goog.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b;};goog.getMsg=function(a,b,c){c&&c.html&&(a=a.replace(/</g,"&lt;"));b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,c){return null!=b&&c in b?b[c]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c);};
goog.exportProperty=function(a,b,c){a[b]=c;};goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)};};
goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}if("string"!=typeof b&&"symbol"!=typeof b)throw Error("method names provided to goog.base must be a string or a symbol");
e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor.prototype;g;g=Object.getPrototypeOf(g))if(g[b]===d)f=!0;else if(f)return g[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){if(goog.isInModuleLoader_())throw Error("goog.scope is not supported within a module.");a.call(goog.global);};
goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};
goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;goog.defineClass.createSealingConstructor_=function(a,b){if(!goog.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);};
goog.tagUnsealableClass=function(a){};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
goog.TRUSTED_TYPES_POLICY_NAME="";goog.identity_=function(a){return a};goog.createTrustedTypesPolicy=function(a){var b=null;if("undefined"===typeof TrustedTypes||!TrustedTypes.createPolicy)return b;try{b=TrustedTypes.createPolicy(a,{createHTML:goog.identity_,createScript:goog.identity_,createScriptURL:goog.identity_,createURL:goog.identity_});}catch(c){goog.logToConsole_(c.message);}return b};
goog.TRUSTED_TYPES_POLICY_=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#base"):null;var jspb={BinaryConstants:{},ConstBinaryMessage:function(){},BinaryMessage:function(){}};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else {var b=Error().stack;b&&(this.stack=b);}a&&(this.message=String(a));this.reportErrorToServer=!0;};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){goog.debug.Error.call(this,goog.asserts.subs_(a,b));this.messagePattern=a;};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
goog.asserts.subs_=function(a,b){a=a.split("%s");for(var c="",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:"%s");return c+a[d]};goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d;}else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a);};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a);};
goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertExists=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&null==a&&goog.asserts.doAssertFailure_("Expected to exist: %s.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)));};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertFinite=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||"number"==typeof a&&isFinite(a)||goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.");};goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=2012<goog.FEATURESET_YEAR;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};
goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return -1};
goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c);}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a);};goog.array.forEachRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;--d)d in e&&b.call(c,e[d],d,a);};
goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k);}return e};
goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return !0;return !1};
goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return !1;return !0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d;},c);return d};
goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return -1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
goog.array.findIndexRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return -1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0;};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b);};
goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b);};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b);};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d);};goog.array.remove=function(a,b){b=goog.array.indexOf(a,b);var c;(c=0<=b)&&goog.array.removeAt(a,b);return c};
goog.array.removeLast=function(a,b){b=goog.array.lastIndexOf(a,b);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++;});return d};
goog.array.concat=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.join=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return []};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g];}else a.push(d);}};
goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;d={};for(var e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g);}b.length=e;};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1;var l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l);}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare);};goog.array.stableSort=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]={index:d,value:a[d]};var e=b||goog.array.defaultCompare;goog.array.sort(c,function(a,b){return e(a.value,b.value)||a.index-b.index});for(d=0;d<a.length;d++)a[d]=c[d].value;};
goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))});};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c);};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return !1}return !0};
goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return !1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return !1;return !0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
goog.array.inverseDefaultCompare=function(a,b){return -goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f);}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e;});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return [];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192){var f=goog.array.slice(d,e,e+8192);f=goog.array.flatten.apply(null,f);for(var g=0;g<f.length;g++)b.push(f[g]);}else b.push(d);}return b};
goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0]);};
goog.array.zip=function(a){if(!arguments.length)return [];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e);}return b};goog.array.shuffle=function(a,b){b=b||Math.random;for(var c=a.length-1;0<c;c--){var d=Math.floor(b()*(c+1)),e=a[c];a[c]=a[d];a[d]=e;}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b]);});return c};
goog.array.concatMap=function(a,b,c){return goog.array.concat.apply([],goog.array.map(a,b,c))};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);255<e&&(b[c++]=e&255,e>>=8);b[c++]=e;}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192){var d=goog.array.slice(a,c,c+8192);b+=String.fromCharCode.apply(null,d);}return b};
goog.crypt.byteArrayToHex=function(a,b){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join(b||"")};goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128);}return b};
goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63);}else if(239<e&&365>e){f=a[c++];var g=a[c++],h=a[c++];e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023));}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63);}return b.join("")};
goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.string={};goog.string.internal={};goog.string.internal.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.internal.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.internal.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(0,b.length))};goog.string.internal.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};
goog.string.internal.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.internal.isEmptyOrWhitespace=function(a){return /^[\s\xa0]*$/.test(a)};goog.string.internal.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};goog.string.internal.caseInsensitiveCompare=function(a,b){a=String(a).toLowerCase();b=String(b).toLowerCase();return a<b?-1:a==b?0:1};
goog.string.internal.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
goog.string.internal.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.internal.AMP_RE_,"&amp;").replace(goog.string.internal.LT_RE_,"&lt;").replace(goog.string.internal.GT_RE_,"&gt;").replace(goog.string.internal.QUOT_RE_,"&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.internal.NULL_RE_,"&#0;");else {if(!goog.string.internal.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.internal.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.internal.LT_RE_,
"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.internal.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.internal.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.internal.NULL_RE_,"&#0;"));}return a};goog.string.internal.AMP_RE_=/&/g;goog.string.internal.LT_RE_=/</g;goog.string.internal.GT_RE_=/>/g;goog.string.internal.QUOT_RE_=/"/g;goog.string.internal.SINGLE_QUOTE_RE_=/'/g;
goog.string.internal.NULL_RE_=/\x00/g;goog.string.internal.ALL_RE_=/[\x00&<>"']/;goog.string.internal.whitespaceEscape=function(a,b){return goog.string.internal.newLineToBr(a.replace(/  /g," &#160;"),b)};goog.string.internal.contains=function(a,b){return -1!=a.indexOf(b)};goog.string.internal.caseInsensitiveContains=function(a,b){return goog.string.internal.contains(a.toLowerCase(),b.toLowerCase())};
goog.string.internal.compareVersions=function(a,b){var c=0;a=goog.string.internal.trim(String(a)).split(".");b=goog.string.internal.trim(String(b)).split(".");for(var d=Math.max(a.length,b.length),e=0;0==c&&e<d;e++){var f=a[e]||"",g=b[e]||"";do{f=/(\d*)(\D*)(.*)/.exec(f)||["","","",""];g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];if(0==f[0].length&&0==g[0].length)break;c=0==f[1].length?0:parseInt(f[1],10);var h=0==g[1].length?0:parseInt(g[1],10);c=goog.string.internal.compareElements_(c,h)||goog.string.internal.compareElements_(0==
f[2].length,0==g[2].length)||goog.string.internal.compareElements_(f[2],g[2]);f=f[3];g=g[3];}while(0==c)}return c};goog.string.internal.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.TypedString=function(){};goog.string.Const=function(a,b){this.stringConstValueWithSecurityContract__googStringSecurityPrivate_=a===goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_&&b||"";this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_=goog.string.Const.TYPE_MARKER_;};goog.string.Const.prototype.implementsGoogStringTypedString=!0;goog.string.Const.prototype.getTypedStringValue=function(){return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_};
goog.string.Const.prototype.toString=function(){return "Const{"+this.stringConstValueWithSecurityContract__googStringSecurityPrivate_+"}"};goog.string.Const.unwrap=function(a){if(a instanceof goog.string.Const&&a.constructor===goog.string.Const&&a.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_===goog.string.Const.TYPE_MARKER_)return a.stringConstValueWithSecurityContract__googStringSecurityPrivate_;goog.asserts.fail("expected object of type Const, got '"+a+"'");return "type_error:Const"};
goog.string.Const.from=function(a){return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_,a)};goog.string.Const.TYPE_MARKER_={};goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_={};goog.string.Const.EMPTY=goog.string.Const.from("");goog.fs={};goog.fs.url={};goog.fs.url.createObjectUrl=function(a){return goog.fs.url.getUrlObject_().createObjectURL(a)};goog.fs.url.revokeObjectUrl=function(a){goog.fs.url.getUrlObject_().revokeObjectURL(a);};goog.fs.url.getUrlObject_=function(){var a=goog.fs.url.findUrlObject_();if(null!=a)return a;throw Error("This browser doesn't seem to support blob URLs");};
goog.fs.url.findUrlObject_=function(){return goog.isDef(goog.global.URL)&&goog.isDef(goog.global.URL.createObjectURL)?goog.global.URL:goog.isDef(goog.global.webkitURL)&&goog.isDef(goog.global.webkitURL.createObjectURL)?goog.global.webkitURL:goog.isDef(goog.global.createObjectURL)?goog.global:null};goog.fs.url.browserSupportsObjectUrls=function(){return null!=goog.fs.url.findUrlObject_()};goog.html={};goog.html.trustedtypes={};goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#html"):null;goog.i18n={};goog.i18n.bidi={};goog.i18n.bidi.FORCE_RTL=!1;
goog.i18n.bidi.IS_RTL=goog.i18n.bidi.FORCE_RTL||("ar"==goog.LOCALE.substring(0,2).toLowerCase()||"fa"==goog.LOCALE.substring(0,2).toLowerCase()||"he"==goog.LOCALE.substring(0,2).toLowerCase()||"iw"==goog.LOCALE.substring(0,2).toLowerCase()||"ps"==goog.LOCALE.substring(0,2).toLowerCase()||"sd"==goog.LOCALE.substring(0,2).toLowerCase()||"ug"==goog.LOCALE.substring(0,2).toLowerCase()||"ur"==goog.LOCALE.substring(0,2).toLowerCase()||"yi"==goog.LOCALE.substring(0,2).toLowerCase())&&(2==goog.LOCALE.length||
"-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))||3<=goog.LOCALE.length&&"ckb"==goog.LOCALE.substring(0,3).toLowerCase()&&(3==goog.LOCALE.length||"-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))||7<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))&&("adlm"==goog.LOCALE.substring(3,7).toLowerCase()||"arab"==goog.LOCALE.substring(3,7).toLowerCase()||"hebr"==goog.LOCALE.substring(3,7).toLowerCase()||"nkoo"==goog.LOCALE.substring(3,
7).toLowerCase()||"rohg"==goog.LOCALE.substring(3,7).toLowerCase()||"thaa"==goog.LOCALE.substring(3,7).toLowerCase())||8<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))&&("adlm"==goog.LOCALE.substring(4,8).toLowerCase()||"arab"==goog.LOCALE.substring(4,8).toLowerCase()||"hebr"==goog.LOCALE.substring(4,8).toLowerCase()||"nkoo"==goog.LOCALE.substring(4,8).toLowerCase()||"rohg"==goog.LOCALE.substring(4,8).toLowerCase()||"thaa"==goog.LOCALE.substring(4,8).toLowerCase());
goog.i18n.bidi.Format={LRE:"\u202a",RLE:"\u202b",PDF:"\u202c",LRM:"\u200e",RLM:"\u200f"};goog.i18n.bidi.Dir={LTR:1,RTL:-1,NEUTRAL:0};goog.i18n.bidi.RIGHT="right";goog.i18n.bidi.LEFT="left";goog.i18n.bidi.I18N_RIGHT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.LEFT:goog.i18n.bidi.RIGHT;goog.i18n.bidi.I18N_LEFT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT;
goog.i18n.bidi.toDir=function(a,b){return "number"==typeof a?0<a?goog.i18n.bidi.Dir.LTR:0>a?goog.i18n.bidi.Dir.RTL:b?null:goog.i18n.bidi.Dir.NEUTRAL:null==a?null:a?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};goog.i18n.bidi.ltrChars_="A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";goog.i18n.bidi.rtlChars_="\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b\ufb1d-\ufdff\ufe70-\ufefc";
goog.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g;goog.i18n.bidi.stripHtmlIfNeeded_=function(a,b){return b?a.replace(goog.i18n.bidi.htmlSkipReg_,""):a};goog.i18n.bidi.rtlCharReg_=new RegExp("["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.ltrCharReg_=new RegExp("["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.hasAnyRtl=function(a,b){return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.hasRtlChar=goog.i18n.bidi.hasAnyRtl;
goog.i18n.bidi.hasAnyLtr=function(a,b){return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.ltrRe_=new RegExp("^["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlRe_=new RegExp("^["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.isRtlChar=function(a){return goog.i18n.bidi.rtlRe_.test(a)};goog.i18n.bidi.isLtrChar=function(a){return goog.i18n.bidi.ltrRe_.test(a)};goog.i18n.bidi.isNeutralChar=function(a){return !goog.i18n.bidi.isLtrChar(a)&&!goog.i18n.bidi.isRtlChar(a)};
goog.i18n.bidi.ltrDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.rtlChars_+"]*["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.ltrChars_+"]*["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.startsWithRtl=function(a,b){return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlText=goog.i18n.bidi.startsWithRtl;
goog.i18n.bidi.startsWithLtr=function(a,b){return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrText=goog.i18n.bidi.startsWithLtr;goog.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/;goog.i18n.bidi.isNeutralText=function(a,b){a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b);return goog.i18n.bidi.isRequiredLtrRe_.test(a)||!goog.i18n.bidi.hasAnyLtr(a)&&!goog.i18n.bidi.hasAnyRtl(a)};
goog.i18n.bidi.ltrExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.ltrChars_+"][^"+goog.i18n.bidi.rtlChars_+"]*$");goog.i18n.bidi.rtlExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.rtlChars_+"][^"+goog.i18n.bidi.ltrChars_+"]*$");goog.i18n.bidi.endsWithLtr=function(a,b){return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrExitText=goog.i18n.bidi.endsWithLtr;
goog.i18n.bidi.endsWithRtl=function(a,b){return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlExitText=goog.i18n.bidi.endsWithRtl;goog.i18n.bidi.rtlLocalesRe_=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;goog.i18n.bidi.isRtlLanguage=function(a){return goog.i18n.bidi.rtlLocalesRe_.test(a)};goog.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
goog.i18n.bidi.guardBracketInText=function(a,b){b=(void 0===b?goog.i18n.bidi.hasAnyRtl(a):b)?goog.i18n.bidi.Format.RLM:goog.i18n.bidi.Format.LRM;return a.replace(goog.i18n.bidi.bracketGuardTextRe_,b+"$&"+b)};goog.i18n.bidi.enforceRtlInHtml=function(a){return "<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=rtl"):"\n<span dir=rtl>"+a+"</span>"};goog.i18n.bidi.enforceRtlInText=function(a){return goog.i18n.bidi.Format.RLE+a+goog.i18n.bidi.Format.PDF};
goog.i18n.bidi.enforceLtrInHtml=function(a){return "<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=ltr"):"\n<span dir=ltr>"+a+"</span>"};goog.i18n.bidi.enforceLtrInText=function(a){return goog.i18n.bidi.Format.LRE+a+goog.i18n.bidi.Format.PDF};goog.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;goog.i18n.bidi.leftRe_=/left/gi;goog.i18n.bidi.rightRe_=/right/gi;goog.i18n.bidi.tempRe_=/%%%%/g;
goog.i18n.bidi.mirrorCSS=function(a){return a.replace(goog.i18n.bidi.dimensionsRe_,":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_,"%%%%").replace(goog.i18n.bidi.rightRe_,goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_,goog.i18n.bidi.RIGHT)};goog.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g;goog.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g;
goog.i18n.bidi.normalizeHebrewQuote=function(a){return a.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_,"$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_,"$1\u05f3")};goog.i18n.bidi.wordSeparatorRe_=/\s+/;goog.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/;goog.i18n.bidi.rtlDetectionThreshold_=.4;
goog.i18n.bidi.estimateDirection=function(a,b){var c=0,d=0,e=!1;a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b).split(goog.i18n.bidi.wordSeparatorRe_);for(b=0;b<a.length;b++){var f=a[b];goog.i18n.bidi.startsWithRtl(f)?(c++,d++):goog.i18n.bidi.isRequiredLtrRe_.test(f)?e=!0:goog.i18n.bidi.hasAnyLtr(f)?d++:goog.i18n.bidi.hasNumeralsRe_.test(f)&&(e=!0);}return 0==d?e?goog.i18n.bidi.Dir.LTR:goog.i18n.bidi.Dir.NEUTRAL:c/d>goog.i18n.bidi.rtlDetectionThreshold_?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};
goog.i18n.bidi.detectRtlDirectionality=function(a,b){return goog.i18n.bidi.estimateDirection(a,b)==goog.i18n.bidi.Dir.RTL};goog.i18n.bidi.setElementDirAndAlign=function(a,b){a&&(b=goog.i18n.bidi.toDir(b))&&(a.style.textAlign=b==goog.i18n.bidi.Dir.RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT,a.dir=b==goog.i18n.bidi.Dir.RTL?"rtl":"ltr");};
goog.i18n.bidi.setElementDirByTextDirectionality=function(a,b){switch(goog.i18n.bidi.estimateDirection(b)){case goog.i18n.bidi.Dir.LTR:a.dir="ltr";break;case goog.i18n.bidi.Dir.RTL:a.dir="rtl";break;default:a.removeAttribute("dir");}};goog.i18n.bidi.DirectionalString=function(){};goog.html.TrustedResourceUrl=function(){this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_="";this.trustedURL_=null;this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString=!0;goog.html.TrustedResourceUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString()};
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.TrustedResourceUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};
goog.html.TrustedResourceUrl.prototype.cloneWithParams=function(a,b){var c=goog.html.TrustedResourceUrl.unwrap(this);c=goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c);var d=c[3]||"";return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c[1]+goog.html.TrustedResourceUrl.stringifyParams_("?",c[2]||"",a)+goog.html.TrustedResourceUrl.stringifyParams_("#",d,b))};
goog.DEBUG&&(goog.html.TrustedResourceUrl.prototype.toString=function(){return "TrustedResourceUrl{"+this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_+"}"});goog.html.TrustedResourceUrl.unwrap=function(a){return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(a).toString()};
goog.html.TrustedResourceUrl.unwrapTrustedScriptURL=function(a){if(a instanceof goog.html.TrustedResourceUrl&&a.constructor===goog.html.TrustedResourceUrl&&a.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;goog.asserts.fail("expected object of type TrustedResourceUrl, got '"+a+"' of type "+goog.typeOf(a));return "type_error:TrustedResourceUrl"};
goog.html.TrustedResourceUrl.unwrapTrustedURL=function(a){return a.trustedURL_?a.trustedURL_:goog.html.TrustedResourceUrl.unwrap(a)};
goog.html.TrustedResourceUrl.format=function(a,b){var c=goog.string.Const.unwrap(a);if(!goog.html.TrustedResourceUrl.BASE_URL_.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof goog.string.Const?goog.string.Const.unwrap(a):
encodeURIComponent(String(a))});return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.TrustedResourceUrl.FORMAT_MARKER_=/%{(\w+)}/g;goog.html.TrustedResourceUrl.BASE_URL_=/^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;goog.html.TrustedResourceUrl.URL_PARAM_PARSER_=/^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
goog.html.TrustedResourceUrl.formatWithParams=function(a,b,c,d){return goog.html.TrustedResourceUrl.format(a,b).cloneWithParams(c,d)};goog.html.TrustedResourceUrl.fromConstant=function(a){return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};goog.html.TrustedResourceUrl.fromConstants=function(a){for(var b="",c=0;c<a.length;c++)b+=goog.string.Const.unwrap(a[c]);return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.TrustedResourceUrl;b.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a):a;goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY&&(b.trustedURL_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a));return b};
goog.html.TrustedResourceUrl.stringifyParams_=function(a,b,c){if(null==c)return b;if(goog.isString(c))return c?a+encodeURIComponent(c):"";for(var d in c){var e=c[d];e=goog.isArray(e)?e:[e];for(var f=0;f<e.length;f++){var g=e[f];null!=g&&(b||(b=a),b+=(b.length>a.length?"&":"")+encodeURIComponent(d)+"="+encodeURIComponent(String(g)));}}return b};goog.html.SafeUrl=function(){this.privateDoNotAccessOrElseSafeUrlWrappedValue_="";this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeUrl.INNOCUOUS_STRING="about:invalid#zClosurez";goog.html.SafeUrl.prototype.implementsGoogStringTypedString=!0;goog.html.SafeUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString()};
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};goog.DEBUG&&(goog.html.SafeUrl.prototype.toString=function(){return "SafeUrl{"+this.privateDoNotAccessOrElseSafeUrlWrappedValue_+"}"});goog.html.SafeUrl.unwrap=function(a){return goog.html.SafeUrl.unwrapTrustedURL(a).toString()};
goog.html.SafeUrl.unwrapTrustedURL=function(a){if(a instanceof goog.html.SafeUrl&&a.constructor===goog.html.SafeUrl&&a.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeUrlWrappedValue_;goog.asserts.fail("expected object of type SafeUrl, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeUrl"};goog.html.SafeUrl.fromConstant=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};
goog.html.SAFE_MIME_TYPE_PATTERN_=/^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i;goog.html.SafeUrl.isSafeMimeType=function(a){return goog.html.SAFE_MIME_TYPE_PATTERN_.test(a)};goog.html.SafeUrl.fromBlob=function(a){a=goog.html.SAFE_MIME_TYPE_PATTERN_.test(a.type)?goog.fs.url.createObjectUrl(a):goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.DATA_URL_PATTERN_=/^data:([^,]*);base64,[a-z0-9+\/]+=*$/i;goog.html.SafeUrl.fromDataUrl=function(a){a=a.replace(/(%0A|%0D)/g,"");var b=a.match(goog.html.DATA_URL_PATTERN_);b=b&&goog.html.SAFE_MIME_TYPE_PATTERN_.test(b[1]);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b?a:goog.html.SafeUrl.INNOCUOUS_STRING)};goog.html.SafeUrl.fromTelUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"tel:")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SIP_URL_PATTERN_=/^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;goog.html.SafeUrl.fromSipUrl=function(a){goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(a))||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromFacebookMessengerUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"fb-messenger://share")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.fromWhatsAppUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"whatsapp://send")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromSmsUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"sms:")&&goog.html.SafeUrl.isSmsUrlBodyValid_(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.isSmsUrlBodyValid_=function(a){var b=a.indexOf("#");0<b&&(a=a.substring(0,b));b=a.match(/[?&]body=/gi);if(!b)return !0;if(1<b.length)return !1;a=a.match(/[?&]body=([^&]*)/)[1];if(!a)return !0;try{decodeURIComponent(a);}catch(c){return !1}return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a)};goog.html.SafeUrl.fromSshUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"ssh://")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeChromeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeFirefoxExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeEdgeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//,a,b)};
goog.html.SafeUrl.sanitizeExtensionUrl_=function(a,b,c){(a=a.exec(b))?(a=a[1],-1==(c instanceof goog.string.Const?[goog.string.Const.unwrap(c)]:c.map(function(a){return goog.string.Const.unwrap(a)})).indexOf(a)&&(b=goog.html.SafeUrl.INNOCUOUS_STRING)):b=goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};goog.html.SafeUrl.fromTrustedResourceUrl=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(a))};
goog.html.SAFE_URL_PATTERN_=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;goog.html.SafeUrl.SAFE_URL_PATTERN=goog.html.SAFE_URL_PATTERN_;goog.html.SafeUrl.sanitize=function(a){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);goog.html.SAFE_URL_PATTERN_.test(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeAssertUnchanged=function(a,b){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);if(b&&/^data:/i.test(a)&&(b=goog.html.SafeUrl.fromDataUrl(a),b.getTypedStringValue()==a))return b;goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(a),"%s does not match the safe URL pattern",a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.SafeUrl;b.privateDoNotAccessOrElseSafeUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a):a;return b};goog.html.SafeUrl.ABOUT_BLANK=goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");goog.html.SafeStyle=function(){this.privateDoNotAccessOrElseSafeStyleWrappedValue_="";this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeStyle.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyle.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyle.EMPTY;goog.asserts.assert(goog.string.internal.endsWith(a,";"),"Last character of style string is not ';': "+a);goog.asserts.assert(goog.string.internal.contains(a,":"),"Style string must contain at least one ':', to specify a \"name: value\" pair: "+a);return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeStyle.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleWrappedValue_};goog.DEBUG&&(goog.html.SafeStyle.prototype.toString=function(){return "SafeStyle{"+this.privateDoNotAccessOrElseSafeStyleWrappedValue_+"}"});
goog.html.SafeStyle.unwrap=function(a){if(a instanceof goog.html.SafeStyle&&a.constructor===goog.html.SafeStyle&&a.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleWrappedValue_;goog.asserts.fail("expected object of type SafeStyle, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeStyle"};goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse=function(a){return (new goog.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleWrappedValue_=a;return this};goog.html.SafeStyle.EMPTY=goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");goog.html.SafeStyle.INNOCUOUS_STRING="zClosurez";
goog.html.SafeStyle.create=function(a){var b="",c;for(c in a){if(!/^[-_a-zA-Z0-9]+$/.test(c))throw Error("Name allows only [-_a-zA-Z0-9], got: "+c);var d=a[c];null!=d&&(d=goog.isArray(d)?goog.array.map(d,goog.html.SafeStyle.sanitizePropertyValue_).join(" "):goog.html.SafeStyle.sanitizePropertyValue_(d),b+=c+":"+d+";");}return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};
goog.html.SafeStyle.sanitizePropertyValue_=function(a){if(a instanceof goog.html.SafeUrl)return 'url("'+goog.html.SafeUrl.unwrap(a).replace(/</g,"%3c").replace(/[\\"]/g,"\\$&")+'")';a=a instanceof goog.string.Const?goog.string.Const.unwrap(a):goog.html.SafeStyle.sanitizePropertyValueString_(String(a));if(/[{;}]/.test(a))throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.",[a]);return a};
goog.html.SafeStyle.sanitizePropertyValueString_=function(a){var b=a.replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.URL_RE_,"url");if(goog.html.SafeStyle.VALUE_RE_.test(b)){if(goog.html.SafeStyle.COMMENT_RE_.test(a))return goog.asserts.fail("String value disallows comments, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedQuotes_(a))return goog.asserts.fail("String value requires balanced quotes, got: "+
a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedSquareBrackets_(a))return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING}else return goog.asserts.fail("String value allows only "+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+" and simple functions, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;return goog.html.SafeStyle.sanitizeUrl_(a)};
goog.html.SafeStyle.hasBalancedQuotes_=function(a){for(var b=!0,c=!0,d=0;d<a.length;d++){var e=a.charAt(d);"'"==e&&c?b=!b:'"'==e&&b&&(c=!c);}return b&&c};goog.html.SafeStyle.hasBalancedSquareBrackets_=function(a){for(var b=!0,c=/^[-_a-zA-Z0-9]$/,d=0;d<a.length;d++){var e=a.charAt(d);if("]"==e){if(b)return !1;b=!0;}else if("["==e){if(!b)return !1;b=!1;}else if(!b&&!c.test(e))return !1}return b};goog.html.SafeStyle.VALUE_ALLOWED_CHARS_="[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
goog.html.SafeStyle.VALUE_RE_=new RegExp("^"+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+"+$");goog.html.SafeStyle.URL_RE_=/\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;goog.html.SafeStyle.FUNCTIONS_RE_=/\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g;goog.html.SafeStyle.COMMENT_RE_=/\/\*/;
goog.html.SafeStyle.sanitizeUrl_=function(a){return a.replace(goog.html.SafeStyle.URL_RE_,function(a,c,d,e){var b="";d=d.replace(/^(['"])(.*)\1$/,function(a,c,d){b=c;return d});a=goog.html.SafeUrl.sanitize(d).getTypedStringValue();return c+b+a+b+e})};goog.html.SafeStyle.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyle.unwrap(a);};goog.array.forEach(arguments,c);return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};goog.html.SafeScript=function(){this.privateDoNotAccessOrElseSafeScriptWrappedValue_="";this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeScript.prototype.implementsGoogStringTypedString=!0;goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeScript.fromConstant=function(a){a=goog.string.Const.unwrap(a);return 0===a.length?goog.html.SafeScript.EMPTY:goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeScript.fromConstantAndArgs=function(a,b){for(var c=[],d=1;d<arguments.length;d++)c.push(goog.html.SafeScript.stringify_(arguments[d]));return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("("+goog.string.Const.unwrap(a)+")("+c.join(", ")+");")};goog.html.SafeScript.fromJson=function(a){return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(a))};goog.html.SafeScript.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeScript.prototype.toString=function(){return "SafeScript{"+this.privateDoNotAccessOrElseSafeScriptWrappedValue_+"}"});goog.html.SafeScript.unwrap=function(a){return goog.html.SafeScript.unwrapTrustedScript(a).toString()};
goog.html.SafeScript.unwrapTrustedScript=function(a){if(a instanceof goog.html.SafeScript&&a.constructor===goog.html.SafeScript&&a.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeScriptWrappedValue_;goog.asserts.fail("expected object of type SafeScript, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeScript"};
goog.html.SafeScript.stringify_=function(a){return JSON.stringify(a).replace(/</g,"\\x3c")};goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse=function(a){return (new goog.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeScriptWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a):a;return this};goog.html.SafeScript.EMPTY=goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");goog.object={};goog.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a);};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return !0;return !1};
goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return !1;return !0};goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};
goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};goog.object.getValueByKeys=function(a,b){var c=goog.isArrayLike(b),d=c?b:arguments;for(c=c?0:1;c<d.length;c++){if(null==a)return;a=a[d[c]];}return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return !0;return !1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};
goog.object.findValue=function(a,b,c){return (b=goog.object.findKey(a,b,c))&&a[b]};goog.object.isEmpty=function(a){for(var b in a)return !1;return !0};goog.object.clear=function(a){for(var b in a)delete a[b];};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c);};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};
goog.object.set=function(a,b,c){a[b]=c;};goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return !1;for(var d in b)if(!(d in a))return !1;return !0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}};
goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return !!Object.isFrozen&&Object.isFrozen(a)};
goog.object.getAllPropertyNames=function(a,b,c){if(!a)return [];if(!Object.getOwnPropertyNames||!Object.getPrototypeOf)return goog.object.getKeys(a);for(var d={};a&&(a!==Object.prototype||b)&&(a!==Function.prototype||c);){for(var e=Object.getOwnPropertyNames(a),f=0;f<e.length;f++)d[e[f]]=!0;a=Object.getPrototypeOf(a);}return goog.object.getKeys(d)};goog.object.getSuperClass=function(a){return (a=Object.getPrototypeOf(a.prototype))&&a.constructor};goog.html.SafeStyleSheet=function(){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_="";this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;};goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyleSheet.createRule=function(a,b){if(goog.string.internal.contains(a,"<"))throw Error("Selector does not allow '<', got: "+a);var c=a.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g,"");if(!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c))throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: "+a);if(!goog.html.SafeStyleSheet.hasBalancedBrackets_(c))throw Error("() and [] in selector must be balanced, got: "+a);b instanceof goog.html.SafeStyle||(b=goog.html.SafeStyle.create(b));
a=a+"{"+goog.html.SafeStyle.unwrap(b).replace(/</g,"\\3C ")+"}";return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.hasBalancedBrackets_=function(a){for(var b={"(":")","[":"]"},c=[],d=0;d<a.length;d++){var e=a[d];if(b[e])c.push(b[e]);else if(goog.object.contains(b,e)&&c.pop()!=e)return !1}return 0==c.length};
goog.html.SafeStyleSheet.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyleSheet.unwrap(a);};goog.array.forEach(arguments,c);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.SafeStyleSheet.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyleSheet.EMPTY;goog.asserts.assert(!goog.string.internal.contains(a,"<"),"Forbidden '<' character in style sheet string: "+a);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_};
goog.DEBUG&&(goog.html.SafeStyleSheet.prototype.toString=function(){return "SafeStyleSheet{"+this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_+"}"});
goog.html.SafeStyleSheet.unwrap=function(a){if(a instanceof goog.html.SafeStyleSheet&&a.constructor===goog.html.SafeStyleSheet&&a.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;goog.asserts.fail("expected object of type SafeStyleSheet, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeStyleSheet"};
goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse=function(a){return (new goog.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(a)};goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_=a;return this};goog.html.SafeStyleSheet.EMPTY=goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");goog.dom.tags={};goog.dom.tags.VOID_TAGS_={area:!0,base:!0,br:!0,col:!0,command:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};goog.dom.tags.isVoidTag=function(a){return !0===goog.dom.tags.VOID_TAGS_[a]};goog.dom.HtmlElement=function(){};goog.dom.TagName=function(a){this.tagName_=a;};goog.dom.TagName.prototype.toString=function(){return this.tagName_};goog.dom.TagName.A=new goog.dom.TagName("A");goog.dom.TagName.ABBR=new goog.dom.TagName("ABBR");goog.dom.TagName.ACRONYM=new goog.dom.TagName("ACRONYM");goog.dom.TagName.ADDRESS=new goog.dom.TagName("ADDRESS");goog.dom.TagName.APPLET=new goog.dom.TagName("APPLET");goog.dom.TagName.AREA=new goog.dom.TagName("AREA");goog.dom.TagName.ARTICLE=new goog.dom.TagName("ARTICLE");
goog.dom.TagName.ASIDE=new goog.dom.TagName("ASIDE");goog.dom.TagName.AUDIO=new goog.dom.TagName("AUDIO");goog.dom.TagName.B=new goog.dom.TagName("B");goog.dom.TagName.BASE=new goog.dom.TagName("BASE");goog.dom.TagName.BASEFONT=new goog.dom.TagName("BASEFONT");goog.dom.TagName.BDI=new goog.dom.TagName("BDI");goog.dom.TagName.BDO=new goog.dom.TagName("BDO");goog.dom.TagName.BIG=new goog.dom.TagName("BIG");goog.dom.TagName.BLOCKQUOTE=new goog.dom.TagName("BLOCKQUOTE");goog.dom.TagName.BODY=new goog.dom.TagName("BODY");
goog.dom.TagName.BR=new goog.dom.TagName("BR");goog.dom.TagName.BUTTON=new goog.dom.TagName("BUTTON");goog.dom.TagName.CANVAS=new goog.dom.TagName("CANVAS");goog.dom.TagName.CAPTION=new goog.dom.TagName("CAPTION");goog.dom.TagName.CENTER=new goog.dom.TagName("CENTER");goog.dom.TagName.CITE=new goog.dom.TagName("CITE");goog.dom.TagName.CODE=new goog.dom.TagName("CODE");goog.dom.TagName.COL=new goog.dom.TagName("COL");goog.dom.TagName.COLGROUP=new goog.dom.TagName("COLGROUP");
goog.dom.TagName.COMMAND=new goog.dom.TagName("COMMAND");goog.dom.TagName.DATA=new goog.dom.TagName("DATA");goog.dom.TagName.DATALIST=new goog.dom.TagName("DATALIST");goog.dom.TagName.DD=new goog.dom.TagName("DD");goog.dom.TagName.DEL=new goog.dom.TagName("DEL");goog.dom.TagName.DETAILS=new goog.dom.TagName("DETAILS");goog.dom.TagName.DFN=new goog.dom.TagName("DFN");goog.dom.TagName.DIALOG=new goog.dom.TagName("DIALOG");goog.dom.TagName.DIR=new goog.dom.TagName("DIR");goog.dom.TagName.DIV=new goog.dom.TagName("DIV");
goog.dom.TagName.DL=new goog.dom.TagName("DL");goog.dom.TagName.DT=new goog.dom.TagName("DT");goog.dom.TagName.EM=new goog.dom.TagName("EM");goog.dom.TagName.EMBED=new goog.dom.TagName("EMBED");goog.dom.TagName.FIELDSET=new goog.dom.TagName("FIELDSET");goog.dom.TagName.FIGCAPTION=new goog.dom.TagName("FIGCAPTION");goog.dom.TagName.FIGURE=new goog.dom.TagName("FIGURE");goog.dom.TagName.FONT=new goog.dom.TagName("FONT");goog.dom.TagName.FOOTER=new goog.dom.TagName("FOOTER");goog.dom.TagName.FORM=new goog.dom.TagName("FORM");
goog.dom.TagName.FRAME=new goog.dom.TagName("FRAME");goog.dom.TagName.FRAMESET=new goog.dom.TagName("FRAMESET");goog.dom.TagName.H1=new goog.dom.TagName("H1");goog.dom.TagName.H2=new goog.dom.TagName("H2");goog.dom.TagName.H3=new goog.dom.TagName("H3");goog.dom.TagName.H4=new goog.dom.TagName("H4");goog.dom.TagName.H5=new goog.dom.TagName("H5");goog.dom.TagName.H6=new goog.dom.TagName("H6");goog.dom.TagName.HEAD=new goog.dom.TagName("HEAD");goog.dom.TagName.HEADER=new goog.dom.TagName("HEADER");
goog.dom.TagName.HGROUP=new goog.dom.TagName("HGROUP");goog.dom.TagName.HR=new goog.dom.TagName("HR");goog.dom.TagName.HTML=new goog.dom.TagName("HTML");goog.dom.TagName.I=new goog.dom.TagName("I");goog.dom.TagName.IFRAME=new goog.dom.TagName("IFRAME");goog.dom.TagName.IMG=new goog.dom.TagName("IMG");goog.dom.TagName.INPUT=new goog.dom.TagName("INPUT");goog.dom.TagName.INS=new goog.dom.TagName("INS");goog.dom.TagName.ISINDEX=new goog.dom.TagName("ISINDEX");goog.dom.TagName.KBD=new goog.dom.TagName("KBD");
goog.dom.TagName.KEYGEN=new goog.dom.TagName("KEYGEN");goog.dom.TagName.LABEL=new goog.dom.TagName("LABEL");goog.dom.TagName.LEGEND=new goog.dom.TagName("LEGEND");goog.dom.TagName.LI=new goog.dom.TagName("LI");goog.dom.TagName.LINK=new goog.dom.TagName("LINK");goog.dom.TagName.MAIN=new goog.dom.TagName("MAIN");goog.dom.TagName.MAP=new goog.dom.TagName("MAP");goog.dom.TagName.MARK=new goog.dom.TagName("MARK");goog.dom.TagName.MATH=new goog.dom.TagName("MATH");goog.dom.TagName.MENU=new goog.dom.TagName("MENU");
goog.dom.TagName.MENUITEM=new goog.dom.TagName("MENUITEM");goog.dom.TagName.META=new goog.dom.TagName("META");goog.dom.TagName.METER=new goog.dom.TagName("METER");goog.dom.TagName.NAV=new goog.dom.TagName("NAV");goog.dom.TagName.NOFRAMES=new goog.dom.TagName("NOFRAMES");goog.dom.TagName.NOSCRIPT=new goog.dom.TagName("NOSCRIPT");goog.dom.TagName.OBJECT=new goog.dom.TagName("OBJECT");goog.dom.TagName.OL=new goog.dom.TagName("OL");goog.dom.TagName.OPTGROUP=new goog.dom.TagName("OPTGROUP");
goog.dom.TagName.OPTION=new goog.dom.TagName("OPTION");goog.dom.TagName.OUTPUT=new goog.dom.TagName("OUTPUT");goog.dom.TagName.P=new goog.dom.TagName("P");goog.dom.TagName.PARAM=new goog.dom.TagName("PARAM");goog.dom.TagName.PICTURE=new goog.dom.TagName("PICTURE");goog.dom.TagName.PRE=new goog.dom.TagName("PRE");goog.dom.TagName.PROGRESS=new goog.dom.TagName("PROGRESS");goog.dom.TagName.Q=new goog.dom.TagName("Q");goog.dom.TagName.RP=new goog.dom.TagName("RP");goog.dom.TagName.RT=new goog.dom.TagName("RT");
goog.dom.TagName.RTC=new goog.dom.TagName("RTC");goog.dom.TagName.RUBY=new goog.dom.TagName("RUBY");goog.dom.TagName.S=new goog.dom.TagName("S");goog.dom.TagName.SAMP=new goog.dom.TagName("SAMP");goog.dom.TagName.SCRIPT=new goog.dom.TagName("SCRIPT");goog.dom.TagName.SECTION=new goog.dom.TagName("SECTION");goog.dom.TagName.SELECT=new goog.dom.TagName("SELECT");goog.dom.TagName.SMALL=new goog.dom.TagName("SMALL");goog.dom.TagName.SOURCE=new goog.dom.TagName("SOURCE");goog.dom.TagName.SPAN=new goog.dom.TagName("SPAN");
goog.dom.TagName.STRIKE=new goog.dom.TagName("STRIKE");goog.dom.TagName.STRONG=new goog.dom.TagName("STRONG");goog.dom.TagName.STYLE=new goog.dom.TagName("STYLE");goog.dom.TagName.SUB=new goog.dom.TagName("SUB");goog.dom.TagName.SUMMARY=new goog.dom.TagName("SUMMARY");goog.dom.TagName.SUP=new goog.dom.TagName("SUP");goog.dom.TagName.SVG=new goog.dom.TagName("SVG");goog.dom.TagName.TABLE=new goog.dom.TagName("TABLE");goog.dom.TagName.TBODY=new goog.dom.TagName("TBODY");goog.dom.TagName.TD=new goog.dom.TagName("TD");
goog.dom.TagName.TEMPLATE=new goog.dom.TagName("TEMPLATE");goog.dom.TagName.TEXTAREA=new goog.dom.TagName("TEXTAREA");goog.dom.TagName.TFOOT=new goog.dom.TagName("TFOOT");goog.dom.TagName.TH=new goog.dom.TagName("TH");goog.dom.TagName.THEAD=new goog.dom.TagName("THEAD");goog.dom.TagName.TIME=new goog.dom.TagName("TIME");goog.dom.TagName.TITLE=new goog.dom.TagName("TITLE");goog.dom.TagName.TR=new goog.dom.TagName("TR");goog.dom.TagName.TRACK=new goog.dom.TagName("TRACK");goog.dom.TagName.TT=new goog.dom.TagName("TT");
goog.dom.TagName.U=new goog.dom.TagName("U");goog.dom.TagName.UL=new goog.dom.TagName("UL");goog.dom.TagName.VAR=new goog.dom.TagName("VAR");goog.dom.TagName.VIDEO=new goog.dom.TagName("VIDEO");goog.dom.TagName.WBR=new goog.dom.TagName("WBR");goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_();};
goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.caseInsensitiveContains(b,a)};
goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=/(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g,c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdgeHtml_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchEdgeChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("Edg/")};
goog.labs.userAgent.browser.matchOperaChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")||goog.labs.userAgent.util.matchUserAgent("FxiOS")};
goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdgeHtml_()||goog.labs.userAgent.browser.matchEdgeChromium_()||goog.labs.userAgent.browser.matchOperaChromium_()||goog.labs.userAgent.browser.matchFirefox_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};
goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};goog.labs.userAgent.browser.matchIosWebview_=function(){return (goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&!goog.labs.userAgent.browser.matchFirefox_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
goog.labs.userAgent.browser.matchChrome_=function(){return (goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchEdgeHtml_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdgeHtml_;goog.labs.userAgent.browser.isEdgeChromium=goog.labs.userAgent.browser.matchEdgeChromium_;goog.labs.userAgent.browser.isOperaChromium=goog.labs.userAgent.browser.matchOperaChromium_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;
goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);b=goog.labs.userAgent.util.extractVersionTuples(b);var c={};goog.array.forEach(b,function(a){c[a[0]]=a[1];});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera"]):goog.labs.userAgent.browser.isEdge()?a(["Edge"]):
goog.labs.userAgent.browser.isEdgeChromium()?a(["Edg"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];b="";var c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0";}else b="7.0";else b=c[1];return b};goog.html.SafeHtml=function(){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_="";this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;this.dir_=null;};goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeHtml.prototype.getDirection=function(){return this.dir_};goog.html.SafeHtml.prototype.implementsGoogStringTypedString=!0;goog.html.SafeHtml.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeHtml.prototype.toString=function(){return "SafeHtml{"+this.privateDoNotAccessOrElseSafeHtmlWrappedValue_+"}"});goog.html.SafeHtml.unwrap=function(a){return goog.html.SafeHtml.unwrapTrustedHTML(a).toString()};
goog.html.SafeHtml.unwrapTrustedHTML=function(a){if(a instanceof goog.html.SafeHtml&&a.constructor===goog.html.SafeHtml&&a.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeHtmlWrappedValue_;goog.asserts.fail("expected object of type SafeHtml, got '"+a+"' of type "+goog.typeOf(a));return "type_error:SafeHtml"};
goog.html.SafeHtml.htmlEscape=function(a){if(a instanceof goog.html.SafeHtml)return a;var b="object"==typeof a,c=null;b&&a.implementsGoogI18nBidiDirectionalString&&(c=a.getDirection());a=b&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(a),c)};
goog.html.SafeHtml.htmlEscapePreservingNewlines=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(a)),a.getDirection())};
goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(a)),a.getDirection())};goog.html.SafeHtml.from=goog.html.SafeHtml.htmlEscape;goog.html.SafeHtml.VALID_NAMES_IN_TAG_=/^[a-zA-Z0-9-]+$/;
goog.html.SafeHtml.URL_ATTRIBUTES_={action:!0,cite:!0,data:!0,formaction:!0,href:!0,manifest:!0,poster:!0,src:!0};goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_={APPLET:!0,BASE:!0,EMBED:!0,IFRAME:!0,LINK:!0,MATH:!0,META:!0,OBJECT:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};goog.html.SafeHtml.create=function(a,b,c){goog.html.SafeHtml.verifyTagName(String(a));return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a),b,c)};
goog.html.SafeHtml.verifyTagName=function(a){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a))throw Error("Invalid tag name <"+a+">.");if(a.toUpperCase()in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)throw Error("Tag name <"+a+"> is not allowed for SafeHtml.");};
goog.html.SafeHtml.createIframe=function(a,b,c,d){a&&goog.html.TrustedResourceUrl.unwrap(a);var e={};e.src=a||null;e.srcdoc=b&&goog.html.SafeHtml.unwrap(b);a=goog.html.SafeHtml.combineAttributes(e,{sandbox:""},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.createSandboxIframe=function(a,b,c,d){if(!goog.html.SafeHtml.canUseSandboxIframe())throw Error("The browser does not support sandboxed iframes.");var e={};e.src=a?goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a)):null;e.srcdoc=b||null;e.sandbox="";a=goog.html.SafeHtml.combineAttributes(e,{},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.canUseSandboxIframe=function(){return goog.global.HTMLIFrameElement&&"sandbox"in goog.global.HTMLIFrameElement.prototype};goog.html.SafeHtml.createScriptSrc=function(a,b){goog.html.TrustedResourceUrl.unwrap(a);a=goog.html.SafeHtml.combineAttributes({src:a},{},b);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",a)};
goog.html.SafeHtml.createScript=function(a,b){for(var c in b){var d=c.toLowerCase();if("language"==d||"src"==d||"text"==d||"type"==d)throw Error('Cannot set "'+d+'" attribute');}c="";a=goog.array.concat(a);for(d=0;d<a.length;d++)c+=goog.html.SafeScript.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",b,a)};
goog.html.SafeHtml.createStyle=function(a,b){b=goog.html.SafeHtml.combineAttributes({type:"text/css"},{},b);var c="";a=goog.array.concat(a);for(var d=0;d<a.length;d++)c+=goog.html.SafeStyleSheet.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",b,a)};
goog.html.SafeHtml.createMetaRefresh=function(a,b){a=goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a));(goog.labs.userAgent.browser.isIE()||goog.labs.userAgent.browser.isEdge())&&goog.string.internal.contains(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'");return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta",{"http-equiv":"refresh",content:(b||0)+"; url="+a})};
goog.html.SafeHtml.getAttrNameAndValue_=function(a,b,c){if(c instanceof goog.string.Const)c=goog.string.Const.unwrap(c);else if("style"==b.toLowerCase())c=goog.html.SafeHtml.getStyleValue_(c);else {if(/^on/i.test(b))throw Error('Attribute "'+b+'" requires goog.string.Const value, "'+c+'" given.');if(b.toLowerCase()in goog.html.SafeHtml.URL_ATTRIBUTES_)if(c instanceof goog.html.TrustedResourceUrl)c=goog.html.TrustedResourceUrl.unwrap(c);else if(c instanceof goog.html.SafeUrl)c=goog.html.SafeUrl.unwrap(c);
else if(goog.isString(c))c=goog.html.SafeUrl.sanitize(c).getTypedStringValue();else throw Error('Attribute "'+b+'" on tag "'+a+'" requires goog.html.SafeUrl, goog.string.Const, or string, value "'+c+'" given.');}c.implementsGoogStringTypedString&&(c=c.getTypedStringValue());goog.asserts.assert(goog.isString(c)||goog.isNumber(c),"String or number value expected, got "+typeof c+" with value: "+c);return b+'="'+goog.string.internal.htmlEscape(String(c))+'"'};
goog.html.SafeHtml.getStyleValue_=function(a){if(!goog.isObject(a))throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, '+typeof a+" given: "+a);a instanceof goog.html.SafeStyle||(a=goog.html.SafeStyle.create(a));return goog.html.SafeStyle.unwrap(a)};goog.html.SafeHtml.createWithDir=function(a,b,c,d){b=goog.html.SafeHtml.create(b,c,d);b.dir_=a;return b};
goog.html.SafeHtml.join=function(a,b){a=goog.html.SafeHtml.htmlEscape(a);var c=a.getDirection(),d=[],e=function(a){goog.isArray(a)?goog.array.forEach(a,e):(a=goog.html.SafeHtml.htmlEscape(a),d.push(goog.html.SafeHtml.unwrap(a)),a=a.getDirection(),c==goog.i18n.bidi.Dir.NEUTRAL?c=a:a!=goog.i18n.bidi.Dir.NEUTRAL&&c!=a&&(c=null));};goog.array.forEach(b,e);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d.join(goog.html.SafeHtml.unwrap(a)),c)};
goog.html.SafeHtml.concat=function(a){return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY,Array.prototype.slice.call(arguments))};goog.html.SafeHtml.concatWithDir=function(a,b){var c=goog.html.SafeHtml.concat(goog.array.slice(arguments,1));c.dir_=a;return c};goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse=function(a,b){return (new goog.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(a,b)};
goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a,b){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a):a;this.dir_=b;return this};
goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse=function(a,b,c){var d=null;var e="<"+a+goog.html.SafeHtml.stringifyAttributes(a,b);goog.isDefAndNotNull(c)?goog.isArray(c)||(c=[c]):c=[];goog.dom.tags.isVoidTag(a.toLowerCase())?(goog.asserts.assert(!c.length,"Void tag <"+a+"> does not allow content."),e+=">"):(d=goog.html.SafeHtml.concat(c),e+=">"+goog.html.SafeHtml.unwrap(d)+"</"+a+">",d=d.getDirection());(a=b&&b.dir)&&(d=/^(ltr|rtl|auto)$/i.test(a)?goog.i18n.bidi.Dir.NEUTRAL:
null);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e,d)};goog.html.SafeHtml.stringifyAttributes=function(a,b){var c="";if(b)for(var d in b){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d))throw Error('Invalid attribute name "'+d+'".');var e=b[d];goog.isDefAndNotNull(e)&&(c+=" "+goog.html.SafeHtml.getAttrNameAndValue_(a,d,e));}return c};
goog.html.SafeHtml.combineAttributes=function(a,b,c){var d={},e;for(e in a)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=a[e];for(e in b)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=b[e];for(e in c){var f=e.toLowerCase();if(f in a)throw Error('Cannot override "'+f+'" attribute, got "'+e+'" with value "'+c[e]+'"');f in b&&delete d[f];d[e]=c[e];}return d};
goog.html.SafeHtml.DOCTYPE_HTML=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.EMPTY=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.BR=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.uncheckedconversions={};goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract=function(a,b,c){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b,c||null)};
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};goog.dom.asserts={};goog.dom.asserts.assertIsLocation=function(a){if(goog.asserts.ENABLE_ASSERTS){var b=goog.dom.asserts.getWindow_(a);b&&(!a||!(a instanceof b.Location)&&a instanceof b.Element)&&goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s",goog.dom.asserts.debugStringForType_(a));}return a};
goog.dom.asserts.assertIsElementType_=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=goog.dom.asserts.getWindow_(a);c&&"undefined"!=typeof c[b]&&(a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element))||goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,goog.dom.asserts.debugStringForType_(a)));}return a};goog.dom.asserts.assertIsHTMLAnchorElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAnchorElement")};
goog.dom.asserts.assertIsHTMLButtonElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLButtonElement")};goog.dom.asserts.assertIsHTMLLinkElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLLinkElement")};goog.dom.asserts.assertIsHTMLImageElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLImageElement")};goog.dom.asserts.assertIsHTMLAudioElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAudioElement")};
goog.dom.asserts.assertIsHTMLVideoElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLVideoElement")};goog.dom.asserts.assertIsHTMLInputElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLInputElement")};goog.dom.asserts.assertIsHTMLTextAreaElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLTextAreaElement")};goog.dom.asserts.assertIsHTMLCanvasElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLCanvasElement")};
goog.dom.asserts.assertIsHTMLEmbedElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLEmbedElement")};goog.dom.asserts.assertIsHTMLFormElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFormElement")};goog.dom.asserts.assertIsHTMLFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFrameElement")};goog.dom.asserts.assertIsHTMLIFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLIFrameElement")};
goog.dom.asserts.assertIsHTMLObjectElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLObjectElement")};goog.dom.asserts.assertIsHTMLScriptElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLScriptElement")};
goog.dom.asserts.debugStringForType_=function(a){if(goog.isObject(a))try{return a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a)}catch(b){return "<object could not be stringified>"}else return void 0===a?"undefined":null===a?"null":typeof a};goog.dom.asserts.getWindow_=function(a){try{var b=a&&a.ownerDocument,c=b&&(b.defaultView||b.parentWindow);c=c||goog.global;if(c.Element&&c.Location)return c}catch(d){}return null};goog.functions={};goog.functions.constant=function(a){return function(){return a}};goog.functions.FALSE=function(){return !1};goog.functions.TRUE=function(){return !0};goog.functions.NULL=function(){return null};goog.functions.identity=function(a,b){return a};goog.functions.error=function(a){return function(){throw Error(a);}};goog.functions.fail=function(a){return function(){throw a;}};
goog.functions.lock=function(a,b){b=b||0;return function(){return a.apply(this,Array.prototype.slice.call(arguments,0,b))}};goog.functions.nth=function(a){return function(){return arguments[a]}};goog.functions.partialRight=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.push.apply(b,c);return a.apply(this,b)}};goog.functions.withReturnValue=function(a,b){return goog.functions.sequence(a,goog.functions.constant(b))};
goog.functions.equalTo=function(a,b){return function(c){return b?a==c:a===c}};goog.functions.compose=function(a,b){var c=arguments,d=c.length;return function(){var a;d&&(a=c[d-1].apply(this,arguments));for(var b=d-2;0<=b;b--)a=c[b].call(this,a);return a}};goog.functions.sequence=function(a){var b=arguments,c=b.length;return function(){for(var a,e=0;e<c;e++)a=b[e].apply(this,arguments);return a}};
goog.functions.and=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(!b[a].apply(this,arguments))return !1;return !0}};goog.functions.or=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(b[a].apply(this,arguments))return !0;return !1}};goog.functions.not=function(a){return function(){return !a.apply(this,arguments)}};
goog.functions.create=function(a,b){var c=function(){};c.prototype=a.prototype;c=new c;a.apply(c,Array.prototype.slice.call(arguments,1));return c};goog.functions.CACHE_RETURN_VALUE=!0;goog.functions.cacheReturnValue=function(a){var b=!1,c;return function(){if(!goog.functions.CACHE_RETURN_VALUE)return a();b||(c=a(),b=!0);return c}};goog.functions.once=function(a){var b=a;return function(){if(b){var a=b;b=null;a();}}};
goog.functions.debounce=function(a,b,c){var d=0;return function(e){goog.global.clearTimeout(d);var f=arguments;d=goog.global.setTimeout(function(){a.apply(c,f);},b);}};goog.functions.throttle=function(a,b,c){var d=0,e=!1,f=[],g=function(){d=0;e&&(e=!1,h());},h=function(){d=goog.global.setTimeout(g,b);a.apply(c,f);};return function(a){f=arguments;d?e=!0:h();}};goog.functions.rateLimit=function(a,b,c){var d=0,e=function(){d=0;};return function(f){d||(d=goog.global.setTimeout(e,b),a.apply(c,arguments));}};goog.dom.safe={};goog.dom.safe.InsertAdjacentHtmlPosition={AFTERBEGIN:"afterbegin",AFTEREND:"afterend",BEFOREBEGIN:"beforebegin",BEFOREEND:"beforeend"};goog.dom.safe.insertAdjacentHtml=function(a,b,c){a.insertAdjacentHTML(b,goog.html.SafeHtml.unwrapTrustedHTML(c));};goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_={MATH:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};
goog.dom.safe.isInnerHtmlCleanupRecursive_=goog.functions.cacheReturnValue(function(){if(goog.DEBUG&&"undefined"===typeof document)return !1;var a=document.createElement("div"),b=document.createElement("div");b.appendChild(document.createElement("div"));a.appendChild(b);if(goog.DEBUG&&!a.firstChild)return !1;b=a.firstChild.firstChild;a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);return !b.parentElement});
goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse=function(a,b){if(goog.dom.safe.isInnerHtmlCleanupRecursive_())for(;a.lastChild;)a.removeChild(a.lastChild);a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b);};
goog.dom.safe.setInnerHtml=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=a.tagName.toUpperCase();if(goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c])throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of "+a.tagName+".");}goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a,b);};goog.dom.safe.setOuterHtml=function(a,b){a.outerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b);};
goog.dom.safe.setFormElementAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLFormElement(a).action=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setButtonFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLButtonElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b);};
goog.dom.safe.setInputFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLInputElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setStyle=function(a,b){a.style.cssText=goog.html.SafeStyle.unwrap(b);};goog.dom.safe.documentWrite=function(a,b){a.write(goog.html.SafeHtml.unwrapTrustedHTML(b));};
goog.dom.safe.setAnchorHref=function(a,b){goog.dom.asserts.assertIsHTMLAnchorElement(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setImageSrc=function(a,b){goog.dom.asserts.assertIsHTMLImageElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:image\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog.html.SafeUrl.unwrapTrustedURL(b);};
goog.dom.safe.setAudioSrc=function(a,b){goog.dom.asserts.assertIsHTMLAudioElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:audio\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog.html.SafeUrl.unwrapTrustedURL(b);};goog.dom.safe.setVideoSrc=function(a,b){goog.dom.asserts.assertIsHTMLVideoElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:video\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c);}a.src=goog.html.SafeUrl.unwrapTrustedURL(b);};
goog.dom.safe.setEmbedSrc=function(a,b){goog.dom.asserts.assertIsHTMLEmbedElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);};goog.dom.safe.setFrameSrc=function(a,b){goog.dom.asserts.assertIsHTMLFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b);};goog.dom.safe.setIframeSrc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b);};
goog.dom.safe.setIframeSrcdoc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.srcdoc=goog.html.SafeHtml.unwrapTrustedHTML(b);};
goog.dom.safe.setLinkHrefAndRel=function(a,b,c){goog.dom.asserts.assertIsHTMLLinkElement(a);a.rel=c;goog.string.internal.caseInsensitiveContains(c,"stylesheet")?(goog.asserts.assert(b instanceof goog.html.TrustedResourceUrl,'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'),a.href=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)):a.href=b instanceof goog.html.TrustedResourceUrl?goog.html.TrustedResourceUrl.unwrapTrustedURL(b):b instanceof goog.html.SafeUrl?goog.html.SafeUrl.unwrapTrustedURL(b):
goog.html.SafeUrl.unwrapTrustedURL(goog.html.SafeUrl.sanitizeAssertUnchanged(b));};goog.dom.safe.setObjectData=function(a,b){goog.dom.asserts.assertIsHTMLObjectElement(a);a.data=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);};goog.dom.safe.setScriptSrc=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b);};
goog.dom.safe.setScriptContent=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.text=goog.html.SafeScript.unwrapTrustedScript(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b);};goog.dom.safe.setLocationHref=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b);};
goog.dom.safe.assignLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.assign(goog.html.SafeUrl.unwrapTrustedURL(b));};goog.dom.safe.replaceLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.replace(goog.html.SafeUrl.unwrapTrustedURL(b));};
goog.dom.safe.openInWindow=function(a,b,c,d,e){a=a instanceof goog.html.SafeUrl?a:goog.html.SafeUrl.sanitizeAssertUnchanged(a);return (b||goog.global).open(goog.html.SafeUrl.unwrapTrustedURL(a),c?goog.string.Const.unwrap(c):"",d,e)};goog.dom.safe.parseFromStringHtml=function(a,b){return goog.dom.safe.parseFromString(a,b,"text/html")};goog.dom.safe.parseFromString=function(a,b,c){return a.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(b),c)};
goog.dom.safe.createImageFromBlob=function(a){if(!/^image\/.*/g.test(a.type))throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");var b=goog.global.URL.createObjectURL(a);a=new goog.global.Image;a.onload=function(){goog.global.URL.revokeObjectURL(b);};goog.dom.safe.setImageSrc(a,goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."),b));return a};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=goog.string.internal.startsWith;goog.string.endsWith=goog.string.internal.endsWith;goog.string.caseInsensitiveStartsWith=goog.string.internal.caseInsensitiveStartsWith;goog.string.caseInsensitiveEndsWith=goog.string.internal.caseInsensitiveEndsWith;goog.string.caseInsensitiveEquals=goog.string.internal.caseInsensitiveEquals;
goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};goog.string.isEmptyOrWhitespace=goog.string.internal.isEmptyOrWhitespace;goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};
goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return !/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return !/[^a-zA-Z]/.test(a)};goog.string.isNumeric=function(a){return !/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return !/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return " "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};
goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.string.internal.trim;
goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=goog.string.internal.caseInsensitiveCompare;
goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return -1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=goog.string.internal.newLineToBr;
goog.string.htmlEscape=function(a,b){a=goog.string.internal.htmlEscape(a,b);goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));return a};goog.string.E_RE_=/e/g;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'};var d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var e=c[a];if(e)return e;"#"==b.charAt(0)&&(b=Number("0"+b.substr(1)),isNaN(b)||(e=String.fromCharCode(b)));e||(goog.dom.safe.setInnerHtml(d,goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."),
a+" ")),e=d.firstChild.nodeValue.slice(0,-1));return c[a]=e})};goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return "&";case "lt":return "<";case "gt":return ">";case "quot":return '"';default:return "#"!=c.charAt(0)||(c=Number("0"+c.substr(1)),isNaN(c))?a:String.fromCharCode(c)}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e);}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"\\u003C"};goog.string.jsEscapeCache_={"'":"\\'"};
goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d));}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b=a.charCodeAt(0);if(31<b&&127>b)var c=a;else {if(256>b){if(c="\\x",16>b||256<b)c+="0";}else c="\\u",4096>b&&(c+="0");c+=b.toString(16).toUpperCase();}return goog.string.jsEscapeCache_[a]=c};goog.string.contains=goog.string.internal.contains;goog.string.caseInsensitiveContains=goog.string.internal.caseInsensitiveContains;
goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){return a.replace(b,"")};goog.string.removeAll=function(a,b){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,"")};goog.string.replaceAll=function(a,b,c){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,c.replace(/\$/g,"$$$$"))};
goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};
goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};goog.string.compareVersions=goog.string.internal.compareVersions;goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;
goog.string.createUniqueString=function(){return "goog_"+goog.string.uniqueStringCounter_++};goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return /^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return /^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};
goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};goog.string.toTitleCase=function(a,b){b=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(b?"|["+b+"]+":"")+")([a-z])","g"),function(a,b,e){return b+e.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};
goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.lastComponent=function(a,b){if(b)"string"==typeof b&&(b=[b]);else return a;for(var c=-1,d=0;d<b.length;d++)if(""!=b[d]){var e=a.lastIndexOf(b[d]);e>c&&(c=e);}return -1==c?a:a.slice(c+1)};
goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f];}return d[b.length]};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};goog.labs.userAgent.platform.isChromecast=function(){return goog.labs.userAgent.util.matchUserAgent("CrKey")};goog.labs.userAgent.platform.isKaiOS=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")};goog.labs.userAgent.platform.isGo2Phone=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP")};
goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isKaiOS()?(b=/(?:KaiOS)\/(\S+)/i,
b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.reflect={};goog.reflect.object=function(a,b){return b};goog.reflect.objectProperty=function(a,b){return a};goog.reflect.sinkValue=function(a){goog.reflect.sinkValue[" "](a);return a};goog.reflect.sinkValue[" "]=goog.nullFunction;goog.reflect.canAccessProperty=function(a,b){try{return goog.reflect.sinkValue(a[b]),!0}catch(c){}return !1};goog.reflect.cache=function(a,b,c,d){d=d?d(b):b;return Object.prototype.hasOwnProperty.call(a,d)?a[d]:a[d]=c(b)};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){a=goog.labs.userAgent.util.extractVersionTuples(a);var b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return "Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];a=a[0];var c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return ""};
goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){return (a=goog.array.find(a,function(a){return b==a[0]}))&&a[1]||""};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
goog.userAgent.getNavigatorTyped=function(){return goog.global.navigator||null};goog.userAgent.getNavigator=function(){return goog.userAgent.getNavigatorTyped()};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();
goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};
goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigatorTyped();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;
goog.userAgent.ASSUME_IPAD=!1;goog.userAgent.ASSUME_IPOD=!1;goog.userAgent.ASSUME_KAIOS=!1;goog.userAgent.ASSUME_GO2PHONE=!1;goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();
goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigatorTyped();return !!a&&goog.string.contains(a.appVersion||"","X11")};
goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();
goog.userAgent.IPOD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIpod();goog.userAgent.IOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIos();goog.userAgent.KAIOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_KAIOS:goog.labs.userAgent.platform.isKaiOS();goog.userAgent.GO2PHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_GO2PHONE:goog.labs.userAgent.platform.isGo2Phone();
goog.userAgent.determineVersion_=function(){var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),null!=b&&b>parseFloat(a))?String(b):a};
goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return /rv:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return /Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return /WebKit\/(\S+)/.exec(a);if(goog.userAgent.OPERA)return /(?:Version)[ \/]?(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};
goog.userAgent.VERSION=goog.userAgent.determineVersion_();goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_,a,function(){return 0<=goog.string.compareVersions(goog.userAgent.VERSION,a)})};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){if(goog.global.document&&goog.userAgent.IE)return goog.userAgent.getDocumentMode_()}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.DEFAULT_ALPHABET_COMMON_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"-_.";goog.crypt.base64.Alphabet={DEFAULT:0,NO_PADDING:1,WEBSAFE:2,WEBSAFE_DOT_PADDING:3,WEBSAFE_NO_PADDING:4};goog.crypt.base64.paddingChars_="=.";
goog.crypt.base64.isPadding_=function(a){return goog.string.contains(goog.crypt.base64.paddingChars_,a)};goog.crypt.base64.byteToCharMaps_={};goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;
goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");void 0===b&&(b=goog.crypt.base64.Alphabet.DEFAULT);goog.crypt.base64.init_();b=goog.crypt.base64.byteToCharMaps_[b];for(var c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,l=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[l],b[e],b[g]||"",b[k]||"");}return c.join("")};
goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a);});return c};
goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a);});return c};
goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=a.length,c=3*b/4;c%3?c=Math.floor(c):goog.crypt.base64.isPadding_(a[b-1])&&(c=goog.crypt.base64.isPadding_(a[b-2])?c-2:c-1);var d=new Uint8Array(c),e=0;goog.crypt.base64.decodeStringInternal_(a,function(a){d[e++]=a;});return d.subarray(0,e)};
goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h));}};
goog.crypt.base64.init_=function(){if(!goog.crypt.base64.charToByteMap_){goog.crypt.base64.charToByteMap_={};for(var a=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));goog.crypt.base64.byteToCharMaps_[c]=d;for(var e=0;e<d.length;e++){var f=d[e],g=goog.crypt.base64.charToByteMap_[f];void 0===g?goog.crypt.base64.charToByteMap_[f]=e:goog.asserts.assert(g===e);}}}};jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a;};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a;};
jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c;};
jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648);else if(isNaN(a))jspb.utils.split64High=0,jspb.utils.split64Low=2147483647;else if(a>jspb.BinaryConstants.FLOAT32_MAX)jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0;else if(a<jspb.BinaryConstants.FLOAT32_MIN)a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|
a)>>>0;else {var c=Math.floor(Math.log(a)/Math.LN2);a*=Math.pow(2,-c);a=Math.round(a*jspb.BinaryConstants.TWO_TO_23)&8388607;jspb.utils.split64High=0;jspb.utils.split64Low=(b<<31|c+127<<23|a)>>>0;}};
jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0;}else {c=
a;var d=0;if(2<=c)for(;2<=c&&1023>d;)d++,c/=2;else for(;1>c&&-1022<d;)c*=2,d--;c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c;}};
jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0;};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+(a>>>0)};
jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));a=jspb.utils.joinUint64(a,b);return c?-a:a};jspb.utils.toZigzag64=function(a,b,c){var d=b>>31;return c(a<<1^d,(b<<1|a>>>31)^d)};jspb.utils.joinZigzag64=function(a,b){return jspb.utils.fromZigzag64(a,b,jspb.utils.joinInt64)};jspb.utils.fromZigzag64=function(a,b,c){var d=-(a&1);return c((a>>>1|b<<31)^d,b>>>1^d)};
jspb.utils.joinFloat32=function(a,b){b=2*(a>>31)+1;var c=a>>>23&255;a&=8388607;return 255==c?a?NaN:Infinity*b:0==c?b*Math.pow(2,-149)*a:b*Math.pow(2,c-150)*(a+Math.pow(2,23))};jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047;a=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?a?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*a:c*Math.pow(2,d-1075)*(a+jspb.BinaryConstants.TWO_TO_52)};
jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");jspb.utils.ZERO_CHAR_CODE_=48;jspb.utils.A_CHAR_CODE_=97;
jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a,b){a=a?String(a):"";return b?"0000000".slice(a.length)+a:a}if(2097151>=b)return ""+jspb.utils.joinUint64(a,b);var d=(a>>>24|b<<8)>>>0&16777215;b=b>>16&65535;a=(a&16777215)+6777216*d+6710656*b;d+=8147497*b;b*=2;1E7<=a&&(d+=Math.floor(a/1E7),a%=1E7);1E7<=d&&(b+=Math.floor(d/1E7),d%=1E7);return c(b,0)+c(d,b)+c(a,1)};
jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);a=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+a:a};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(a,c):jspb.utils.joinUnsignedDecimalString(a,c)};
jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++)b=a*e[c]+b,e[c]=b&255,b>>>=8;}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255;}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,a.charCodeAt(f)-jspb.utils.ZERO_CHAR_CODE_);d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));};
jspb.utils.toHexDigit_=function(a){return String.fromCharCode(10>a?jspb.utils.ZERO_CHAR_CODE_+a:jspb.utils.A_CHAR_CODE_-10+a)};jspb.utils.fromHexCharCode_=function(a){return a>=jspb.utils.A_CHAR_CODE_?a-jspb.utils.A_CHAR_CODE_+10:a-jspb.utils.ZERO_CHAR_CODE_};jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.toHexDigit_(d>>4);b[2*c+3]=jspb.utils.toHexDigit_(d&15);}return b.join("")};
jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++){var d=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+2)),e=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+3));b=String.fromCharCode(16*d+e)+b;}return b};
jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinInt64(a,c):jspb.utils.joinUint64(a,c)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7;}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7;}if(a[b++]!=g)break;f++;b+=e;}return f};
jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7;}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g;}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16);}return b+'"'};
jspb.utils.debugScalarToTextFormat=function(a){return "string"===typeof a?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d;}return b};
jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||"undefined"!=typeof Buffer&&a.constructor===Buffer||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c);};jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this);};
jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};
jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=void 0!==b?b:0;this.end_=void 0!==c?this.start_+c:this.bytes_.length;this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a;};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};
jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a;};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
jspb.BinaryDecoder.prototype.readSplitVarint64=function(a){for(var b=128,c=0,d=0,e=0;4>e&&128<=b;e++)b=this.bytes_[this.cursor_++],c|=(b&127)<<7*e;128<=b&&(b=this.bytes_[this.cursor_++],c|=(b&127)<<28,d|=(b&127)>>4);if(128<=b)for(e=0;5>e&&128<=b;e++)b=this.bytes_[this.cursor_++],d|=(b&127)<<7*e+3;if(128>b)return a(c>>>0,d>>>0);goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=!0;};
jspb.BinaryDecoder.prototype.readSplitZigzagVarint64=function(a){return this.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryDecoder.prototype.readSplitFixed64=function(a){var b=this.bytes_,c=this.cursor_;this.cursor_+=8;for(var d=0,e=0,f=c+7;f>=c;f--)d=d<<8|b[f],e=e<<8|b[f+4];return a(d,e)};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++;};
jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--;};
jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a=this.bytes_;var b=a[this.cursor_+0];var c=b&127;if(128>b)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+1];c|=(b&127)<<7;if(128>b)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+2];c|=(b&127)<<14;if(128>b)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+3];c|=(b&127)<<21;if(128>b)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
this.end_),c;b=a[this.cursor_+4];c|=(b&15)<<28;if(128>b)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinUint64)};jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString)};
jspb.BinaryDecoder.prototype.readSignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinInt64)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){return this.readSplitVarint64(jspb.utils.joinZigzag64)};jspb.BinaryDecoder.prototype.readZigzagVarintHash64=function(){return this.readSplitZigzagVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};
jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8|c<<16|d<<24)>>>0};jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};
jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return !!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63);}else if(240>f){g=b[c++];var h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63);}else if(248>f){g=b[c++];h=b[c++];var k=b[c++];f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63;f-=65536;d.push((f>>10&1023)+55296,(f&1023)+56320);}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0);}e+=goog.crypt.byteArrayToString(d);
this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};jspb.BinaryDecoder.prototype.readVarintHash64=function(){return this.readSplitVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6];a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;};jspb.BinaryReader.instanceCache_=[];
jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this);};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isDelimited=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};
jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};
jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a);};
jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return !1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3;a&=7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type: %s (at position %s)",
a,this.fieldCursor_),this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return !0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_);};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader();};
jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint();};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else {var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a);}};
jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4);};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8);};
jspb.BinaryReader.prototype.skipGroup=function(){var a=this.nextField_;do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP){this.nextField_!=a&&(goog.asserts.fail("Unmatched end-group tag"),this.error_=!0);break}this.skipField();}while(1)};
jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.");}};
jspb.BinaryReader.prototype.registerReadCallback=function(a,b){null===this.readCallbacks_&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b;};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(null!==this.readCallbacks_);a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
default:goog.asserts.fail("Invalid field type in readAny()");}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32();d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c);};
jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0);};
jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a;a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return !!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readSintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarintHash64()};jspb.BinaryReader.prototype.readSplitVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(a)};
jspb.BinaryReader.prototype.readSplitZigzagVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
jspb.BinaryReader.prototype.readSplitFixed64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readSplitFixed64(a)};jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var b=this.decoder_.readUnsignedVarint32();b=this.decoder_.getCursor()+b;for(var c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};
jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};
jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};
jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};
jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};
jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};
jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.Map=function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_();};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1]);}this.arrClean=!0;};
jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray();}}}else {this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value]);}this.arrClean=!0;}return this.arr_};
jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value]);}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f);}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a;};
jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};"undefined"!=typeof Symbol&&(jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1;};
jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value]);}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)]);}return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this);}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage();}};
jspb.Map.deserializeBinary=function(a,b,c,d,e,f,g){for(;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g||(g=new a.valueCtor_),d.call(b,g,e)):g=d.call(b));}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g);};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0;};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e;};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f;};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return !!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.hiddenES6Property_=function(){};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedPrimitiveFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b]);};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:Array.isArray(a)};jspb.Message.isExtensionObject_=function(a){return null!==a&&"object"==typeof a&&!jspb.Message.isArray_(a)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)};
jspb.Message.initPivotAndExtensionObject_=function(a,b){var c=a.array.length,d=-1;if(c&&(d=c-1,c=a.array[d],jspb.Message.isExtensionObject_(c))){a.pivot_=jspb.Message.getFieldNumber_(a,d);a.extensionObject_=c;return}-1<b?(a.pivot_=Math.max(b,jspb.Message.getFieldNumber_(a,d+1)),a.extensionObject_=null):a.pivot_=Number.MAX_VALUE;};jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={});};
jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h;}}};
jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
else f.binaryWriterFn.call(b,g.fieldIndex,h);}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");if(c.isMessageType()){var g=new c.ctor;f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn);}else g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g);}else b.skipField();};
jspb.Message.getField=function(a,b){if(b<a.pivot_){b=jspb.Message.getIndex_(a,b);var c=a.array[b];return c===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[b]=[]:c}if(a.extensionObject_)return c=a.extensionObject_[b],c===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:c};jspb.Message.getRepeatedField=function(a,b){return jspb.Message.getField(a,b)};jspb.Message.getOptionalFloatingPointField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:+a};
jspb.Message.getBooleanField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:!!a};jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedPrimitiveFields_[b]=!0;}return c};
jspb.Message.getRepeatedBooleanField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=!!c[d];a.convertedPrimitiveFields_[b]=!0;}return c};
jspb.Message.bytesAsB64=function(a){if(null==a||"string"===typeof a)return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if("string"===typeof a)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return a.length&&"string"!==typeof a[0]?goog.array.map(a,jspb.Message.bytesAsB64):a};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b);});}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getBooleanFieldWithDefault=function(a,b,c){a=jspb.Message.getBooleanField(a,b);return null==a?c:a};
jspb.Message.getFloatingPointFieldWithDefault=function(a,b,c){a=jspb.Message.getOptionalFloatingPointField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];var e=jspb.Message.getField(a,b);if(!e){if(c)return;e=[];jspb.Message.setField(a,b,e);}return a.wrappers_[b]=new jspb.Map(e,d)};
jspb.Message.setField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);return a};jspb.Message.setProto3IntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};jspb.Message.setProto3FloatField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3BooleanField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,!1)};jspb.Message.setProto3StringField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3BytesField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3EnumField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3StringIntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"0")};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);c!==d?jspb.Message.setField(a,b,c):b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=null:(jspb.Message.maybeInitEmptyExtensionObject_(a),delete a.extensionObject_[b]);return a};
jspb.Message.addToRepeatedField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);b=jspb.Message.getRepeatedField(a,b);void 0!=d?b.splice(d,0,c):b.push(c);return a};jspb.Message.setOneofField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));return jspb.Message.setField(a,b,d)};
jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0));}return c?(jspb.Message.setField(a,c,d),c):0};jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e);}return a.wrappers_[c]};
jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e;}};
jspb.Message.setWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};jspb.Message.setOneofWrapperField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;return jspb.Message.setOneofField(a,b,c,e)};
jspb.Message.setRepeatedWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(Array.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray();}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return !this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray();b=b.toArray();var d=[],e=0,f=c.length>b.length?c.length:b.length;a.getJsPbMessageId()&&(d[0]=a.getJsPbMessageId(),e=1);for(;e<f;e++)jspb.Message.compareFields(c[e],b[e])||(d[e]=b[e]);return new a.constructor(d)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return !1;return !0};
jspb.Message.compareFields=function(a,b){if(a==b)return !0;if(!goog.isObject(a)||!goog.isObject(b))return "number"===typeof a&&isNaN(a)||"number"===typeof b&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return !1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return !1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return !1;return !0}if(a.constructor===Array){var d=void 0,e=void 0,f=Math.max(a.length,b.length);for(c=0;c<f;c++){var g=a[c],h=b[c];g&&
g.constructor==Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return !1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");a=jspb.Message.clone(a);for(var c=b.toArray(),d=a.toArray(),e=c.length=0;e<d.length;e++)c[e]=d[e];b.wrappers_=a.wrappers_;b.extensionObject_=a.extensionObject_;};
jspb.Message.clone_=function(a){if(Array.isArray(a)){for(var b=Array(a.length),c=0;c<a.length;c++){var d=a[c];null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);}return b}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);b={};for(c in a)d=a[c],null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);return b};jspb.Message.registerMessageType=function(a,b){b.messageId=a;};jspb.Message.messageSetExtensions={};
jspb.Message.messageSetExtensionsBinary={};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b;};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
jspb.arith.UInt64.prototype.msb=function(){return !!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return !!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){var c=a&65535;a>>>=16;var d=b&65535,e=b>>>16;b=c*d+65536*(c*e&65535)+65536*(a*d&65535);for(c=a*e+(c*e>>>16)+(a*d>>>16);4294967296<=b;)b-=4294967296,c+=1;return new jspb.arith.UInt64(b>>>0,c>>>0)};
jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
jspb.arith.UInt64.prototype.div=function(a){if(0==a)return [];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return [b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();){b=b.div(10);var c=b[0];a=b[1].lo+a;b=c;}""==a&&(a="0");return a};
jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c);}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b;};
jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return (a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryEncoder=function(){this.buffer_=[];};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a);};
jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b);};
jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a);};
jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else {for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1);}};
jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0);};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(a));};jspb.BinaryEncoder.prototype.writeZigzagVarintHash64=function(a){var b=this;jspb.utils.splitHash64(a);jspb.utils.toZigzag64(jspb.utils.split64Low,jspb.utils.split64High,function(a,d){b.writeSplitVarint64(a>>>0,d>>>0);});};
jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};
jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(Infinity===a||-Infinity===a||isNaN(a)||a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low);};
jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(Infinity===a||-Infinity===a||isNaN(a)||a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert("boolean"===typeof a||"number"===typeof a);this.buffer_.push(a?1:0);};
jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a);};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a);};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++);}else this.buffer_.push(d>>
12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128);}return this.buffer_.length-b};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[];};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length;};
jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop();b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++;};
jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c));};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c);};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[];};
jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length;}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a));};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop());};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b);};
jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()");}};
jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b));};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b));};
jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b));};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b));};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b));};
jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b));};jspb.BinaryWriter.prototype.writeZigzagVarintHash64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarintHash64(b));};
jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};jspb.BinaryWriter.prototype.writeInt32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};
jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b));};jspb.BinaryWriter.prototype.writeInt64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi));};
jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};jspb.BinaryWriter.prototype.writeUint32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b));};
jspb.BinaryWriter.prototype.writeUint64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi));};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b));};
jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b));};jspb.BinaryWriter.prototype.writeSintHash64=function(a,b){null!=b&&this.writeZigzagVarintHash64_(a,b);};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&this.writeZigzagVarint64String_(a,b);};
jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b));};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b));};
jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi));};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b));};
jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b));};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi));};
jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b));};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b));};
jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert("boolean"===typeof b||"number"===typeof b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b));};jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};
jspb.BinaryWriter.prototype.writeString=function(a,b){null!=b&&(a=this.beginDelimited_(a),this.encoder_.writeString(b),this.endDelimited_(a));};jspb.BinaryWriter.prototype.writeBytes=function(a,b){null!=b&&(b=jspb.utils.byteSourceToUint8Array(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),this.appendUint8Array_(b));};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a));};
jspb.BinaryWriter.prototype.writeMessageSet=function(a,b,c){null!=b&&(this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.START_GROUP),this.writeFieldHeader_(2,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(a),a=this.beginDelimited_(3),c(b,this),this.endDelimited_(a),this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.END_GROUP));};
jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP));};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b));};
jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b));};jspb.BinaryWriter.prototype.writeSplitFixed64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(b,c);};
jspb.BinaryWriter.prototype.writeSplitVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(b,c);};jspb.BinaryWriter.prototype.writeSplitZigzagVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);var d=this.encoder_;jspb.utils.toZigzag64(b,c,function(a,b){d.writeSplitVarint64(a>>>0,b>>>0);});};
jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitFixed64(a,c(b[e]),d(b[e]));};jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitVarint64(a,c(b[e]),d(b[e]));};jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitZigzagVarint64(a,c(b[e]),d(b[e]));};
jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarintHash64_(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e);}};
jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP);};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c]);};
jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c]);};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(b[c]);this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(parseInt(b[c],10));this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint64(b[c]);this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedSplitFixed64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitFixed64(c(b[e]),d(b[e]));this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedSplitVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitVarint64(c(b[e]),d(b[e]));this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=this.encoder_,f=0;f<b.length;f++)jspb.utils.toZigzag64(c(b[f]),d(b[f]),function(a,b){e.writeSplitVarint64(a>>>0,b>>>0);});this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.Int64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi);}this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(parseInt(b[c],10));this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint64(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi);}this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint32(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint64(b[c]);this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(b[c]));this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedSintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(b[c]);this.endDelimited_(a);}};
jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeUint32(b[a]);};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeUint64(b[a]);};
jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++){var c=jspb.arith.UInt64.fromString(b[a]);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};
jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeInt32(b[a]);};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64(b[a]);};
jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64String(b[a]);};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeFloat(b[a]);};
jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeDouble(b[a]);};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),a=0;a<b.length;a++)this.encoder_.writeBool(b[a]);};
jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeEnum(b[c]);this.endDelimited_(a);}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeFixedHash64(b[a]);};
jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeVarintHash64(b[c]);this.endDelimited_(a);}};jspb.Export={};googleProtobuf.Map=jspb.Map;googleProtobuf.Message=jspb.Message;googleProtobuf.BinaryReader=jspb.BinaryReader;googleProtobuf.BinaryWriter=jspb.BinaryWriter;googleProtobuf.ExtensionFieldInfo=jspb.ExtensionFieldInfo;googleProtobuf.ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo;googleProtobuf.exportSymbol=goog.exportSymbol;googleProtobuf.inherits=goog.inherits;googleProtobuf.object={extend:goog.object.extend};googleProtobuf.typeOf=goog.typeOf;

(function (exports) {
	// source: route_guide.proto
	/**
	 * @fileoverview
	 * @enhanceable
	 * @suppress {missingRequire} reports error on implicit type usages.
	 * @suppress {messageConventions} JS Compiler reports an error if a variable or
	 *     field starts with 'MSG_' and isn't a translatable message.
	 * @public
	 */
	// GENERATED CODE -- DO NOT EDIT!
	/* eslint-disable */
	// @ts-nocheck

	var jspb = googleProtobuf;
	var goog = jspb;
	var global = (function() {
	  if (this) { return this; }
	  if (typeof window !== 'undefined') { return window; }
	  if (typeof global !== 'undefined') { return global; }
	  if (typeof self !== 'undefined') { return self; }
	  return Function('return this')();
	}.call(null));

	goog.exportSymbol('proto.routeguide.Feature', null, global);
	goog.exportSymbol('proto.routeguide.Point', null, global);
	goog.exportSymbol('proto.routeguide.Rectangle', null, global);
	goog.exportSymbol('proto.routeguide.RouteNote', null, global);
	goog.exportSymbol('proto.routeguide.RouteSummary', null, global);
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.routeguide.Point = function(opt_data) {
	  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.routeguide.Point, jspb.Message);
	if (goog.DEBUG && !COMPILED) {
	  /**
	   * @public
	   * @override
	   */
	  proto.routeguide.Point.displayName = 'proto.routeguide.Point';
	}
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.routeguide.Rectangle = function(opt_data) {
	  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.routeguide.Rectangle, jspb.Message);
	if (goog.DEBUG && !COMPILED) {
	  /**
	   * @public
	   * @override
	   */
	  proto.routeguide.Rectangle.displayName = 'proto.routeguide.Rectangle';
	}
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.routeguide.Feature = function(opt_data) {
	  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.routeguide.Feature, jspb.Message);
	if (goog.DEBUG && !COMPILED) {
	  /**
	   * @public
	   * @override
	   */
	  proto.routeguide.Feature.displayName = 'proto.routeguide.Feature';
	}
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.routeguide.RouteNote = function(opt_data) {
	  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.routeguide.RouteNote, jspb.Message);
	if (goog.DEBUG && !COMPILED) {
	  /**
	   * @public
	   * @override
	   */
	  proto.routeguide.RouteNote.displayName = 'proto.routeguide.RouteNote';
	}
	/**
	 * Generated by JsPbCodeGenerator.
	 * @param {Array=} opt_data Optional initial data array, typically from a
	 * server response, or constructed directly in Javascript. The array is used
	 * in place and becomes part of the constructed object. It is not cloned.
	 * If no data is provided, the constructed object will be empty, but still
	 * valid.
	 * @extends {jspb.Message}
	 * @constructor
	 */
	proto.routeguide.RouteSummary = function(opt_data) {
	  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
	};
	goog.inherits(proto.routeguide.RouteSummary, jspb.Message);
	if (goog.DEBUG && !COMPILED) {
	  /**
	   * @public
	   * @override
	   */
	  proto.routeguide.RouteSummary.displayName = 'proto.routeguide.RouteSummary';
	}



	if (jspb.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.routeguide.Point.prototype.toObject = function(opt_includeInstance) {
	  return proto.routeguide.Point.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.routeguide.Point} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.Point.toObject = function(includeInstance, msg) {
	  var obj = {
	    latitude: jspb.Message.getFieldWithDefault(msg, 1, 0),
	    longitude: jspb.Message.getFieldWithDefault(msg, 2, 0)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.routeguide.Point}
	 */
	proto.routeguide.Point.deserializeBinary = function(bytes) {
	  var reader = new jspb.BinaryReader(bytes);
	  var msg = new proto.routeguide.Point;
	  return proto.routeguide.Point.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.routeguide.Point} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.routeguide.Point}
	 */
	proto.routeguide.Point.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setLatitude(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setLongitude(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.routeguide.Point.prototype.serializeBinary = function() {
	  var writer = new jspb.BinaryWriter();
	  proto.routeguide.Point.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.routeguide.Point} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.Point.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getLatitude();
	  if (f !== 0) {
	    writer.writeInt32(
	      1,
	      f
	    );
	  }
	  f = message.getLongitude();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	};


	/**
	 * optional int32 latitude = 1;
	 * @return {number}
	 */
	proto.routeguide.Point.prototype.getLatitude = function() {
	  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
	};


	/**
	 * @param {number} value
	 * @return {!proto.routeguide.Point} returns this
	 */
	proto.routeguide.Point.prototype.setLatitude = function(value) {
	  return jspb.Message.setProto3IntField(this, 1, value);
	};


	/**
	 * optional int32 longitude = 2;
	 * @return {number}
	 */
	proto.routeguide.Point.prototype.getLongitude = function() {
	  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
	};


	/**
	 * @param {number} value
	 * @return {!proto.routeguide.Point} returns this
	 */
	proto.routeguide.Point.prototype.setLongitude = function(value) {
	  return jspb.Message.setProto3IntField(this, 2, value);
	};





	if (jspb.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.routeguide.Rectangle.prototype.toObject = function(opt_includeInstance) {
	  return proto.routeguide.Rectangle.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.routeguide.Rectangle} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.Rectangle.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    lo: (f = msg.getLo()) && proto.routeguide.Point.toObject(includeInstance, f),
	    hi: (f = msg.getHi()) && proto.routeguide.Point.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.routeguide.Rectangle}
	 */
	proto.routeguide.Rectangle.deserializeBinary = function(bytes) {
	  var reader = new jspb.BinaryReader(bytes);
	  var msg = new proto.routeguide.Rectangle;
	  return proto.routeguide.Rectangle.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.routeguide.Rectangle} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.routeguide.Rectangle}
	 */
	proto.routeguide.Rectangle.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = new proto.routeguide.Point;
	      reader.readMessage(value,proto.routeguide.Point.deserializeBinaryFromReader);
	      msg.setLo(value);
	      break;
	    case 2:
	      var value = new proto.routeguide.Point;
	      reader.readMessage(value,proto.routeguide.Point.deserializeBinaryFromReader);
	      msg.setHi(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.routeguide.Rectangle.prototype.serializeBinary = function() {
	  var writer = new jspb.BinaryWriter();
	  proto.routeguide.Rectangle.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.routeguide.Rectangle} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.Rectangle.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getLo();
	  if (f != null) {
	    writer.writeMessage(
	      1,
	      f,
	      proto.routeguide.Point.serializeBinaryToWriter
	    );
	  }
	  f = message.getHi();
	  if (f != null) {
	    writer.writeMessage(
	      2,
	      f,
	      proto.routeguide.Point.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional Point lo = 1;
	 * @return {?proto.routeguide.Point}
	 */
	proto.routeguide.Rectangle.prototype.getLo = function() {
	  return /** @type{?proto.routeguide.Point} */ (
	    jspb.Message.getWrapperField(this, proto.routeguide.Point, 1));
	};


	/**
	 * @param {?proto.routeguide.Point|undefined} value
	 * @return {!proto.routeguide.Rectangle} returns this
	*/
	proto.routeguide.Rectangle.prototype.setLo = function(value) {
	  return jspb.Message.setWrapperField(this, 1, value);
	};


	/**
	 * Clears the message field making it undefined.
	 * @return {!proto.routeguide.Rectangle} returns this
	 */
	proto.routeguide.Rectangle.prototype.clearLo = function() {
	  return this.setLo(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.routeguide.Rectangle.prototype.hasLo = function() {
	  return jspb.Message.getField(this, 1) != null;
	};


	/**
	 * optional Point hi = 2;
	 * @return {?proto.routeguide.Point}
	 */
	proto.routeguide.Rectangle.prototype.getHi = function() {
	  return /** @type{?proto.routeguide.Point} */ (
	    jspb.Message.getWrapperField(this, proto.routeguide.Point, 2));
	};


	/**
	 * @param {?proto.routeguide.Point|undefined} value
	 * @return {!proto.routeguide.Rectangle} returns this
	*/
	proto.routeguide.Rectangle.prototype.setHi = function(value) {
	  return jspb.Message.setWrapperField(this, 2, value);
	};


	/**
	 * Clears the message field making it undefined.
	 * @return {!proto.routeguide.Rectangle} returns this
	 */
	proto.routeguide.Rectangle.prototype.clearHi = function() {
	  return this.setHi(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.routeguide.Rectangle.prototype.hasHi = function() {
	  return jspb.Message.getField(this, 2) != null;
	};





	if (jspb.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.routeguide.Feature.prototype.toObject = function(opt_includeInstance) {
	  return proto.routeguide.Feature.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.routeguide.Feature} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.Feature.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    name: jspb.Message.getFieldWithDefault(msg, 1, ""),
	    location: (f = msg.getLocation()) && proto.routeguide.Point.toObject(includeInstance, f)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.routeguide.Feature}
	 */
	proto.routeguide.Feature.deserializeBinary = function(bytes) {
	  var reader = new jspb.BinaryReader(bytes);
	  var msg = new proto.routeguide.Feature;
	  return proto.routeguide.Feature.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.routeguide.Feature} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.routeguide.Feature}
	 */
	proto.routeguide.Feature.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setName(value);
	      break;
	    case 2:
	      var value = new proto.routeguide.Point;
	      reader.readMessage(value,proto.routeguide.Point.deserializeBinaryFromReader);
	      msg.setLocation(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.routeguide.Feature.prototype.serializeBinary = function() {
	  var writer = new jspb.BinaryWriter();
	  proto.routeguide.Feature.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.routeguide.Feature} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.Feature.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getName();
	  if (f.length > 0) {
	    writer.writeString(
	      1,
	      f
	    );
	  }
	  f = message.getLocation();
	  if (f != null) {
	    writer.writeMessage(
	      2,
	      f,
	      proto.routeguide.Point.serializeBinaryToWriter
	    );
	  }
	};


	/**
	 * optional string name = 1;
	 * @return {string}
	 */
	proto.routeguide.Feature.prototype.getName = function() {
	  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
	};


	/**
	 * @param {string} value
	 * @return {!proto.routeguide.Feature} returns this
	 */
	proto.routeguide.Feature.prototype.setName = function(value) {
	  return jspb.Message.setProto3StringField(this, 1, value);
	};


	/**
	 * optional Point location = 2;
	 * @return {?proto.routeguide.Point}
	 */
	proto.routeguide.Feature.prototype.getLocation = function() {
	  return /** @type{?proto.routeguide.Point} */ (
	    jspb.Message.getWrapperField(this, proto.routeguide.Point, 2));
	};


	/**
	 * @param {?proto.routeguide.Point|undefined} value
	 * @return {!proto.routeguide.Feature} returns this
	*/
	proto.routeguide.Feature.prototype.setLocation = function(value) {
	  return jspb.Message.setWrapperField(this, 2, value);
	};


	/**
	 * Clears the message field making it undefined.
	 * @return {!proto.routeguide.Feature} returns this
	 */
	proto.routeguide.Feature.prototype.clearLocation = function() {
	  return this.setLocation(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.routeguide.Feature.prototype.hasLocation = function() {
	  return jspb.Message.getField(this, 2) != null;
	};





	if (jspb.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.routeguide.RouteNote.prototype.toObject = function(opt_includeInstance) {
	  return proto.routeguide.RouteNote.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.routeguide.RouteNote} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.RouteNote.toObject = function(includeInstance, msg) {
	  var f, obj = {
	    location: (f = msg.getLocation()) && proto.routeguide.Point.toObject(includeInstance, f),
	    message: jspb.Message.getFieldWithDefault(msg, 2, "")
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.routeguide.RouteNote}
	 */
	proto.routeguide.RouteNote.deserializeBinary = function(bytes) {
	  var reader = new jspb.BinaryReader(bytes);
	  var msg = new proto.routeguide.RouteNote;
	  return proto.routeguide.RouteNote.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.routeguide.RouteNote} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.routeguide.RouteNote}
	 */
	proto.routeguide.RouteNote.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = new proto.routeguide.Point;
	      reader.readMessage(value,proto.routeguide.Point.deserializeBinaryFromReader);
	      msg.setLocation(value);
	      break;
	    case 2:
	      var value = /** @type {string} */ (reader.readString());
	      msg.setMessage(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.routeguide.RouteNote.prototype.serializeBinary = function() {
	  var writer = new jspb.BinaryWriter();
	  proto.routeguide.RouteNote.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.routeguide.RouteNote} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.RouteNote.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getLocation();
	  if (f != null) {
	    writer.writeMessage(
	      1,
	      f,
	      proto.routeguide.Point.serializeBinaryToWriter
	    );
	  }
	  f = message.getMessage();
	  if (f.length > 0) {
	    writer.writeString(
	      2,
	      f
	    );
	  }
	};


	/**
	 * optional Point location = 1;
	 * @return {?proto.routeguide.Point}
	 */
	proto.routeguide.RouteNote.prototype.getLocation = function() {
	  return /** @type{?proto.routeguide.Point} */ (
	    jspb.Message.getWrapperField(this, proto.routeguide.Point, 1));
	};


	/**
	 * @param {?proto.routeguide.Point|undefined} value
	 * @return {!proto.routeguide.RouteNote} returns this
	*/
	proto.routeguide.RouteNote.prototype.setLocation = function(value) {
	  return jspb.Message.setWrapperField(this, 1, value);
	};


	/**
	 * Clears the message field making it undefined.
	 * @return {!proto.routeguide.RouteNote} returns this
	 */
	proto.routeguide.RouteNote.prototype.clearLocation = function() {
	  return this.setLocation(undefined);
	};


	/**
	 * Returns whether this field is set.
	 * @return {boolean}
	 */
	proto.routeguide.RouteNote.prototype.hasLocation = function() {
	  return jspb.Message.getField(this, 1) != null;
	};


	/**
	 * optional string message = 2;
	 * @return {string}
	 */
	proto.routeguide.RouteNote.prototype.getMessage = function() {
	  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
	};


	/**
	 * @param {string} value
	 * @return {!proto.routeguide.RouteNote} returns this
	 */
	proto.routeguide.RouteNote.prototype.setMessage = function(value) {
	  return jspb.Message.setProto3StringField(this, 2, value);
	};





	if (jspb.Message.GENERATE_TO_OBJECT) {
	/**
	 * Creates an object representation of this proto.
	 * Field names that are reserved in JavaScript and will be renamed to pb_name.
	 * Optional fields that are not set will be set to undefined.
	 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
	 * For the list of reserved names please see:
	 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
	 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
	 *     JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @return {!Object}
	 */
	proto.routeguide.RouteSummary.prototype.toObject = function(opt_includeInstance) {
	  return proto.routeguide.RouteSummary.toObject(opt_includeInstance, this);
	};


	/**
	 * Static version of the {@see toObject} method.
	 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
	 *     the JSPB instance for transitional soy proto support:
	 *     http://goto/soy-param-migration
	 * @param {!proto.routeguide.RouteSummary} msg The msg instance to transform.
	 * @return {!Object}
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.RouteSummary.toObject = function(includeInstance, msg) {
	  var obj = {
	    pointCount: jspb.Message.getFieldWithDefault(msg, 1, 0),
	    featureCount: jspb.Message.getFieldWithDefault(msg, 2, 0),
	    distance: jspb.Message.getFieldWithDefault(msg, 3, 0),
	    elapsedTime: jspb.Message.getFieldWithDefault(msg, 4, 0)
	  };

	  if (includeInstance) {
	    obj.$jspbMessageInstance = msg;
	  }
	  return obj;
	};
	}


	/**
	 * Deserializes binary data (in protobuf wire format).
	 * @param {jspb.ByteSource} bytes The bytes to deserialize.
	 * @return {!proto.routeguide.RouteSummary}
	 */
	proto.routeguide.RouteSummary.deserializeBinary = function(bytes) {
	  var reader = new jspb.BinaryReader(bytes);
	  var msg = new proto.routeguide.RouteSummary;
	  return proto.routeguide.RouteSummary.deserializeBinaryFromReader(msg, reader);
	};


	/**
	 * Deserializes binary data (in protobuf wire format) from the
	 * given reader into the given message object.
	 * @param {!proto.routeguide.RouteSummary} msg The message object to deserialize into.
	 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
	 * @return {!proto.routeguide.RouteSummary}
	 */
	proto.routeguide.RouteSummary.deserializeBinaryFromReader = function(msg, reader) {
	  while (reader.nextField()) {
	    if (reader.isEndGroup()) {
	      break;
	    }
	    var field = reader.getFieldNumber();
	    switch (field) {
	    case 1:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setPointCount(value);
	      break;
	    case 2:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setFeatureCount(value);
	      break;
	    case 3:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setDistance(value);
	      break;
	    case 4:
	      var value = /** @type {number} */ (reader.readInt32());
	      msg.setElapsedTime(value);
	      break;
	    default:
	      reader.skipField();
	      break;
	    }
	  }
	  return msg;
	};


	/**
	 * Serializes the message to binary data (in protobuf wire format).
	 * @return {!Uint8Array}
	 */
	proto.routeguide.RouteSummary.prototype.serializeBinary = function() {
	  var writer = new jspb.BinaryWriter();
	  proto.routeguide.RouteSummary.serializeBinaryToWriter(this, writer);
	  return writer.getResultBuffer();
	};


	/**
	 * Serializes the given message to binary data (in protobuf wire
	 * format), writing to the given BinaryWriter.
	 * @param {!proto.routeguide.RouteSummary} message
	 * @param {!jspb.BinaryWriter} writer
	 * @suppress {unusedLocalVariables} f is only used for nested messages
	 */
	proto.routeguide.RouteSummary.serializeBinaryToWriter = function(message, writer) {
	  var f = undefined;
	  f = message.getPointCount();
	  if (f !== 0) {
	    writer.writeInt32(
	      1,
	      f
	    );
	  }
	  f = message.getFeatureCount();
	  if (f !== 0) {
	    writer.writeInt32(
	      2,
	      f
	    );
	  }
	  f = message.getDistance();
	  if (f !== 0) {
	    writer.writeInt32(
	      3,
	      f
	    );
	  }
	  f = message.getElapsedTime();
	  if (f !== 0) {
	    writer.writeInt32(
	      4,
	      f
	    );
	  }
	};


	/**
	 * optional int32 point_count = 1;
	 * @return {number}
	 */
	proto.routeguide.RouteSummary.prototype.getPointCount = function() {
	  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
	};


	/**
	 * @param {number} value
	 * @return {!proto.routeguide.RouteSummary} returns this
	 */
	proto.routeguide.RouteSummary.prototype.setPointCount = function(value) {
	  return jspb.Message.setProto3IntField(this, 1, value);
	};


	/**
	 * optional int32 feature_count = 2;
	 * @return {number}
	 */
	proto.routeguide.RouteSummary.prototype.getFeatureCount = function() {
	  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
	};


	/**
	 * @param {number} value
	 * @return {!proto.routeguide.RouteSummary} returns this
	 */
	proto.routeguide.RouteSummary.prototype.setFeatureCount = function(value) {
	  return jspb.Message.setProto3IntField(this, 2, value);
	};


	/**
	 * optional int32 distance = 3;
	 * @return {number}
	 */
	proto.routeguide.RouteSummary.prototype.getDistance = function() {
	  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
	};


	/**
	 * @param {number} value
	 * @return {!proto.routeguide.RouteSummary} returns this
	 */
	proto.routeguide.RouteSummary.prototype.setDistance = function(value) {
	  return jspb.Message.setProto3IntField(this, 3, value);
	};


	/**
	 * optional int32 elapsed_time = 4;
	 * @return {number}
	 */
	proto.routeguide.RouteSummary.prototype.getElapsedTime = function() {
	  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
	};


	/**
	 * @param {number} value
	 * @return {!proto.routeguide.RouteSummary} returns this
	 */
	proto.routeguide.RouteSummary.prototype.setElapsedTime = function(value) {
	  return jspb.Message.setProto3IntField(this, 4, value);
	};


	goog.object.extend(exports, proto.routeguide); 
} (route_guide_pb$1));

var RouteGuideService_1;
var grpc = src$2;
var route_guide_pb = route_guide_pb$1;

function serialize_routeguide_Feature(arg) {
  if (!(arg instanceof route_guide_pb.Feature)) {
    throw new Error('Expected argument of type routeguide.Feature');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_routeguide_Feature(buffer_arg) {
  return route_guide_pb.Feature.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_routeguide_Point(arg) {
  if (!(arg instanceof route_guide_pb.Point)) {
    throw new Error('Expected argument of type routeguide.Point');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_routeguide_Point(buffer_arg) {
  return route_guide_pb.Point.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_routeguide_Rectangle(arg) {
  if (!(arg instanceof route_guide_pb.Rectangle)) {
    throw new Error('Expected argument of type routeguide.Rectangle');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_routeguide_Rectangle(buffer_arg) {
  return route_guide_pb.Rectangle.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_routeguide_RouteNote(arg) {
  if (!(arg instanceof route_guide_pb.RouteNote)) {
    throw new Error('Expected argument of type routeguide.RouteNote');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_routeguide_RouteNote(buffer_arg) {
  return route_guide_pb.RouteNote.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_routeguide_RouteSummary(arg) {
  if (!(arg instanceof route_guide_pb.RouteSummary)) {
    throw new Error('Expected argument of type routeguide.RouteSummary');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_routeguide_RouteSummary(buffer_arg) {
  return route_guide_pb.RouteSummary.deserializeBinary(new Uint8Array(buffer_arg));
}


// Interface exported by the server.
var RouteGuideService$1 = RouteGuideService_1 = {
  // A simple RPC.
//
// Obtains the feature at a given position.
//
// A feature with an empty name is returned if there's no feature at the given
// position.
getFeature: {
    path: '/routeguide.RouteGuide/GetFeature',
    requestStream: false,
    responseStream: false,
    requestType: route_guide_pb.Point,
    responseType: route_guide_pb.Feature,
    requestSerialize: serialize_routeguide_Point,
    requestDeserialize: deserialize_routeguide_Point,
    responseSerialize: serialize_routeguide_Feature,
    responseDeserialize: deserialize_routeguide_Feature,
  },
  // A server-to-client streaming RPC.
//
// Obtains the Features available within the given Rectangle.  Results are
// streamed rather than returned at once (e.g. in a response message with a
// repeated field), as the rectangle may cover a large area and contain a
// huge number of features.
listFeatures: {
    path: '/routeguide.RouteGuide/ListFeatures',
    requestStream: false,
    responseStream: true,
    requestType: route_guide_pb.Rectangle,
    responseType: route_guide_pb.Feature,
    requestSerialize: serialize_routeguide_Rectangle,
    requestDeserialize: deserialize_routeguide_Rectangle,
    responseSerialize: serialize_routeguide_Feature,
    responseDeserialize: deserialize_routeguide_Feature,
  },
  // A client-to-server streaming RPC.
//
// Accepts a stream of Points on a route being traversed, returning a
// RouteSummary when traversal is completed.
recordRoute: {
    path: '/routeguide.RouteGuide/RecordRoute',
    requestStream: true,
    responseStream: false,
    requestType: route_guide_pb.Point,
    responseType: route_guide_pb.RouteSummary,
    requestSerialize: serialize_routeguide_Point,
    requestDeserialize: deserialize_routeguide_Point,
    responseSerialize: serialize_routeguide_RouteSummary,
    responseDeserialize: deserialize_routeguide_RouteSummary,
  },
  // A Bidirectional streaming RPC.
//
// Accepts a stream of RouteNotes sent while a route is being traversed,
// while receiving other RouteNotes (e.g. from other users).
routeChat: {
    path: '/routeguide.RouteGuide/RouteChat',
    requestStream: true,
    responseStream: true,
    requestType: route_guide_pb.RouteNote,
    responseType: route_guide_pb.RouteNote,
    requestSerialize: serialize_routeguide_RouteNote,
    requestDeserialize: deserialize_routeguide_RouteNote,
    responseSerialize: serialize_routeguide_RouteNote,
    responseDeserialize: deserialize_routeguide_RouteNote,
  },
};

grpc.makeGenericClientConstructor(RouteGuideService$1);

const createRouteGuideServer = (routeGuideService) => ({
    getFeature: function (call, callback) {
        const result = new route_guide_pb$1.Feature();
        const point = call.request.toObject();
        const dbFeature = routeGuideService.checkFeature(point);
        if (!dbFeature) {
            result.setName('').setLocation(call.request);
            callback(null, result);
            return;
        }
        result
            .setName(dbFeature.name)
            .setLocation(new route_guide_pb$1.Point()
            .setLatitude(dbFeature.location.latitude)
            .setLongitude(dbFeature.location.longitude));
        callback(null, result);
    },
    listFeatures: function (call) {
        const rectangle = call.request.toObject();
        if (!rectangle.hi || !rectangle.lo)
            throw new Error('Wrong rectangle shape request');
        const featuresList = routeGuideService.listFeatures(rectangle.lo, rectangle.hi);
        featuresList.forEach((feature) => {
            call.write(new route_guide_pb$1.Feature()
                .setLocation(new route_guide_pb$1.Point()
                .setLatitude(feature.location.latitude)
                .setLongitude(feature.location.longitude))
                .setName(feature.name));
        });
        call.end();
    },
    recordRoute: function (call, callback) {
        const record = routeGuideService.recordRoute();
        const summary = new route_guide_pb$1.RouteSummary();
        call.on('data', (point) => {
            const { distance, feature_count, point_count, start_time } = record(point.toObject());
            summary
                .setDistance(distance | 0)
                .setFeatureCount(feature_count)
                .setPointCount(point_count)
                .setElapsedTime(process.hrtime(start_time)[0]);
        });
        call.on('end', () => {
            callback(null, summary);
        });
    },
    routeChat: function (call) {
        call.on('data', (note) => {
            const { location, message } = note.toObject();
            if (!location)
                throw new Error('Location is undefined');
            const currentNotes = routeGuideService.getNotes(location);
            currentNotes.forEach((currentNote) => call.write(new route_guide_pb$1.RouteNote().setMessage(currentNote.message)));
            routeGuideService.insertNote(location, { message });
        });
        call.on('end', () => {
            call.end();
        });
    },
});

class RouteGuideService {
    repository;
    COORD_FACTOR = 1e7;
    constructor(repository) {
        this.repository = repository;
    }
    checkFeature(point) {
        const feature = this.repository.getFeature(point);
        return (feature || {
            name: '',
            location: {
                latitude: point.latitude,
                longitude: point.longitude,
            },
        });
    }
    listFeatures(lo, hi) {
        const { top, right, left, bottom } = this.getBoundingRectangle(lo, hi);
        const featureList = this.repository.getAllFeatures();
        return featureList.filter((feature) => {
            if (!feature.name)
                return false;
            return (feature.location.longitude >= left &&
                feature.location.longitude <= right &&
                feature.location.latitude >= bottom &&
                feature.location.latitude <= top);
        });
    }
    insertNote(point, message) {
        this.repository.insertNote(point, message);
    }
    getNotes(point) {
        return this.repository.getNotes(point);
    }
    recordRoute() {
        let point_count = 0;
        let feature_count = 0;
        let distance = 0;
        let previous = null;
        let start_time = process.hrtime();
        return (point) => {
            point_count += 1;
            if (this.checkFeature(point).name !== '') {
                feature_count += 1;
            }
            if (previous != null) {
                distance += this.getDistance(previous, point);
            }
            previous = point;
            return {
                point_count,
                feature_count,
                distance,
                start_time,
            };
        };
    }
    getBoundingRectangle(lo, hi) {
        const left = Math.min(lo.longitude, hi.longitude);
        const right = Math.max(lo.longitude, hi.longitude);
        const top = Math.max(lo.latitude, hi.latitude);
        const bottom = Math.min(lo.latitude, hi.latitude);
        return {
            top,
            left,
            bottom,
            right,
        };
    }
    getDistance(start, end) {
        function toRadians(num) {
            return (num * Math.PI) / 180;
        }
        var R = 6371000; // earth radius in metres
        var lat1 = toRadians(start.latitude / this.COORD_FACTOR);
        var lat2 = toRadians(end.latitude / this.COORD_FACTOR);
        var lon1 = toRadians(start.longitude / this.COORD_FACTOR);
        var lon2 = toRadians(end.longitude / this.COORD_FACTOR);
        var deltalat = lat2 - lat1;
        var deltalon = lon2 - lon1;
        var a = Math.sin(deltalat / 2) * Math.sin(deltalat / 2) +
            Math.cos(lat1) *
                Math.cos(lat2) *
                Math.sin(deltalon / 2) *
                Math.sin(deltalon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
}

class InMemoryGuideRepository {
    dbPath = require$$1$3.join(__dirname + '/../assets/route_guide_db.json');
    featureList;
    notes;
    constructor() {
        const buff = require$$0.readFileSync(this.dbPath);
        const parsed = JSON.parse(buff.toString());
        this.featureList = parsed;
        this.notes = new Map();
    }
    insertNote(point, message) {
        const key = this.getPointMessageKey(point);
        const notes = this.notes.get(key) || [];
        notes.push(message);
        this.notes.set(key, notes);
    }
    getNotes(point) {
        const key = this.getPointMessageKey(point);
        return this.notes.get(key) || [];
    }
    getFeature(point) {
        for (let i = 0; i < this.featureList.length; i++) {
            const feature = this.featureList[i];
            if (feature.location.latitude === point.latitude &&
                feature.location.longitude === point.longitude) {
                return feature;
            }
        }
        return null;
    }
    getAllFeatures() {
        return this.featureList;
    }
    getPointMessageKey(point) {
        return `${point.latitude}_${point.longitude}`;
    }
}

dotenv.config();
const port = process.env.GRPC_SERVER_PORT || 50051;
const uri = `0.0.0.0:${port}`;
function createServer() {
    const server = new src$2.Server();
    console.log(`Listening on ${uri}`);
    server.addService(RouteGuideService_1, createRouteGuideServer(new RouteGuideService(new InMemoryGuideRepository())));
    server.bindAsync(uri, src$2.ServerCredentials.createInsecure(), (err) => {
        if (err)
            console.log(err);
    });
    return server;
}

createServer();
